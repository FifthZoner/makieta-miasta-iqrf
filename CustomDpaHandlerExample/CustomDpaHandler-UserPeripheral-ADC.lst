CC5X Version 3.8A,   File: C:\customdpa\CustomDpaHandlerExample\CustomDpaHandler-UserPeripheral-ADC.c  7. Jan 2025  16:38   Page 1

ADDR CODE  LINE SOURCE

           0001 
           0002 ; CC5X Version 3.8A, Copyright (c) B Knudsen Data
           0003 ; C compiler for the PICmicro family
           0004 ; ************   7. Jan 2025  16:38  *************
           0005 
           0006         processor  16LF18877
           0007         radix  DEC
           0008 
     0000  0009 INDF0       EQU   0x00
     0004  0010 FSR0        EQU   0x04
     0004  0011 FSR0L       EQU   0x04
     0000  0012 Carry       EQU   0
     0002  0013 Zero_       EQU   2
     0011  0014 TRISA       EQU   0x11
     0012  0015 TRISB       EQU   0x12
     0013  0016 TRISC       EQU   0x13
     008C  0017 ADRESL      EQU   0x8C
     008D  0018 ADRESH      EQU   0x8D
     0093  0019 ADCON0      EQU   0x93
     0098  0020 ADCLK       EQU   0x98
     1F38  0021 ANSELA      EQU   0x1F38
     0000  0022 ADGO        EQU   0
     0005  0023 ADCMD       EQU   5
     0070  0024 userReg0    EQU   0x70
     02A1  0025 DLEN        EQU   0x2A1
     02AE  0026 PNUM        EQU   0x2AE
     02AF  0027 PCMD        EQU   0x2AF
     04A0  0028 DpaRfMessage EQU   0x4A0
     0073  0029 par1        EQU   0x73
           0030 
0000 2900  0031         GOTO main
           0032 
           0033   ; FILE C:\customdpa\CustomDpaHandlerExample\..\Include\IQRF.h
           0034                         ;// *********************************************************************
           0035                         ;//                     IQRF OS basic include file                      *
           0036                         ;// *********************************************************************
           0037                         ;//
           0038                         ;// Online IQRF OS Reference Guide: http://www.iqrf.org/IQRF-OS-Reference-guide/
           0039                         ;//
           0040                         ;// Copyright (c) MICRORISC s.r.o.
           0041                         ;//
           0042                         ;// Intended for:
           0043                         ;//   HW: TR-72D, TR-76D, TR-77D, TR-78D, TR-75D, TR-72G, TR-76G, TR-75G, TR-82G
           0044                         ;//   OS: 4.06D, 4.06G
           0045                         ;//
           0046                         ;// File:    IQRF.h
           0047                         ;// Version: v1.00                                   Revision: 03/06/2022
           0048                         ;//
           0049                         ;// Revision history:
           0050                         ;//   v1.00: 03/06/2022  First release for OS 4.06D and 4.06G.
           0051                         ;//
           0052                         ;// *********************************************************************
           0053                         ;
           0054                         ;#if IQRFOS != 406
           0055                         ;    #error Invalid IQRF OS version, v4.06D or v4.06G is expected. Make sure matching header files and project IQRF OS version setting are used.
           0056                         ;#endif
           0057                         ;
           0058                         ;#if __CC5X__ < 3701
           0059                         ;    #warning Insufficient CC5X compiler version, V3.7A or higher is recommended.
           0060                         ;#endif
           0061                         ;
           0062                         ;#define OS_VERSION 0x46
           0063                         ;
           0064                         ;#if defined TR72D
           0065                         ;    #message Compilation for TR-72D modules (PIC16LF1938) and IQRF OS 4.06D.
           0066                         ;    #define TR7xD
           0067                         ;#elif defined TR76D
           0068                         ;    #message Compilation for TR-76D modules (PIC16LF1938) and IQRF OS 4.06D.
           0069                         ;    #define TR7xD
           0070                         ;#elif defined TR77D
           0071                         ;    #message Compilation for TR-77D modules (PIC16LF1938) and IQRF OS 4.06D.
           0072                         ;    #define TR7xD
           0073                         ;#elif defined TR78D
           0074                         ;    #message Compilation for TR-78D modules (PIC16LF1938) and IQRF OS 4.06D.
           0075                         ;    #define TR7xD
           0076                         ;#elif defined TR75D
           0077                         ;    #message Compilation for TR-75D modules (PIC16LF1938) and IQRF OS 4.06D.
           0078                         ;    #define TR7xD
           0079                         ;#elif defined TR72G
           0080                         ;    #message Compilation for TR-72G modules (PIC16LF18877) and IQRF OS 4.06G.
           0081                         ;    #define TR7xG
           0082                         ;#elif defined TR76G
           0083                         ;    #message Compilation for TR-76G modules (PIC16LF18877) and IQRF OS 4.06G.
           0084                         ;    #define TR7xG
           0085                         ;#elif defined TR75G
           0086                         ;    #message Compilation for TR-75G modules (PIC16LF18877) and IQRF OS 4.06G.
           0087                         ;    #define TR7xG
           0088                         ;#elif defined TR82G
           0089                         ;    #message Compilation for TR-82G modules (PIC16LF18877) and IQRF OS 4.06G.
           0090                         ;    #define TR8xG
           0091                         ;#else
           0092                         ;    #error Unsupported TR module type.
           0093                         ;#endif
           0094                         ;
           0095                         ;// TR-7xD
           0096                         ;#if defined TR7xD
           0097                         ;    #if _16LF1938 != 1
           0098                         ;        #pragma chip      PIC16LF1938
           0099                         ;    #endif
           0100                         ;    
           0101                         ;    #define MCU_ID    4
           0102                         ;    #define TR_FAMILY 1 // TR-7xD
           0103                         ;
           0104                         ;    #define _ACKDT    ACKDT
           0105                         ;    #define _ACKEN    ACKEN
           0106                         ;    #define _ACKSTAT  ACKSTAT
           0107                         ;    #define _BAUDCON  BAUDCON
           0108                         ;    #define _BF       BF
           0109                         ;    #define _CKE      CKE
           0110                         ;    #define _DACCON0  DACCON0
           0111                         ;    #define _DACCON1  DACCON1
           0112                         ;    #define _EEADRH   EEADRH
           0113                         ;    #define _EEADRL   EEADRL
           0114                         ;    #define _EECON1   EECON1
           0115                         ;    #define _EECON2   EECON2
           0116                         ;    #define _EEDATH   EEDATH
           0117                         ;    #define _EEDATL   EEDATL
           0118                         ;    #define _GO       GO
           0119                         ;    #define _PEN      PEN
           0120                         ;    #define _PR6      PR6
           0121                         ;    #define _RCEN     RCEN
           0122                         ;    #define _RCREG    RCREG
           0123                         ;    #define _RCSTA    RCSTA
           0124                         ;    #define _RW_      RW_
           0125                         ;    #define _SEN      SEN
           0126                         ;    #define _SMP      SMP
           0127                         ;    #define _SPBRGH   SPBRGH
           0128                         ;    #define _SPBRGL   SPBRGL
           0129                         ;    #define _SSPADD   SSPADD
           0130                         ;    #define _SSPBUF   SSPBUF
           0131                         ;    #define _SSPCON1  SSPCON1
           0132                         ;    #define _SSPCON2  SSPCON2
           0133                         ;    #define _SSPIF    SSPIF
           0134                         ;    #define _SSPEN    SSPEN
           0135                         ;    #define _SSPSTAT  SSPSTAT
           0136                         ;    #define _SWDTEN   SWDTEN
           0137                         ;    #define _T1SYNC_  T1SYNC_
           0138                         ;    #define _TMR1ON   TMR1ON
           0139                         ;    #define _TMR6     TMR6
           0140                         ;    #define _TMR6ON   TMR6ON
           0141                         ;    #define _TXREG    TXREG
           0142                         ;    #define _TXSTA    TXSTA
           0143                         ;    #define _WDTCON   WDTCON
           0144                         ;
           0145                         ;// TR-7xG, TR-8xG
           0146                         ;#elif defined TR7xG || defined TR8xG
           0147                         ;    #if _16LF18877 != 1
           0148                         ;        #pragma chip      PIC16LF18877
           0149                         ;    #endif
           0150                         ;    
           0151                         ;    #define MCU_ID    5
           0152                         ;    
           0153                         ;    #if defined TR7xG
           0154                         ;        #define TR_FAMILY 2 // TR-7xG
           0155                         ;    #else
           0156                         ;        #define TR_FAMILY 3 // TR-8xG
           0157                         ;    #endif
           0158                         ;
           0159                         ;    #define _ACKDT    SSP1CON2.5
           0160                         ;    #define _ACKEN    SSP1CON2.4
           0161                         ;    #define _ACKSTAT  SSP1CON2.6
           0162                         ;    #define _BAUDCON  BAUD1CON
           0163                         ;    #define _BF       SSP1STAT.0
           0164                         ;    #define _CKE      SSP1STAT.6
           0165                         ;    #define _DACCON0  DAC1CON0
           0166                         ;    #define _DACCON1  DAC1CON1
           0167                         ;    #define _EEADRH   NVMADRH
           0168                         ;    #define _EEADRL   NVMADRL
           0169                         ;    #define _EECON1   NVMCON1
           0170                         ;    #define _EECON2   NVMCON2
           0171                         ;    #define _EEDATH   NVMDATH
           0172                         ;    #define _EEDATL   NVMDATL
           0173                         ;    #define _GO       ADGO
           0174                         ;    #define _PEN      SSP1CON2.2
           0175                         ;    #define _PR6      T6PR
           0176                         ;    #define _RCEN     SSP1CON2.3
           0177                         ;    #define _RCREG    RC1REG
           0178                         ;    #define _RCSTA    RC1STA
           0179                         ;    #define _RW_      SSP1STAT.2
           0180                         ;    #define _SEN      SSP1CON2.0
           0181                         ;    #define _SMP      SSP1STAT.7
           0182                         ;    #define _SPBRGH   SP1BRGH
           0183                         ;    #define _SPBRGL   SP1BRGL
           0184                         ;    #define _SSPADD   SSP1ADD
           0185                         ;    #define _SSPBUF   SSP1BUF
           0186                         ;    #define _SSPCON1  SSP1CON1
           0187                         ;    #define _SSPCON2  SSP1CON2
           0188                         ;    #define _SSPIF    SSP1IF
           0189                         ;    #define _SSPEN    SSP1CON1.5
           0190                         ;    #define _SSPSTAT  SSP1STAT
           0191                         ;    #define _SWDTEN   WDTCON0.0
           0192                         ;    #define _T1SYNC_  T1CON.2
           0193                         ;    #define _TMR1ON   T1CON.0
           0194                         ;    #define _TMR6     T6TMR
           0195                         ;    #define _TMR6ON   T6CON.7
           0196                         ;    #define _TXREG    TX1REG
           0197                         ;    #define _TXSTA    TX1STA
           0198                         ;    #define _WDTCON   WDTCON0
           0199                         ;#else
           0200                         ;    #error Unsupported TR module family.
           0201                         ;#endif
           0202                         ;
           0203                         ;#pragma origin 0x100
     0000  0204         ORG 0x0100
           0205                         ;#pragma update_RP 0
           0206                         ;
           0207                         ;void APPLICATION();
           0208                         ;
           0209                         ;void main()                                 // Skipped during Upload
           0210                         ;{
           0211 main
           0212                         ;    APPLICATION();
0100 31B8  0213         MOVLP 0x38
0101 2200  0214         CALL  APPLICATION
0102 3180  0215         MOVLP 0x00
           0216                         ;}
0103 0063  0217         SLEEP
0104 2900  0218         GOTO main
           0219 
           0220   ; FILE C:\customdpa\CustomDpaHandlerExample\..\Include\IQRF-functions.h
           0221                         ;// *********************************************************************
           0222                         ;//                         IQRF OS functions                           *
           0223                         ;// *********************************************************************
           0224                         ;//
           0225                         ;// Online IQRF OS Reference Guide: http://www.iqrf.org/IQRF-OS-Reference-guide/
           0226                         ;//
           0227                         ;// Copyright (c) MICRORISC s.r.o.
           0228                         ;//
           0229                         ;// Intended for:
           0230                         ;//   HW: TR-72D, TR-76D, TR-77D, TR-78D, TR-75D, TR-72G, TR-76G, TR-75G, TR-82G
           0231                         ;//   OS: 4.06D, 4.06G
           0232                         ;//
           0233                         ;// File:    IQRF-functions.h
           0234                         ;// Version: v1.01                                   Revision: 05/12/2024
           0235                         ;//
           0236                         ;// Revision history:
           0237                         ;//   v1.01: 05/12/2024  The return value of the wasRFICrestarted function is different for TR-7xD and TR-7xG module lines.
           0238                         ;//   v1.00: 03/06/2022  First release for OS 4.06D and 4.06G.
           0239                         ;//
           0240                         ;// *********************************************************************
           0241                         ;
           0242                         ;#pragma optimize 0
           0243                         ;#pragma update_PAGE 0
           0244                         ;#pragma update_RP 0
           0245                         ;
           0246                         ;// Identification header for internal use only
           0247                         ;#pragma cdata[0x3800] = OS_VERSION /* OS Version */, MCU_ID /* MCU ID */, TR_FAMILY | 0x80 /*TR Family*/
           0248                         ;
           0249                         ;#define dummy_address   0x3810
           0250                         ;#pragma origin dummy_address
     0000  0251         ORG 0x3810
           0252                         ;void dummy()
           0253                         ;{
           0254 dummy
           0255                         ;  #asm
           0256                         ;    DW 0x2000
3810 2000  0257         DW    0x2000
           0258                         ;  #endasm
           0259                         ;  #pragma updateBank exit=UserBank_01
           0260                         ;}
3811 0008  0261         RETURN
           0262                         ;
           0263                         ;#define iqrfSleep_address   0x3816
           0264                         ;#pragma origin iqrfSleep_address
     0000  0265         ORG 0x3816
           0266                         ;void iqrfSleep()
           0267                         ;{
           0268 iqrfSleep
           0269                         ;  #asm
           0270                         ;    DW 0x2000
3816 2000  0271         DW    0x2000
           0272                         ;  #endasm
           0273                         ;  #pragma updateBank exit=UserBank_01
           0274                         ;}
3817 0008  0275         RETURN
           0276                         ;
           0277                         ;#define _debug_address  0x3819
           0278                         ;#pragma origin _debug_address
     0000  0279         ORG 0x3819
           0280                         ;void _debug()
           0281                         ;{
           0282 _debug
           0283                         ;  #asm
           0284                         ;    DW 0x2000
3819 2000  0285         DW    0x2000
           0286                         ;  #endasm
           0287                         ;  #pragma updateBank exit=UserBank_01
           0288                         ;}
381A 0008  0289         RETURN
           0290                         ;
           0291                         ;#define debug()     \
           0292                         ;    do {            \
           0293                         ;        _debug();   \
           0294                         ;        nop();      \
           0295                         ;    } while (0)
           0296                         ;
           0297                         ;#define moduleInfo_address  0x381c
           0298                         ;#pragma origin moduleInfo_address
     0000  0299         ORG 0x381C
           0300                         ;void moduleInfo()
           0301                         ;{
           0302 moduleInfo
           0303                         ;  #asm
           0304                         ;    DW 0x2000
381C 2000  0305         DW    0x2000
           0306                         ;  #endasm
           0307                         ;  #pragma updateBank exit=UserBank_01
           0308                         ;}
381D 0008  0309         RETURN
           0310                         ;
           0311                         ;#define pulsingLEDR_address 0x3822
           0312                         ;#pragma origin pulsingLEDR_address
     0000  0313         ORG 0x3822
           0314                         ;void pulsingLEDR()
           0315                         ;{
           0316 pulsingLEDR
           0317                         ;  #asm
           0318                         ;    DW 0x2000
3822 2000  0319         DW    0x2000
           0320                         ;  #endasm
           0321                         ;  #pragma updateBank exit=UserBank_01
           0322                         ;}
3823 0008  0323         RETURN
           0324                         ;
           0325                         ;#define pulseLEDR_address   0x3825
           0326                         ;#pragma origin pulseLEDR_address
     0000  0327         ORG 0x3825
           0328                         ;void pulseLEDR()
           0329                         ;{
           0330 pulseLEDR
           0331                         ;  #asm
           0332                         ;    DW 0x2000
3825 2000  0333         DW    0x2000
           0334                         ;  #endasm
           0335                         ;  #pragma updateBank exit=UserBank_01
           0336                         ;}
3826 0008  0337         RETURN
           0338                         ;
           0339                         ;#define stopLEDR_address    0x3828
           0340                         ;#pragma origin stopLEDR_address
     0000  0341         ORG 0x3828
           0342                         ;void stopLEDR()
           0343                         ;{
           0344 stopLEDR
           0345                         ;  #asm
           0346                         ;    DW 0x2000
3828 2000  0347         DW    0x2000
           0348                         ;  #endasm
           0349                         ;  #pragma updateBank exit=UserBank_01
           0350                         ;}
3829 0008  0351         RETURN
           0352                         ;
           0353                         ;#define pulsingLEDG_address 0x382b
           0354                         ;#pragma origin pulsingLEDG_address
     0000  0355         ORG 0x382B
           0356                         ;void pulsingLEDG()
           0357                         ;{
           0358 pulsingLEDG
           0359                         ;  #asm
           0360                         ;    DW 0x2000
382B 2000  0361         DW    0x2000
           0362                         ;  #endasm
           0363                         ;  #pragma updateBank exit=UserBank_01
           0364                         ;}
382C 0008  0365         RETURN
           0366                         ;
           0367                         ;#define pulseLEDG_address   0x382e
           0368                         ;#pragma origin pulseLEDG_address
     0000  0369         ORG 0x382E
           0370                         ;void pulseLEDG()
           0371                         ;{
           0372 pulseLEDG
           0373                         ;  #asm
           0374                         ;    DW 0x2000
382E 2000  0375         DW    0x2000
           0376                         ;  #endasm
           0377                         ;  #pragma updateBank exit=UserBank_01
           0378                         ;}
382F 0008  0379         RETURN
           0380                         ;
           0381                         ;#define stopLEDG_address    0x3831
           0382                         ;#pragma origin stopLEDG_address
     0000  0383         ORG 0x3831
           0384                         ;void stopLEDG()
           0385                         ;{
           0386 stopLEDG
           0387                         ;  #asm
           0388                         ;    DW 0x2000
3831 2000  0389         DW    0x2000
           0390                         ;  #endasm
           0391                         ;  #pragma updateBank exit=UserBank_01
           0392                         ;}
3832 0008  0393         RETURN
           0394                         ;
           0395                         ;#define setOnPulsingLED_address 0x3834
           0396                         ;#pragma origin setOnPulsingLED_address
     0000  0397         ORG 0x3834
           0398                         ;void setOnPulsingLED(uns8 ticks @ W)
           0399                         ;{
           0400 setOnPulsingLED
           0401                         ;  #asm
           0402                         ;    DW 0x2000
3834 2000  0403         DW    0x2000
           0404                         ;  #endasm
           0405                         ;  #pragma updateBank exit=UserBank_01
           0406                         ;}
3835 0008  0407         RETURN
           0408                         ;
           0409                         ;#define setOffPulsingLED_address    0x3837
           0410                         ;#pragma origin setOffPulsingLED_address
     0000  0411         ORG 0x3837
           0412                         ;void setOffPulsingLED(uns8 ticks @ W)
           0413                         ;{
           0414 setOffPulsingLED
           0415                         ;  #asm
           0416                         ;    DW 0x2000
3837 2000  0417         DW    0x2000
           0418                         ;  #endasm
           0419                         ;  #pragma updateBank exit=UserBank_01
           0420                         ;}
3838 0008  0421         RETURN
           0422                         ;
           0423                         ;#define eeReadByte_address  0x383a
           0424                         ;#pragma origin eeReadByte_address
     0000  0425         ORG 0x383A
           0426                         ;uns8 eeReadByte(uns8 address @ W)
           0427                         ;{
           0428 eeReadByte
           0429                         ;  #asm
           0430                         ;    DW 0x2000
383A 2000  0431         DW    0x2000
           0432                         ;  #endasm
           0433                         ;  #pragma updateBank exit=UserBank_01
           0434                         ;  return W;
383B 0008  0435         RETURN
           0436                         ;}
           0437                         ;
           0438                         ;#define eeReadData_address  0x383d
           0439                         ;#pragma origin eeReadData_address
     0000  0440         ORG 0x383D
           0441                         ;bit eeReadData(uns8 address @ param2, uns8 length @ W)
           0442                         ;{
           0443 eeReadData
           0444                         ;  #asm
           0445                         ;    DW 0x2000
383D 2000  0446         DW    0x2000
           0447                         ;  #endasm
           0448                         ;  #pragma updateBank exit=UserBank_01
           0449                         ;  return Carry;
383E 0008  0450         RETURN
           0451                         ;}
           0452                         ;
           0453                         ;#define eeWriteByte_address 0x3840
           0454                         ;#pragma origin eeWriteByte_address
     0000  0455         ORG 0x3840
           0456                         ;void eeWriteByte(uns8 address @ param2, uns8 data @ W)
           0457                         ;{
           0458 eeWriteByte
           0459                         ;  #asm
           0460                         ;    DW 0x2000
3840 2000  0461         DW    0x2000
           0462                         ;  #endasm
           0463                         ;  #pragma updateBank exit=UserBank_01
           0464                         ;}
3841 0008  0465         RETURN
           0466                         ;
           0467                         ;#define eeWriteData_address 0x3843
           0468                         ;#pragma origin eeWriteData_address
     0000  0469         ORG 0x3843
           0470                         ;void eeWriteData(uns8 address @ param2, uns8 length @ W)
           0471                         ;{
           0472 eeWriteData
           0473                         ;  #asm
           0474                         ;    DW 0x2000
3843 2000  0475         DW    0x2000
           0476                         ;  #endasm
           0477                         ;  #pragma updateBank exit=UserBank_01
           0478                         ;}
3844 0008  0479         RETURN
           0480                         ;
           0481                         ;#define readFromRAM_address 0x3846
           0482                         ;#pragma origin readFromRAM_address
     0000  0483         ORG 0x3846
           0484                         ;uns8 readFromRAM(uns16 address @ FSR0)
           0485                         ;{
           0486 readFromRAM
           0487                         ;  #asm
           0488                         ;    DW 0x2000
3846 2000  0489         DW    0x2000
           0490                         ;  #endasm
           0491                         ;  #pragma updateBank exit=UserBank_01
           0492                         ;  return W;
3847 0008  0493         RETURN
           0494                         ;}
           0495                         ;
           0496                         ;#define clearBufferINFO_address 0x384c
           0497                         ;#pragma origin clearBufferINFO_address
     0000  0498         ORG 0x384C
           0499                         ;void clearBufferINFO()
           0500                         ;{
           0501 clearBufferINFO
           0502                         ;  #asm
           0503                         ;    DW 0x2000
384C 2000  0504         DW    0x2000
           0505                         ;  #endasm
           0506                         ;  #pragma updateBank exit=UserBank_01
           0507                         ;}
384D 0008  0508         RETURN
           0509                         ;
           0510                         ;#define swapBufferINFO_address  0x384f
           0511                         ;#pragma origin swapBufferINFO_address
     0000  0512         ORG 0x384F
           0513                         ;void swapBufferINFO()
           0514                         ;{
           0515 swapBufferINFO
           0516                         ;  #asm
           0517                         ;    DW 0x2000
384F 2000  0518         DW    0x2000
           0519                         ;  #endasm
           0520                         ;  #pragma updateBank exit=UserBank_01
           0521                         ;}
3850 0008  0522         RETURN
           0523                         ;
           0524                         ;#define compareBufferINFO2RF_address    0x3852
           0525                         ;#pragma origin compareBufferINFO2RF_address
     0000  0526         ORG 0x3852
           0527                         ;bit compareBufferINFO2RF(uns8 length @ W)
           0528                         ;{
           0529 compareBufferINFO2RF
           0530                         ;  #asm
           0531                         ;    DW 0x2000
3852 2000  0532         DW    0x2000
           0533                         ;  #endasm
           0534                         ;  #pragma updateBank exit=UserBank_01
           0535                         ;  return Carry;
3853 0008  0536         RETURN
           0537                         ;}
           0538                         ;
           0539                         ;#define copyBufferINFO2COM_address  0x3855
           0540                         ;#pragma origin copyBufferINFO2COM_address
     0000  0541         ORG 0x3855
           0542                         ;void copyBufferINFO2COM()
           0543                         ;{
           0544 copyBufferINFO2COM
           0545                         ;  #asm
           0546                         ;    DW 0x2000
3855 2000  0547         DW    0x2000
           0548                         ;  #endasm
           0549                         ;  #pragma updateBank exit=UserBank_01
           0550                         ;}
3856 0008  0551         RETURN
           0552                         ;
           0553                         ;#define copyBufferINFO2RF_address   0x3858
           0554                         ;#pragma origin copyBufferINFO2RF_address
     0000  0555         ORG 0x3858
           0556                         ;void copyBufferINFO2RF()
           0557                         ;{
           0558 copyBufferINFO2RF
           0559                         ;  #asm
           0560                         ;    DW 0x2000
3858 2000  0561         DW    0x2000
           0562                         ;  #endasm
           0563                         ;  #pragma updateBank exit=UserBank_01
           0564                         ;}
3859 0008  0565         RETURN
           0566                         ;
           0567                         ;#define copyBufferRF2COM_address    0x385b
           0568                         ;#pragma origin copyBufferRF2COM_address
     0000  0569         ORG 0x385B
           0570                         ;void copyBufferRF2COM()
           0571                         ;{
           0572 copyBufferRF2COM
           0573                         ;  #asm
           0574                         ;    DW 0x2000
385B 2000  0575         DW    0x2000
           0576                         ;  #endasm
           0577                         ;  #pragma updateBank exit=UserBank_01
           0578                         ;}
385C 0008  0579         RETURN
           0580                         ;
           0581                         ;#define copyBufferRF2INFO_address   0x385e
           0582                         ;#pragma origin copyBufferRF2INFO_address
     0000  0583         ORG 0x385E
           0584                         ;void copyBufferRF2INFO()
           0585                         ;{
           0586 copyBufferRF2INFO
           0587                         ;  #asm
           0588                         ;    DW 0x2000
385E 2000  0589         DW    0x2000
           0590                         ;  #endasm
           0591                         ;  #pragma updateBank exit=UserBank_01
           0592                         ;}
385F 0008  0593         RETURN
           0594                         ;
           0595                         ;#define copyBufferCOM2RF_address    0x3861
           0596                         ;#pragma origin copyBufferCOM2RF_address
     0000  0597         ORG 0x3861
           0598                         ;void copyBufferCOM2RF()
           0599                         ;{
           0600 copyBufferCOM2RF
           0601                         ;  #asm
           0602                         ;    DW 0x2000
3861 2000  0603         DW    0x2000
           0604                         ;  #endasm
           0605                         ;  #pragma updateBank exit=UserBank_01
           0606                         ;}
3862 0008  0607         RETURN
           0608                         ;
           0609                         ;#define copyBufferCOM2INFO_address  0x3864
           0610                         ;#pragma origin copyBufferCOM2INFO_address
     0000  0611         ORG 0x3864
           0612                         ;void copyBufferCOM2INFO()
           0613                         ;{
           0614 copyBufferCOM2INFO
           0615                         ;  #asm
           0616                         ;    DW 0x2000
3864 2000  0617         DW    0x2000
           0618                         ;  #endasm
           0619                         ;  #pragma updateBank exit=UserBank_01
           0620                         ;}
3865 0008  0621         RETURN
           0622                         ;
           0623                         ;#define copyMemoryBlock_address 0x3867
           0624                         ;#pragma origin copyMemoryBlock_address
     0000  0625         ORG 0x3867
           0626                         ;void copyMemoryBlock(uns16 from @ FSR0, uns16 to @ FSR1, uns8 length @ W)
           0627                         ;{
           0628 copyMemoryBlock
           0629                         ;  #asm
           0630                         ;    DW 0x2000
3867 2000  0631         DW    0x2000
           0632                         ;  #endasm
           0633                         ; #pragma updateBank exit=UserBank_01
           0634                         ;}
3868 0008  0635         RETURN
           0636                         ;
           0637                         ;#define startDelay_address  0x386a
           0638                         ;#pragma origin startDelay_address
     0000  0639         ORG 0x386A
           0640                         ;void startDelay(uns8 ticks @ W)
           0641                         ;{
           0642 startDelay
           0643                         ;  #asm
           0644                         ;    DW 0x2000
386A 2000  0645         DW    0x2000
           0646                         ;  #endasm
           0647                         ;  #pragma updateBank exit=UserBank_01
           0648                         ;}
386B 0008  0649         RETURN
           0650                         ;
           0651                         ;#define startLongDelay_address  0x386d
           0652                         ;#pragma origin startLongDelay_address
     0000  0653         ORG 0x386D
           0654                         ;void startLongDelay(uns16 ticks @ param3)
           0655                         ;{
           0656 startLongDelay
           0657                         ;  #asm
           0658                         ;    DW 0x2000
386D 2000  0659         DW    0x2000
           0660                         ;  #endasm
           0661                         ;  #pragma updateBank exit=UserBank_01
           0662                         ;}
386E 0008  0663         RETURN
           0664                         ;
           0665                         ;#define isDelay_address 0x3870
           0666                         ;#pragma origin isDelay_address
     0000  0667         ORG 0x3870
           0668                         ;bit isDelay()
           0669                         ;{
           0670 isDelay
           0671                         ;  #asm
           0672                         ;    DW 0x2000
3870 2000  0673         DW    0x2000
           0674                         ;  #endasm
           0675                         ;  #pragma updateBank exit=UserBank_01
           0676                         ;  return Carry;
3871 0008  0677         RETURN
           0678                         ;}
           0679                         ;
           0680                         ;#define waitDelay_address   0x3873
           0681                         ;#pragma origin waitDelay_address
     0000  0682         ORG 0x3873
           0683                         ;void waitDelay(uns8 ticks @ W)
           0684                         ;{
           0685 waitDelay
           0686                         ;  #asm
           0687                         ;    DW 0x2000
3873 2000  0688         DW    0x2000
           0689                         ;  #endasm
           0690                         ;  #pragma updateBank exit=UserBank_01
           0691                         ;}
3874 0008  0692         RETURN
           0693                         ;
           0694                         ;#define waitMS_address  0x3876
           0695                         ;#pragma origin waitMS_address
     0000  0696         ORG 0x3876
           0697                         ;void waitMS(uns8 ms @ W)
           0698                         ;{
           0699 waitMS
           0700                         ;  #asm
           0701                         ;    DW 0x2000
3876 2000  0702         DW    0x2000
           0703                         ;  #endasm
           0704                         ;  #pragma updateBank exit=UserBank_01
           0705                         ;}
3877 0008  0706         RETURN
           0707                         ;
           0708                         ;#define startCapture_address    0x3879
           0709                         ;#pragma origin startCapture_address
     0000  0710         ORG 0x3879
           0711                         ;void startCapture()
           0712                         ;{
           0713 startCapture
           0714                         ;  #asm
           0715                         ;    DW 0x2000
3879 2000  0716         DW    0x2000
           0717                         ;  #endasm
           0718                         ;  #pragma updateBank exit=UserBank_01
           0719                         ;}
387A 0008  0720         RETURN
           0721                         ;
           0722                         ;#define captureTicks_address    0x387c
           0723                         ;#pragma origin captureTicks_address
     0000  0724         ORG 0x387C
           0725                         ;void captureTicks()
           0726                         ;{
           0727 captureTicks
           0728                         ;  #asm
           0729                         ;    DW 0x2000
387C 2000  0730         DW    0x2000
           0731                         ;  #endasm
           0732                         ;  #pragma updateBank exit=UserBank_01
           0733                         ;}
387D 0008  0734         RETURN
           0735                         ;
           0736                         ;#define waitNewTick_address 0x3882
           0737                         ;#pragma origin waitNewTick_address
     0000  0738         ORG 0x3882
           0739                         ;void waitNewTick()
           0740                         ;{
           0741 waitNewTick
           0742                         ;  #asm
           0743                         ;    DW 0x2000
3882 2000  0744         DW    0x2000
           0745                         ;  #endasm
           0746                         ;  #pragma updateBank exit=UserBank_01
           0747                         ;}
3883 0008  0748         RETURN
           0749                         ;
           0750                         ;#define enableSPI_address   0x3885
           0751                         ;#pragma origin enableSPI_address
     0000  0752         ORG 0x3885
           0753                         ;void enableSPI()
           0754                         ;{
           0755 enableSPI
           0756                         ;  #asm
           0757                         ;    DW 0x2000
3885 2000  0758         DW    0x2000
           0759                         ;  #endasm
           0760                         ;  #pragma updateBank exit=UserBank_01
           0761                         ;}
3886 0008  0762         RETURN
           0763                         ;
           0764                         ;#define disableSPI_address  0x3888
           0765                         ;#pragma origin disableSPI_address
     0000  0766         ORG 0x3888
           0767                         ;void disableSPI()
           0768                         ;{
           0769 disableSPI
           0770                         ;  #asm
           0771                         ;    DW 0x2000
3888 2000  0772         DW    0x2000
           0773                         ;  #endasm
           0774                         ;  #pragma updateBank exit=UserBank_01
           0775                         ;}
3889 0008  0776         RETURN
           0777                         ;
           0778                         ;#define startSPI_address    0x388b
           0779                         ;#pragma origin startSPI_address
     0000  0780         ORG 0x388B
           0781                         ;void startSPI(uns8 length @ W)
           0782                         ;{
           0783 startSPI
           0784                         ;  #asm
           0785                         ;    DW 0x2000
388B 2000  0786         DW    0x2000
           0787                         ;  #endasm
           0788                         ;  #pragma updateBank exit=UserBank_01
           0789                         ;}
388C 0008  0790         RETURN
           0791                         ;
           0792                         ;#define stopSPI_address 0x388e
           0793                         ;#pragma origin stopSPI_address
     0000  0794         ORG 0x388E
           0795                         ;void stopSPI()
           0796                         ;{
           0797 stopSPI
           0798                         ;  #asm
           0799                         ;    DW 0x2000
388E 2000  0800         DW    0x2000
           0801                         ;  #endasm
           0802                         ;  #pragma updateBank exit=UserBank_01
           0803                         ;}
388F 0008  0804         RETURN
           0805                         ;
           0806                         ;#define restartSPI_address  0x3891
           0807                         ;#pragma origin restartSPI_address
     0000  0808         ORG 0x3891
           0809                         ;void restartSPI()
           0810                         ;{
           0811 restartSPI
           0812                         ;  #asm
           0813                         ;    DW 0x2000
3891 2000  0814         DW    0x2000
           0815                         ;  #endasm
           0816                         ;  #pragma updateBank exit=UserBank_01
           0817                         ;}
3892 0008  0818         RETURN
           0819                         ;
           0820                         ;#define getStatusSPI_address    0x3894
           0821                         ;#pragma origin getStatusSPI_address
     0000  0822         ORG 0x3894
           0823                         ;bit getStatusSPI()
           0824                         ;{
           0825 getStatusSPI
           0826                         ;  #asm
           0827                         ;    DW 0x2000
3894 2000  0828         DW    0x2000
           0829                         ;  #endasm
           0830                         ;  #pragma updateBank exit=UserBank_01
           0831                         ;  return Carry;
3895 0008  0832         RETURN
           0833                         ;}
           0834                         ;
           0835                         ;#define setRFpower_address  0x3897
           0836                         ;#pragma origin setRFpower_address
     0000  0837         ORG 0x3897
           0838                         ;void setRFpower(uns8 level @ W)
           0839                         ;{
           0840 setRFpower
           0841                         ;  #asm
           0842                         ;    DW 0x2000
3897 2000  0843         DW    0x2000
           0844                         ;  #endasm
           0845                         ;  #pragma updateBank exit=UserBank_01
           0846                         ;}
3898 0008  0847         RETURN
           0848                         ;
           0849                         ;#define setLEDG_address 0x389a
           0850                         ;#pragma origin setLEDG_address
     0000  0851         ORG 0x389A
           0852                         ;void setLEDG()
           0853                         ;{
           0854 setLEDG
           0855                         ;  #asm
           0856                         ;    DW 0x2000
389A 2000  0857         DW    0x2000
           0858                         ;  #endasm
           0859                         ;  #pragma updateBank exit=UserBank_01
           0860                         ;}
389B 0008  0861         RETURN
           0862                         ;
           0863                         ;#define setRFchannel_address    0x389d
           0864                         ;#pragma origin setRFchannel_address
     0000  0865         ORG 0x389D
           0866                         ;void setRFchannel(uns8 channel @ W)
           0867                         ;{
           0868 setRFchannel
           0869                         ;  #asm
           0870                         ;    DW 0x2000
389D 2000  0871         DW    0x2000
           0872                         ;  #endasm
           0873                         ;  #pragma updateBank exit=UserBank_01
           0874                         ;}
389E 0008  0875         RETURN
           0876                         ;
           0877                         ;#define setRFmode_address   0x38a0
           0878                         ;#pragma origin setRFmode_address
     0000  0879         ORG 0x38A0
           0880                         ;void setRFmode(uns8 mode @ W)
           0881                         ;{
           0882 setRFmode
           0883                         ;  #asm
           0884                         ;    DW 0x2000
38A0 2000  0885         DW    0x2000
           0886                         ;  #endasm
           0887                         ;  #pragma updateBank exit=UserBank_01
           0888                         ;}
38A1 0008  0889         RETURN
           0890                         ;
           0891                         ;#define setRFspeed_address  0x38a3
           0892                         ;#pragma origin setRFspeed_address
     0000  0893         ORG 0x38A3
           0894                         ;void setRFspeed(uns8 speed @ W)
           0895                         ;{
           0896 setRFspeed
           0897                         ;  #asm
           0898                         ;    DW 0x2000
38A3 2000  0899         DW    0x2000
           0900                         ;  #endasm
           0901                         ;  #pragma updateBank exit=UserBank_01
           0902                         ;}
38A4 0008  0903         RETURN
           0904                         ;
           0905                         ;#define setRFsleep_address  0x38a6
           0906                         ;#pragma origin setRFsleep_address
     0000  0907         ORG 0x38A6
           0908                         ;void setRFsleep()
           0909                         ;{
           0910 setRFsleep
           0911                         ;  #asm
           0912                         ;    DW 0x2000
38A6 2000  0913         DW    0x2000
           0914                         ;  #endasm
           0915                         ;  #pragma updateBank exit=UserBank_01
           0916                         ;}
38A7 0008  0917         RETURN
           0918                         ;
           0919                         ;#define setRFready_address  0x38a9
           0920                         ;#pragma origin setRFready_address
     0000  0921         ORG 0x38A9
           0922                         ;void setRFready()
           0923                         ;{
           0924 setRFready
           0925                         ;  #asm
           0926                         ;    DW 0x2000
38A9 2000  0927         DW    0x2000
           0928                         ;  #endasm
           0929                         ;  #pragma updateBank exit=UserBank_01
           0930                         ;}
38AA 0008  0931         RETURN
           0932                         ;
           0933                         ;#define RFTXpacket_address  0x38ac
           0934                         ;#pragma origin RFTXpacket_address
     0000  0935         ORG 0x38AC
           0936                         ;void RFTXpacket()
           0937                         ;{
           0938 RFTXpacket
           0939                         ;  #asm
           0940                         ;    DW 0x2000
38AC 2000  0941         DW    0x2000
           0942                         ;  #endasm
           0943                         ;  #pragma updateBank exit=UserBank_01
           0944                         ;}
38AD 0008  0945         RETURN
           0946                         ;
           0947                         ;#define RFRXpacket_address  0x38af
           0948                         ;#pragma origin RFRXpacket_address
     0000  0949         ORG 0x38AF
           0950                         ;bit RFRXpacket()
           0951                         ;{
           0952 RFRXpacket
           0953                         ;  #asm
           0954                         ;    DW 0x2000
38AF 2000  0955         DW    0x2000
           0956                         ;  #endasm
           0957                         ;  #pragma updateBank exit=UserBank_01
           0958                         ;  return Carry;
38B0 0008  0959         RETURN
           0960                         ;}
           0961                         ;
           0962                         ;#define checkRF_address 0x38b2
           0963                         ;#pragma origin checkRF_address
     0000  0964         ORG 0x38B2
           0965                         ;bit checkRF(uns8 level @ W)
           0966                         ;{
           0967 checkRF
           0968                         ;  #asm
           0969                         ;    DW 0x2000
38B2 2000  0970         DW    0x2000
           0971                         ;  #endasm
           0972                         ;  #pragma updateBank exit=UserBank_01
           0973                         ;  return Carry;
38B3 0008  0974         RETURN
           0975                         ;}
           0976                         ;
           0977                         ;#define amIBonded_address   0x38b8
           0978                         ;#pragma origin amIBonded_address
     0000  0979         ORG 0x38B8
           0980                         ;bit amIBonded()
           0981                         ;{
           0982 amIBonded
           0983                         ;  #asm
           0984                         ;    DW 0x2000
38B8 2000  0985         DW    0x2000
           0986                         ;  #endasm
           0987                         ;  #pragma updateBank exit=UserBank_01
           0988                         ;  return Carry;
38B9 0008  0989         RETURN
           0990                         ;}
           0991                         ;
           0992                         ;#define removeBond_address  0x38bb
           0993                         ;#pragma origin removeBond_address
     0000  0994         ORG 0x38BB
           0995                         ;void removeBond()
           0996                         ;{
           0997 removeBond
           0998                         ;  #asm
           0999                         ;    DW 0x2000
38BB 2000  1000         DW    0x2000
           1001                         ;  #endasm
           1002                         ;  #pragma updateBank exit=UserBank_01
           1003                         ;}
38BC 0008  1004         RETURN
           1005                         ;
           1006                         ;#define bondNewNode_address 0x38be
           1007                         ;#pragma origin bondNewNode_address
     0000  1008         ORG 0x38BE
           1009                         ;bit bondNewNode(uns8 address @ W)
           1010                         ;{
           1011 bondNewNode
           1012                         ;  #asm
           1013                         ;    DW 0x2000
38BE 2000  1014         DW    0x2000
           1015                         ;  #endasm
           1016                         ;  #pragma updateBank exit=UserBank_01
           1017                         ;  return Carry;
38BF 0008  1018         RETURN
           1019                         ;}
           1020                         ;
           1021                         ;#define isBondedNode_address    0x38c1
           1022                         ;#pragma origin isBondedNode_address
     0000  1023         ORG 0x38C1
           1024                         ;bit isBondedNode(uns8 address @ W)
           1025                         ;{
           1026 isBondedNode
           1027                         ;  #asm
           1028                         ;    DW 0x2000
38C1 2000  1029         DW    0x2000
           1030                         ;  #endasm
           1031                         ;  #pragma updateBank exit=UserBank_01
           1032                         ;  return Carry;
38C2 0008  1033         RETURN
           1034                         ;}
           1035                         ;
           1036                         ;#define removeBondedNode_address    0x38c4
           1037                         ;#pragma origin removeBondedNode_address
     0000  1038         ORG 0x38C4
           1039                         ;void removeBondedNode(uns8 address @ W)
           1040                         ;{
           1041 removeBondedNode
           1042                         ;  #asm
           1043                         ;    DW 0x2000
38C4 2000  1044         DW    0x2000
           1045                         ;  #endasm
           1046                         ;  #pragma updateBank exit=UserBank_01
           1047                         ;}
38C5 0008  1048         RETURN
           1049                         ;
           1050                         ;#define rebondNode_address  0x38c7
           1051                         ;#pragma origin rebondNode_address
     0000  1052         ORG 0x38C7
           1053                         ;bit rebondNode(uns8 address @ W)
           1054                         ;{
           1055 rebondNode
           1056                         ;  #asm
           1057                         ;    DW 0x2000
38C7 2000  1058         DW    0x2000
           1059                         ;  #endasm
           1060                         ;  #pragma updateBank exit=UserBank_01
           1061                         ;  return Carry;
38C8 0008  1062         RETURN
           1063                         ;}
           1064                         ;
           1065                         ;#define clearAllBonds_address   0x38ca
           1066                         ;#pragma origin clearAllBonds_address
     0000  1067         ORG 0x38CA
           1068                         ;void clearAllBonds()
           1069                         ;{
           1070 clearAllBonds
           1071                         ;  #asm
           1072                         ;    DW 0x2000
38CA 2000  1073         DW    0x2000
           1074                         ;  #endasm
           1075                         ;  #pragma updateBank exit=UserBank_01
           1076                         ;}
38CB 0008  1077         RETURN
           1078                         ;
           1079                         ;#define setNonetMode_address    0x38cd
           1080                         ;#pragma origin setNonetMode_address
     0000  1081         ORG 0x38CD
           1082                         ;void setNonetMode()
           1083                         ;{
           1084 setNonetMode
           1085                         ;  #asm
           1086                         ;    DW 0x2000
38CD 2000  1087         DW    0x2000
           1088                         ;  #endasm
           1089                         ;  #pragma updateBank exit=UserBank_01
           1090                         ;}
38CE 0008  1091         RETURN
           1092                         ;
           1093                         ;#define setCoordinatorMode_address  0x38d0
           1094                         ;#pragma origin setCoordinatorMode_address
     0000  1095         ORG 0x38D0
           1096                         ;void setCoordinatorMode()
           1097                         ;{
           1098 setCoordinatorMode
           1099                         ;  #asm
           1100                         ;    DW 0x2000
38D0 2000  1101         DW    0x2000
           1102                         ;  #endasm
           1103                         ;  #pragma updateBank exit=UserBank_01
           1104                         ;}
38D1 0008  1105         RETURN
           1106                         ;
           1107                         ;#define setNodeMode_address 0x38d3
           1108                         ;#pragma origin setNodeMode_address
     0000  1109         ORG 0x38D3
           1110                         ;void setNodeMode()
           1111                         ;{
           1112 setNodeMode
           1113                         ;  #asm
           1114                         ;    DW 0x2000
38D3 2000  1115         DW    0x2000
           1116                         ;  #endasm
           1117                         ;  #pragma updateBank exit=UserBank_01
           1118                         ;}
38D4 0008  1119         RETURN
           1120                         ;
           1121                         ;#define setNetworkFilteringOn_address   0x38d6
           1122                         ;#pragma origin setNetworkFilteringOn_address
     0000  1123         ORG 0x38D6
           1124                         ;void setNetworkFilteringOn()
           1125                         ;{
           1126 setNetworkFilteringOn
           1127                         ;  #asm
           1128                         ;    DW 0x2000
38D6 2000  1129         DW    0x2000
           1130                         ;  #endasm
           1131                         ;  #pragma updateBank exit=UserBank_01
           1132                         ;}
38D7 0008  1133         RETURN
           1134                         ;
           1135                         ;#define setNetworkFilteringOff_address  0x38d9
           1136                         ;#pragma origin setNetworkFilteringOff_address
     0000  1137         ORG 0x38D9
           1138                         ;void setNetworkFilteringOff()
           1139                         ;{
           1140 setNetworkFilteringOff
           1141                         ;  #asm
           1142                         ;    DW 0x2000
38D9 2000  1143         DW    0x2000
           1144                         ;  #endasm
           1145                         ;  #pragma updateBank exit=UserBank_01
           1146                         ;}
38DA 0008  1147         RETURN
           1148                         ;
           1149                         ;#define getNetworkParams_address    0x38dc
           1150                         ;#pragma origin getNetworkParams_address
     0000  1151         ORG 0x38DC
           1152                         ;uns8 getNetworkParams()
           1153                         ;{
           1154 getNetworkParams
           1155                         ;  #asm
           1156                         ;    DW 0x2000
38DC 2000  1157         DW    0x2000
           1158                         ;  #endasm
           1159                         ;  #pragma updateBank exit=UserBank_01
           1160                         ;  return W;
38DD 0008  1161         RETURN
           1162                         ;}
           1163                         ;
           1164                         ;#define setRoutingOn_address    0x38df
           1165                         ;#pragma origin setRoutingOn_address
     0000  1166         ORG 0x38DF
           1167                         ;void setRoutingOn()
           1168                         ;{
           1169 setRoutingOn
           1170                         ;  #asm
           1171                         ;    DW 0x2000
38DF 2000  1172         DW    0x2000
           1173                         ;  #endasm
           1174                         ;  #pragma updateBank exit=UserBank_01
           1175                         ;}
38E0 0008  1176         RETURN
           1177                         ;
           1178                         ;#define setRoutingOff_address   0x38e2
           1179                         ;#pragma origin setRoutingOff_address
     0000  1180         ORG 0x38E2
           1181                         ;void setRoutingOff()
           1182                         ;{
           1183 setRoutingOff
           1184                         ;  #asm
           1185                         ;    DW 0x2000
38E2 2000  1186         DW    0x2000
           1187                         ;  #endasm
           1188                         ;  #pragma updateBank exit=UserBank_01
           1189                         ;}
38E3 0008  1190         RETURN
           1191                         ;
           1192                         ;#define answerSystemPacket_address  0x38e8
           1193                         ;#pragma origin answerSystemPacket_address
     0000  1194         ORG 0x38E8
           1195                         ;void answerSystemPacket()
           1196                         ;{
           1197 answerSystemPacket
           1198                         ;  #asm
           1199                         ;    DW 0x2000
38E8 2000  1200         DW    0x2000
           1201                         ;  #endasm
           1202                         ;  #pragma updateBank exit=UserBank_01
           1203                         ;}
38E9 0008  1204         RETURN
           1205                         ;
           1206                         ;#define discovery_address   0x38eb
           1207                         ;#pragma origin discovery_address
     0000  1208         ORG 0x38EB
           1209                         ;uns8 discovery(uns8 MaxNodeAddress @ W)
           1210                         ;{
           1211 discovery
           1212                         ;  #asm
           1213                         ;    DW 0x2000
38EB 2000  1214         DW    0x2000
           1215                         ;  #endasm
           1216                         ;  #pragma updateBank exit=UserBank_01
           1217                         ;  return W;
38EC 0008  1218         RETURN
           1219                         ;}
           1220                         ;
           1221                         ;#define wasRouted_address   0x38ee
           1222                         ;#pragma origin wasRouted_address
     0000  1223         ORG 0x38EE
           1224                         ;bit wasRouted()
           1225                         ;{
           1226 wasRouted
           1227                         ;  #asm
           1228                         ;    DW 0x2000
38EE 2000  1229         DW    0x2000
           1230                         ;  #endasm
           1231                         ;  #pragma updateBank exit=UserBank_01
           1232                         ;  return Carry;
38EF 0008  1233         RETURN
           1234                         ;}
           1235                         ;
           1236                         ;#define optimizeHops_address    0x38f1
           1237                         ;#pragma origin optimizeHops_address
     0000  1238         ORG 0x38F1
           1239                         ;bit optimizeHops(uns8 method @ W)
           1240                         ;{
           1241 optimizeHops
           1242                         ;  #asm
           1243                         ;    DW 0x2000
38F1 2000  1244         DW    0x2000
           1245                         ;  #endasm
           1246                         ;  #pragma updateBank exit=UserBank_01
           1247                         ;  return Carry;
38F2 0008  1248         RETURN
           1249                         ;}
           1250                         ;
           1251                         ;#define getSupplyVoltage_address    0x38f4
           1252                         ;#pragma origin getSupplyVoltage_address
     0000  1253         ORG 0x38F4
           1254                         ;uns8 getSupplyVoltage()
           1255                         ;{
           1256 getSupplyVoltage
           1257                         ;  #asm
           1258                         ;    DW 0x2000
38F4 2000  1259         DW    0x2000
           1260                         ;  #endasm
           1261                         ;  #pragma updateBank exit=UserBank_01
           1262                         ;  return W;
38F5 0008  1263         RETURN
           1264                         ;}
           1265                         ;
           1266                         ;#define getTemperature_address  0x38f7
           1267                         ;#pragma origin getTemperature_address
     0000  1268         ORG 0x38F7
           1269                         ;int8 getTemperature()
           1270                         ;{
           1271 getTemperature
           1272                         ;  #asm
           1273                         ;    DW 0x2000
38F7 2000  1274         DW    0x2000
           1275                         ;  #endasm
           1276                         ;  #pragma updateBank exit=UserBank_01
           1277                         ;  return W;
38F8 0008  1278         RETURN
           1279                         ;}
           1280                         ;
           1281                         ;#define clearBufferRF_address   0x38fa
           1282                         ;#pragma origin clearBufferRF_address
     0000  1283         ORG 0x38FA
           1284                         ;void clearBufferRF()
           1285                         ;{
           1286 clearBufferRF
           1287                         ;  #asm
           1288                         ;    DW 0x2000
38FA 2000  1289         DW    0x2000
           1290                         ;  #endasm
           1291                         ;  #pragma updateBank exit=UserBank_01
           1292                         ;}
38FB 0008  1293         RETURN
           1294                         ;
           1295                         ;#define isDiscoveredNode_address    0x3910
           1296                         ;#pragma origin isDiscoveredNode_address
     0000  1297         ORG 0x3910
           1298                         ;bit isDiscoveredNode(uns8 address @ W)
           1299                         ;{
           1300 isDiscoveredNode
           1301                         ;  #asm
           1302                         ;    DW 0x2000
3910 2000  1303         DW    0x2000
           1304                         ;  #endasm
           1305                         ;  #pragma updateBank exit=UserBank_01
           1306                         ;  return Carry;
3911 0008  1307         RETURN
           1308                         ;}
           1309                         ;
           1310                         ;#define enableRFPGM_address 0x3913
           1311                         ;#pragma origin enableRFPGM_address
     0000  1312         ORG 0x3913
           1313                         ;void enableRFPGM()
           1314                         ;{
           1315 enableRFPGM
           1316                         ;  #asm
           1317                         ;    DW 0x2000
3913 2000  1318         DW    0x2000
           1319                         ;  #endasm
           1320                         ;  #pragma updateBank exit=UserBank_01
           1321                         ;}
3914 0008  1322         RETURN
           1323                         ;
           1324                         ;#define disableRFPGM_address    0x3916
           1325                         ;#pragma origin disableRFPGM_address
     0000  1326         ORG 0x3916
           1327                         ;void disableRFPGM()
           1328                         ;{
           1329 disableRFPGM
           1330                         ;  #asm
           1331                         ;    DW 0x2000
3916 2000  1332         DW    0x2000
           1333                         ;  #endasm
           1334                         ;  #pragma updateBank exit=UserBank_01
           1335                         ;}
3917 0008  1336         RETURN
           1337                         ;
           1338                         ;#define setupRFPGM_address  0x3919
           1339                         ;#pragma origin setupRFPGM_address
     0000  1340         ORG 0x3919
           1341                         ;void setupRFPGM(uns8 x @ W)
           1342                         ;{
           1343 setupRFPGM
           1344                         ;  #asm
           1345                         ;    DW 0x2000
3919 2000  1346         DW    0x2000
           1347                         ;  #endasm
           1348                         ;  #pragma updateBank exit=UserBank_01
           1349                         ;}
391A 0008  1350         RETURN
           1351                         ;
           1352                         ;#define runRFPGM_address    0x391c
           1353                         ;#pragma origin runRFPGM_address
     0000  1354         ORG 0x391C
           1355                         ;void runRFPGM()
           1356                         ;{
           1357 runRFPGM
           1358                         ;  #asm
           1359                         ;    DW 0x2000
391C 2000  1360         DW    0x2000
           1361                         ;  #endasm
           1362                         ;  #pragma updateBank exit=UserBank_01
           1363                         ;}
391D 0008  1364         RETURN
           1365                         ;
           1366                         ;#define iqrfDeepSleep_address   0x391f
           1367                         ;#pragma origin iqrfDeepSleep_address
     0000  1368         ORG 0x391F
           1369                         ;void iqrfDeepSleep()
           1370                         ;{
           1371 iqrfDeepSleep
           1372                         ;  #asm
           1373                         ;    DW 0x2000
391F 2000  1374         DW    0x2000
           1375                         ;  #endasm
           1376                         ;  #pragma updateBank exit=UserBank_01
           1377                         ;}
3920 0008  1378         RETURN
           1379                         ;
           1380                         ;#define wasRFICrestarted_address    0x3922
           1381                         ;#pragma origin wasRFICrestarted_address
     0000  1382         ORG 0x3922
           1383                         ;#if !defined( TR7xD )
           1384                         ;    bit wasRFICrestarted()
           1385                         ;    {
           1386 wasRFICrestarted
           1387                         ;      #asm
           1388                         ;        DW 0x2000
3922 2000  1389         DW    0x2000
           1390                         ;      #endasm
           1391                         ;      #pragma updateBank exit=UserBank_01
           1392                         ;      return Carry;
3923 0008  1393         RETURN
           1394                         ;    }
           1395                         ;#else
           1396                         ;    uns8 wasRFICrestarted()
           1397                         ;    {
           1398                         ;      #asm
           1399                         ;        DW 0x2000
           1400                         ;      #endasm
           1401                         ;      #pragma updateBank exit=UserBank_01
           1402                         ;      return W;
           1403                         ;    }
           1404                         ;#endif
           1405                         ;
           1406                         ;#define eeeWriteData_address    0x3925
           1407                         ;#pragma origin eeeWriteData_address
     0000  1408         ORG 0x3925
           1409                         ;bit eeeWriteData(uns16 address @ param3)
           1410                         ;{
           1411 eeeWriteData
           1412                         ;  #asm
           1413                         ;    DW 0x2000
3925 2000  1414         DW    0x2000
           1415                         ;  #endasm
           1416                         ;  #pragma updateBank exit=UserBank_01
           1417                         ;  return Carry;
3926 0008  1418         RETURN
           1419                         ;}
           1420                         ;
           1421                         ;#define eeeReadData_address 0x3928
           1422                         ;#pragma origin eeeReadData_address
     0000  1423         ORG 0x3928
           1424                         ;bit eeeReadData(uns16 address @ param3)
           1425                         ;{
           1426 eeeReadData
           1427                         ;  #asm
           1428                         ;    DW 0x2000
3928 2000  1429         DW    0x2000
           1430                         ;  #endasm
           1431                         ;  #pragma updateBank exit=UserBank_01
           1432                         ;  return Carry;
3929 0008  1433         RETURN
           1434                         ;}
           1435                         ;
           1436                         ;#define setINDF0_address    0x3931
           1437                         ;#pragma origin setINDF0_address
     0000  1438         ORG 0x3931
           1439                         ;void setINDF0(uns8 value @ W)
           1440                         ;{
           1441 setINDF0
           1442                         ;  #asm
           1443                         ;    DW 0x2000
3931 2000  1444         DW    0x2000
           1445                         ;  #endasm
           1446                         ;  #pragma updateBank exit=UserBank_01
           1447                         ;}
3932 0008  1448         RETURN
           1449                         ;
           1450                         ;#define setINDF1_address    0x3934
           1451                         ;#pragma origin setINDF1_address
     0000  1452         ORG 0x3934
           1453                         ;void setINDF1(uns8 value @ W)
           1454                         ;{
           1455 setINDF1
           1456                         ;  #asm
           1457                         ;    DW 0x2000
3934 2000  1458         DW    0x2000
           1459                         ;  #endasm
           1460                         ;  #pragma updateBank exit=UserBank_01
           1461                         ;}
3935 0008  1462         RETURN
           1463                         ;
           1464                         ;#define getRSSI_address 0x3937
           1465                         ;#pragma origin getRSSI_address
     0000  1466         ORG 0x3937
           1467                         ;uns8 getRSSI()
           1468                         ;{
           1469 getRSSI
           1470                         ;  #asm
           1471                         ;    DW 0x2000
3937 2000  1472         DW    0x2000
           1473                         ;  #endasm
           1474                         ;  #pragma updateBank exit=UserBank_01
           1475                         ;  return W;
3938 0008  1476         RETURN
           1477                         ;}
           1478                         ;
           1479                         ;#define removeBondAddress_address   0x393a
           1480                         ;#pragma origin removeBondAddress_address
     0000  1481         ORG 0x393A
           1482                         ;void removeBondAddress()
           1483                         ;{
           1484 removeBondAddress
           1485                         ;  #asm
           1486                         ;    DW 0x2000
393A 2000  1487         DW    0x2000
           1488                         ;  #endasm
           1489                         ;  #pragma updateBank exit=UserBank_01
           1490                         ;}
393B 0008  1491         RETURN
           1492                         ;
           1493                         ;#define sendFRC_address 0x393d
           1494                         ;#pragma origin sendFRC_address
     0000  1495         ORG 0x393D
           1496                         ;uns8 sendFRC(uns8 command @ W)
           1497                         ;{
           1498 sendFRC
           1499                         ;  #asm
           1500                         ;    DW 0x2000
393D 2000  1501         DW    0x2000
           1502                         ;  #endasm
           1503                         ;  #pragma updateBank exit=UserBank_01
           1504                         ;  return W;
393E 0008  1505         RETURN
           1506                         ;}
           1507                         ;
           1508                         ;#define responseFRC_address 0x3940
           1509                         ;#pragma origin responseFRC_address
     0000  1510         ORG 0x3940
           1511                         ;void responseFRC()
           1512                         ;{
           1513 responseFRC
           1514                         ;  #asm
           1515                         ;    DW 0x2000
3940 2000  1516         DW    0x2000
           1517                         ;  #endasm
           1518                         ;  #pragma updateBank exit=UserBank_01
           1519                         ;}
3941 0008  1520         RETURN
           1521                         ;
           1522                         ;#define bondRequestAdvanced_address 0x3943
           1523                         ;#pragma origin bondRequestAdvanced_address
     0000  1524         ORG 0x3943
           1525                         ;bit bondRequestAdvanced()
           1526                         ;{
           1527 bondRequestAdvanced
           1528                         ;  #asm
           1529                         ;    DW 0x2000
3943 2000  1530         DW    0x2000
           1531                         ;  #endasm
           1532                         ;  #pragma updateBank exit=UserBank_01
           1533                         ;  return Carry;
3944 0008  1534         RETURN
           1535                         ;}
           1536                         ;
           1537                         ;#define prebondNodeAtNode_address   0x3946
           1538                         ;#pragma origin prebondNodeAtNode_address
     0000  1539         ORG 0x3946
           1540                         ;bit prebondNodeAtNode()
           1541                         ;{
           1542 prebondNodeAtNode
           1543                         ;  #asm
           1544                         ;    DW 0x2000
3946 2000  1545         DW    0x2000
           1546                         ;  #endasm
           1547                         ;  #pragma updateBank exit=UserBank_01
           1548                         ;  return Carry;
3947 0008  1549         RETURN
           1550                         ;}
           1551                         ;
           1552                         ;#define nodeAuthorization_address   0x3949
           1553                         ;#pragma origin nodeAuthorization_address
     0000  1554         ORG 0x3949
           1555                         ;bit nodeAuthorization(uns8 address @ W)
           1556                         ;{
           1557 nodeAuthorization
           1558                         ;  #asm
           1559                         ;    DW 0x2000
3949 2000  1560         DW    0x2000
           1561                         ;  #endasm
           1562                         ;  #pragma updateBank exit=UserBank_01
           1563                         ;  return Carry;
394A 0008  1564         RETURN
           1565                         ;}
           1566                         ;
           1567                         ;#define dummy01_address 0x394c
           1568                         ;#pragma origin dummy01_address
     0000  1569         ORG 0x394C
           1570                         ;void dummy01()
           1571                         ;{
           1572 dummy01
           1573                         ;  #asm
           1574                         ;  DW 0x2000
394C 2000  1575         DW    0x2000
           1576                         ;  #endasm
           1577                         ;  #pragma updateBank exit=UserBank_01
           1578                         ;}
394D 0008  1579         RETURN
           1580                         ;
           1581                         ;#define setAccessPassword_address   0x3958
           1582                         ;#pragma origin setAccessPassword_address
     0000  1583         ORG 0x3958
           1584                         ;void setAccessPassword()
           1585                         ;{
           1586 setAccessPassword
           1587                         ;  #asm
           1588                         ;    DW 0x2000
3958 2000  1589         DW    0x2000
           1590                         ;  #endasm
           1591                         ;  #pragma updateBank exit=UserBank_01
           1592                         ;}
3959 0008  1593         RETURN
           1594                         ;
           1595                         ;#define setUserKey_address  0x395b
           1596                         ;#pragma origin setUserKey_address
     0000  1597         ORG 0x395B
           1598                         ;void setUserKey()
           1599                         ;{
           1600 setUserKey
           1601                         ;  #asm
           1602                         ;    DW 0x2000
395B 2000  1603         DW    0x2000
           1604                         ;  #endasm
           1605                         ;  #pragma updateBank exit=UserBank_01
           1606                         ;}
395C 0008  1607         RETURN
           1608                         ;
           1609                         ;#define amIRecipientOfFRC_address   0x3961
           1610                         ;#pragma origin amIRecipientOfFRC_address
     0000  1611         ORG 0x3961
           1612                         ;bit amIRecipientOfFRC()
           1613                         ;{
           1614 amIRecipientOfFRC
           1615                         ;  #asm
           1616                         ;    DW 0x2000
3961 2000  1617         DW    0x2000
           1618                         ;  #endasm
           1619                         ;  #pragma updateBank exit=UserBank_01
           1620                         ;  return Carry;
3962 0008  1621         RETURN
           1622                         ;}
           1623                         ;
           1624                         ;#define setLEDR_address 0x3964
           1625                         ;#pragma origin setLEDR_address
     0000  1626         ORG 0x3964
           1627                         ;void setLEDR()
           1628                         ;{
           1629 setLEDR
           1630                         ;  #asm
           1631                         ;    DW 0x2000
3964 2000  1632         DW    0x2000
           1633                         ;  #endasm
           1634                         ;  #pragma updateBank exit=UserBank_01
           1635                         ;}
3965 0008  1636         RETURN
           1637                         ;
           1638                         ;#define encryptBufferRF_address 0x3967
           1639                         ;#pragma origin encryptBufferRF_address
     0000  1640         ORG 0x3967
           1641                         ;void encryptBufferRF(uns8 blocks @ W)
           1642                         ;{
           1643 encryptBufferRF
           1644                         ;  #asm
           1645                         ;    DW 0x2000
3967 2000  1646         DW    0x2000
           1647                         ;  #endasm
           1648                         ;  #pragma updateBank exit=UserBank_01
           1649                         ;}
3968 0008  1650         RETURN
           1651                         ;
           1652                         ;#define decryptBufferRF_address 0x396a
           1653                         ;#pragma origin decryptBufferRF_address
     0000  1654         ORG 0x396A
           1655                         ;void decryptBufferRF(uns8 blocks @ W)
           1656                         ;{
           1657 decryptBufferRF
           1658                         ;  #asm
           1659                         ;    DW 0x2000
396A 2000  1660         DW    0x2000
           1661                         ;  #endasm
           1662                         ;  #pragma updateBank exit=UserBank_01
           1663                         ;}
396B 0008  1664         RETURN
           1665                         ;
           1666                         ;#define prebondNodeAtCoordinator_address    0x396d
           1667                         ;#pragma origin prebondNodeAtCoordinator_address
     0000  1668         ORG 0x396D
           1669                         ;bit prebondNodeAtCoordinator(uns8 address @ W)
           1670                         ;{
           1671 prebondNodeAtCoordinator
           1672                         ;  #asm
           1673                         ;    DW 0x2000
396D 2000  1674         DW    0x2000
           1675                         ;  #endasm
           1676                         ;  #pragma updateBank exit=UserBank_01
           1677                         ;  return Carry;
396E 0008  1678         RETURN
           1679                         ;}
           1680                         ;
           1681                         ;#define setFSRs_address 0x3970
           1682                         ;#pragma origin setFSRs_address
     0000  1683         ORG 0x3970
           1684                         ;uns8 setFSRs(uns8 fsrs @ W)
           1685                         ;{
           1686 setFSRs
           1687                         ;  #asm
           1688                         ;    DW 0x2000
3970 2000  1689         DW    0x2000
           1690                         ;  #endasm
           1691                         ;  #pragma updateBank exit=UserBank_01
           1692                         ;  return W;
3971 0008  1693         RETURN
           1694                         ;}
           1695                         ;
           1696                         ;// For internal usage only
           1697                         ;#define updateCRC16_address 0x3973
           1698                         ;#pragma origin updateCRC16_address
     0000  1699         ORG 0x3973
           1700                         ;void updateCRC16(uns8 value @ W)
           1701                         ;{
           1702 updateCRC16
           1703                         ;  #asm
           1704                         ;    DW 0x2000
3973 2000  1705         DW    0x2000
           1706                         ;  #endasm
           1707                         ;  #pragma updateBank exit=UserBank_01
           1708                         ;}
3974 0008  1709         RETURN
           1710                         ;
           1711                         ;#define smartConnect_address    0x3976
           1712                         ;#pragma origin smartConnect_address
     0000  1713         ORG 0x3976
           1714                         ;bit smartConnect(uns8 address @ W)
           1715                         ;{
           1716 smartConnect
           1717                         ;  #asm
           1718                         ;    DW 0x2000
3976 2000  1719         DW    0x2000
           1720                         ;  #endasm
           1721                         ;  #pragma updateBank exit=UserBank_01
           1722                         ;  return Carry;
3977 0008  1723         RETURN
           1724                         ;}
           1725                         ;
           1726                         ;#define addressBitmap_address   0x3979
           1727                         ;#pragma origin addressBitmap_address
     0000  1728         ORG 0x3979
           1729                         ;uns8 addressBitmap(uns8 bitIndex @ W)
           1730                         ;{
           1731 addressBitmap
           1732                         ;  #asm
           1733                         ;    DW 0x2000
3979 2000  1734         DW    0x2000
           1735                         ;  #endasm
           1736                         ;  #pragma updateBank exit=UserBank_01
           1737                         ;  return W;
397A 0008  1738         RETURN
           1739                         ;}
           1740                         ;
           1741                         ;#define setServiceChannel_address   0x397c
           1742                         ;#pragma origin setServiceChannel_address
     0000  1743         ORG 0x397C
           1744                         ;bit setServiceChannel(uns8 channelNumber @ W)
           1745                         ;{
           1746 setServiceChannel
           1747                         ;  #asm
           1748                         ;    DW 0x2000
397C 2000  1749         DW    0x2000
           1750                         ;  #endasm
           1751                         ;  #pragma updateBank exit=UserBank_01
           1752                         ;  return Carry;
397D 0008  1753         RETURN
           1754                         ;}
           1755                         ;
           1756                         ;#pragma optimize 1
           1757                         ;#pragma update_RP 1
           1758                         ;#pragma update_PAGE 1
           1759                         ;#pragma origin __APPLICATION_ADDRESS
     0000  1760         ORG 0x3A00
           1761 
           1762   ; FILE C:\customdpa\CustomDpaHandlerExample\..\Include\DPA.h
           1763                         ;// *********************************************************************
           1764                         ;//   General public DPA header file                                    *
           1765                         ;// *********************************************************************
           1766                         ;// Copyright (c) MICRORISC s.r.o.
           1767                         ;//
           1768                         ;// File:    $RCSfile: DPA.h,v $
           1769                         ;// Version: $Revision: 1.329 $
           1770                         ;// Date:    $Date: 2024/12/05 09:28:57 $
           1771                         ;//
           1772                         ;// Revision history:
           1773                         ;//   2024/11/05  Release for DPA 4.32
           1774                         ;//   2024/04/17  Release for DPA 4.31
           1775                         ;//   2023/03/07  Release for DPA 4.30
           1776                         ;//   2022/10/05  Release for DPA 4.18
           1777                         ;//   2022/02/24  Release for DPA 4.17
           1778                         ;//   2021/08/20  Release for DPA 4.16
           1779                         ;//   2020/09/03  Release for DPA 4.15
           1780                         ;//   2020/04/03  Release for DPA 4.14
           1781                         ;//   2020/02/27  Release for DPA 4.13
           1782                         ;//   2020/01/09  Release for DPA 4.12
           1783                         ;//   2019/12/11  Release for DPA 4.11
           1784                         ;//   2019/10/09  Release for DPA 4.10
           1785                         ;//   2019/06/12  Release for DPA 4.03
           1786                         ;//   2019/06/03  Release for DPA 4.02
           1787                         ;//   2019/03/07  Release for DPA 4.01
           1788                         ;//   2019/01/10  Release for DPA 4.00
           1789                         ;//   2018/10/25  Release for DPA 3.03
           1790                         ;//   2017/11/16  Release for DPA 3.02
           1791                         ;//   2017/08/14  Release for DPA 3.01
           1792                         ;//   2017/03/13  Release for DPA 3.00
           1793                         ;//   2016/09/12  Release for DPA 2.28
           1794                         ;//   2016/04/14  Release for DPA 2.27
           1795                         ;//   2016/03/03  Release for DPA 2.26
           1796                         ;//   2016/01/21  Release for DPA 2.25
           1797                         ;//   2015/12/01  Release for DPA 2.24
           1798                         ;//   2015/10/23  Release for DPA 2.23
           1799                         ;//   2015/09/25  Release for DPA 2.22
           1800                         ;//   2015/09/03  Release for DPA 2.21
           1801                         ;//   2015/08/05  Release for DPA 2.20
           1802                         ;//   2014/10/31  Release for DPA 2.10
           1803                         ;//   2014/04/30  Release for DPA 2.00
           1804                         ;//   2013/10/03  Release for DPA 1.00
           1805                         ;//
           1806                         ;// *********************************************************************
           1807                         ;
           1808                         ;// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
           1809                         ;// IQRF Standards documentation https://doc.iqrf.org/
           1810                         ;
           1811                         ;#ifndef _DPA_HEADER_
           1812                         ;#define _DPA_HEADER_
           1813                         ;
           1814                         ;//############################################################################################
           1815                         ;
           1816                         ;// DPA version
           1817                         ;#define DPA_VERSION_MASTER          0x0432
           1818                         ;
           1819                         ;#if defined( __CC5X__ ) && !defined( CC5XnotDPA )
           1820                         ;// Compiled only at CC5X
           1821                         ;#if __CC5X__ < 3800
           1822                         ;#error Insufficient CC5X compiler version, V3.8 is minimum
           1823                         ;#endif
           1824                         ;
           1825                         ;#if IQRFOS < 406
           1826                         ;#error IQRF OS 4.06+ is required
           1827                         ;#endif
           1828                         ;
           1829                         ;// Bank for custom variables
           1830                         ;#pragma rambank = UserBank_01
           1831                         ;
           1832                         ;// Main DPA API entry address (also start of the licensed FLASH)
           1833                         ;#define DPA_API_ADDRESS             __LICENSED_FLASH
           1834                         ;
           1835                         ;// Main DPA entry address
           1836                         ;#define MAIN_DPA_ADDRESS            ( DPA_API_ADDRESS + 4 )
           1837                         ;
           1838                         ;// Main DPA API entry address stub
           1839                         ;#define DPA_API_ADDRESS_ENTRY       0x3A08
           1840                         ;
           1841                         ;// Address of the DPA Custom Handler
           1842                         ;#define CUSTOM_HANDLER_ADDRESS      0x3A20
           1843                         ;
           1844                         ;// Address of the DPA Custom Handler end + 1
           1845                         ;#if defined TR7xD
           1846                         ;#define CUSTOM_HANDLER_ADDRESS_END  0x3D80
           1847                         ;#else
           1848                         ;#define CUSTOM_HANDLER_ADDRESS_END  __USER_INTERRUPT
           1849                         ;#endif
           1850                         ;
           1851                         ;// DPA API entry function
           1852                         ;uns8  DpaApiEntry( uns8 par1, uns8 par2, uns8 apiIndex );
           1853                         ;
           1854                         ;// DPA API codes
           1855                         ;#define DPA_API_RFTX_DPAPACKET              0
           1856                         ;#define DPA_API_READ_CONFIG_BYTE            1
           1857                         ;#define DPA_API_SEND_TO_IFACEMASTER         2
           1858                         ;#define DPA_API_COORDINATOR_RFTX_DPAPACKET  3
           1859                         ;#define DPA_API_LOCAL_REQUEST               4
           1860                         ;#define DPA_API_SET_PERIPHERAL_ERROR        5
           1861                         ;#define DPA_API_SET_RF_DEFAULTS             6
           1862                         ;#define DPA_API_LOCAL_FRC                   7
           1863                         ;#define DPA_API_CRC8                        8
           1864                         ;#define DPA_API_AGGREGATE_FRC               9
           1865                         ;#define DPA_API_SET_OTK                     10
           1866                         ;#define DPA_API_I2C_INIT                    11
           1867                         ;#define DPA_API_I2C_START                   12
           1868                         ;#define DPA_API_I2C_WRITE                   13
           1869                         ;#define DPA_API_I2C_READ                    14
           1870                         ;#define DPA_API_I2C_STOP                    15
           1871                         ;#define DPA_API_I2C_WAIT_FOR_ACK            16
           1872                         ;#define DPA_API_I2C_SHUTDOWN                17
           1873                         ;#define DPA_API_I2C_WAIT_FOR_IDLE           18
           1874                         ;#define DPA_API_SLEEP                       19
           1875                         ;#define DPA_API_AFTER_SLEEP                 20
           1876                         ;#define DPA_API_RANDOM                      21
           1877                         ;#if !defined( TR7xD )
           1878                         ;#define DPA_API_MENU                        22
           1879                         ;#define DPA_API_MENU_INDICATE_RESULT        23
           1880                         ;#define DPA_API_MENU_EXECUTE                24
           1881                         ;#define DPA_API_DEEP_SLEEP                  25
           1882                         ;#endif
           1883                         ;
           1884                         ;// Used buffer size symbols
           1885                         ;#define sizeofBufferRF                      sizeof( bufferRF )
           1886                         ;#define sizeofBufferAUX                     sizeof( bufferAUX )
           1887                         ;#define sizeofBufferCOM                     sizeof( bufferCOM )
           1888                         ;#define sizeofBufferINFO                    sizeof( bufferINFO )
           1889                         ;
           1890                         ;// Converts conventional address to the linear one at PIC16LF1938
           1891                         ;// Note: This is workaround of CC5X preprocessor bug "No '#endif' detected"
           1892                         ;#define error_ #error Address cannot be linearized
           1893                         ;#define LINEARIZE_ADDRESS( a ) \
           1894                         ;#if ( ((uns16)(a)) - ( ((uns16)(a)) / 0x80 ) * 0x80 ) >= 0x20 && ( ((uns16)(a)) - ( ((uns16)(a)) / 0x80 ) * 0x80 ) <= 0x6F && ( ((uns16)(a)) / 0x80 ) <= 12 \
           1895                         ;( ( ( ((uns16)(a)) / 0x80 ) * 0x50 ) + ( ((uns16)(a)) - 0x20 - ( ((uns16)(a)) / 0x80 ) * 0x80 ) + 0x2000 ) \
           1896                         ;#else \
           1897                         ;error_ \
           1898                         ;#endif
           1899                         ;#undef error_
           1900                         ;
           1901                         ;#define STRUCTATTR
           1902                         ;
           1903                         ;#else //__CC5X__
           1904                         ;// Not compiled at CC5X
           1905                         ;
           1906                         ;#if !defined( CC5XnotDPA )
           1907                         ;// Define CC5X types
           1908                         ;typedef int8_t    int8;
           1909                         ;typedef int16_t   int16;
           1910                         ;typedef uint8_t   uns8;
           1911                         ;typedef uint16_t  uns16;
           1912                         ;// Disables alignment of members of structures
           1913                         ;#define STRUCTATTR  __attribute__((packed))
           1914                         ;#else
           1915                         ;#define STRUCTATTR
           1916                         ;#endif
           1917                         ;
           1918                         ;// Fake buffer sizes
           1919                         ;#define sizeofBufferRF    64
           1920                         ;#define sizeofBufferAUX   64
           1921                         ;#define sizeofBufferCOM   64
           1922                         ;#define sizeofBufferINFO  64
           1923                         ;
           1924                         ;#endif  // __CC5X__
           1925                         ;
           1926                         ;// Indexes of configuration bytes used by DpaApiReadConfigByte( index )
           1927                         ;// Checksum
           1928                         ;#define CFGIND_CHECKSUM         0x00
           1929                         ;// Embedded peripherals
           1930                         ;#define CFGIND_DPA_PERIPHERALS  0x01
           1931                         ;// DPA configuration flags #0
           1932                         ;#define CFGIND_DPA_FLAGS0       0x05
           1933                         ;// Main RF channel, used by the subordinate network
           1934                         ;#define CFGIND_CHANNEL_2ND_A    0x06
           1935                         ;// Second RF channel, used by the subordinate network
           1936                         ;#define CFGIND_CHANNEL_2ND_B    0x07
           1937                         ;// TX power
           1938                         ;#define CFGIND_TXPOWER          0x08
           1939                         ;// RX filter used by checkRF()
           1940                         ;#define CFGIND_RXFILTER         0x09
           1941                         ;// toutRF for LP mode
           1942                         ;#define CFGIND_DPA_LP_TOUTRF    0x0A
           1943                         ;// UART interface baud rate
           1944                         ;#define CFGIND_DPA_UART_IFACE_SPEED 0x0B
           1945                         ;// Alternate DSM channel
           1946                         ;#define CFGIND_ALTERNATE_DSM_CHANNEL 0x0C
           1947                         ;// DPA configuration flags #1
           1948                         ;#define CFGIND_DPA_FLAGS1       0x0D
           1949                         ;// Main RF channel
           1950                         ;#define CFGIND_CHANNEL_A        0x11
           1951                         ;// Second RF channel
           1952                         ;#define CFGIND_CHANNEL_B        0x12
           1953                         ;
           1954                         ;// 0: checks only mandatory precondition in order to prevent critical side-effects
           1955                         ;// 1: as above plus checks meaningful parameter conditions
           1956                         ;// 2: full implemented parameter checking (default)
           1957                         ;#ifndef PARAM_CHECK_LEVEL
           1958                         ;#define PARAM_CHECK_LEVEL 2
           1959                         ;#endif
           1960                         ;
           1961                         ;// "foursome" at IFace structure
           1962                         ;typedef struct
           1963                         ;{
           1964                         ;  // Node address low byte
           1965                         ;  uns8  NADRlow;
           1966                         ;  // Node address high byte
           1967                         ;  uns8  NADRhigh;
           1968                         ;  // Peripheral number
           1969                         ;  uns8  PNUM;
           1970                         ;  // Peripheral command
           1971                         ;  uns8  PCMD;
           1972                         ;  // HWPID
           1973                         ;  uns16 HWPID;
           1974                         ;} STRUCTATTR TDpaIFaceHeader;
           1975                         ;
           1976                         ;// Maximum command PCMD value (except reserved 0x3F = CMD_GET_PER_INFO)
           1977                         ;#define PCMD_MAX                    0x7f
           1978                         ;// Bit mask at PCMD that indicates DPA Response message
           1979                         ;#define RESPONSE_FLAG               0x80
           1980                         ;
           1981                         ;// IQMESH coordinator address
           1982                         ;#define COORDINATOR_ADDRESS         0x00
           1983                         ;// IQMESH broadcast address
           1984                         ;#define BROADCAST_ADDRESS           0xff
           1985                         ;// IQMESH temporary address, assigned by pre-bonding before authorization is done
           1986                         ;#define TEMPORARY_ADDRESS           0xfe
           1987                         ;// Address of the local device addressed by IFace
           1988                         ;#define LOCAL_ADDRESS               0xfc
           1989                         ;// Maximum IQMESH network device address
           1990                         ;#define MAX_ADDRESS                 ( 240 - 1 )
           1991                         ;
           1992                         ;// Time slots lengths in 10 ms
           1993                         ;#define MIN_STD_TIMESLOT    4
           1994                         ;#define MAX_STD_TIMESLOT    6
           1995                         ;
           1996                         ;#define MIN_LP_TIMESLOT     8
           1997                         ;#define MAX_LP_TIMESLOT     10
           1998                         ;
           1999                         ;// Maximum number of DPA PData bytes ( minus 8 = 6B foursome + 8b error code + 8b DpaValue )
           2000                         ;#define DPA_MAX_DATA_LENGTH         ( sizeofBufferCOM - sizeof( TDpaIFaceHeader ) - 2 * sizeof( uns8 ) )
           2001                         ;
           2002                         ;// Maximum number of peripherals info that can fit in the message
           2003                         ;#define MAX_PERIPHERALS_PER_BLOCK_INFO  ( DPA_MAX_DATA_LENGTH / sizeof( TPeripheralInfoAnswer ) )
           2004                         ;
           2005                         ;// Embedded peripheral numbers
           2006                         ;#define PNUM_COORDINATOR    0x00
           2007                         ;#define PNUM_NODE           0x01
           2008                         ;#define PNUM_OS             0x02
           2009                         ;#define PNUM_EEPROM         0x03
           2010                         ;#define PNUM_EEEPROM        0x04
           2011                         ;#define PNUM_RAM            0x05
           2012                         ;#define PNUM_LEDR           0x06
           2013                         ;#define PNUM_LEDG           0x07
           2014                         ;#define PNUM_IO             0x09
           2015                         ;#define PNUM_THERMOMETER    0x0A
           2016                         ;#define PNUM_UART           0x0C
           2017                         ;#define PNUM_FRC            0x0D
           2018                         ;
           2019                         ;// Number of the 1st user peripheral
           2020                         ;#define PNUM_USER           0x20
           2021                         ;// Number of the last user peripheral
           2022                         ;#define PNUM_USER_MAX       0x3E
           2023                         ;// Maximum peripheral number
           2024                         ;#define PNUM_MAX            0x7F
           2025                         ;
           2026                         ;// Fake peripheral number used to flag DPA response with error sent by RF
           2027                         ;#define PNUM_ERROR_FLAG     0xFE
           2028                         ;// Special peripheral used for enumeration
           2029                         ;#define PNUM_ENUMERATION    0xFF
           2030                         ;
           2031                         ;// DPA Commands for embedded peripherals
           2032                         ;#define CMD_COORDINATOR_ADDR_INFO  0
           2033                         ;#define CMD_COORDINATOR_DISCOVERED_DEVICES 1
           2034                         ;#define CMD_COORDINATOR_BONDED_DEVICES 2
           2035                         ;#define CMD_COORDINATOR_CLEAR_ALL_BONDS 3
           2036                         ;#define CMD_COORDINATOR_BOND_NODE 4
           2037                         ;#define CMD_COORDINATOR_REMOVE_BOND 5
           2038                         ;#define CMD_COORDINATOR_DISCOVERY 7
           2039                         ;#define CMD_COORDINATOR_SET_DPAPARAMS 8
           2040                         ;#define CMD_COORDINATOR_SET_HOPS 9
           2041                         ;#define CMD_COORDINATOR_BACKUP 11
           2042                         ;#define CMD_COORDINATOR_RESTORE 12
           2043                         ;#define CMD_COORDINATOR_AUTHORIZE_BOND 13
           2044                         ;#define CMD_COORDINATOR_BRIDGE 14
           2045                         ;#define CMD_COORDINATOR_SMART_CONNECT 18
           2046                         ;#define CMD_COORDINATOR_SET_MID 19
           2047                         ;
           2048                         ;#define CMD_NODE_READ 0
           2049                         ;#define CMD_NODE_REMOVE_BOND 1
           2050                         ;#define CMD_NODE_BACKUP 6
           2051                         ;#define CMD_NODE_RESTORE 7
           2052                         ;#define CMD_NODE_VALIDATE_BONDS 8
           2053                         ;
           2054                         ;#define CMD_OS_READ 0
           2055                         ;#define CMD_OS_RESET 1
           2056                         ;#define CMD_OS_READ_CFG 2
           2057                         ;#define CMD_OS_RFPGM 3
           2058                         ;#define CMD_OS_SLEEP 4
           2059                         ;#define CMD_OS_BATCH 5
           2060                         ;#define CMD_OS_SET_SECURITY 6
           2061                         ;#define CMD_OS_INDICATE 7
           2062                         ;#define CMD_OS_RESTART 8
           2063                         ;#define CMD_OS_WRITE_CFG_BYTE 9
           2064                         ;#define CMD_OS_LOAD_CODE 10
           2065                         ;#define CMD_OS_SELECTIVE_BATCH 11
           2066                         ;#define CMD_OS_TEST_RF_SIGNAL 12
           2067                         ;#define CMD_OS_FACTORY_SETTINGS 13
           2068                         ;#define CMD_OS_WRITE_CFG 15
           2069                         ;
           2070                         ;#define CMD_RAM_READ 0
           2071                         ;#define CMD_RAM_WRITE 1
           2072                         ;#define CMD_RAM_READ_ANY    15
           2073                         ;
           2074                         ;#define CMD_EEPROM_READ CMD_RAM_READ
           2075                         ;#define CMD_EEPROM_WRITE CMD_RAM_WRITE
           2076                         ;
           2077                         ;#define CMD_EEEPROM_XREAD ( CMD_RAM_READ + 2 )
           2078                         ;#define CMD_EEEPROM_XWRITE ( CMD_RAM_WRITE + 2 )
           2079                         ;
           2080                         ;#define CMD_LED_SET_OFF 0
           2081                         ;#define CMD_LED_SET_ON 1
           2082                         ;#define CMD_LED_PULSE 3
           2083                         ;#define CMD_LED_FLASHING 4
           2084                         ;
           2085                         ;#define CMD_IO_DIRECTION  0
           2086                         ;#define CMD_IO_SET  1
           2087                         ;#define CMD_IO_GET  2
           2088                         ;
           2089                         ;#define CMD_THERMOMETER_READ 0
           2090                         ;
           2091                         ;#define CMD_UART_OPEN 0
           2092                         ;#define CMD_UART_CLOSE 1
           2093                         ;#define CMD_UART_WRITE_READ 2
           2094                         ;#define CMD_UART_CLEAR_WRITE_READ 3
           2095                         ;
           2096                         ;#define CMD_FRC_SEND 0
           2097                         ;#define CMD_FRC_EXTRARESULT 1
           2098                         ;#define CMD_FRC_SEND_SELECTIVE 2
           2099                         ;#define CMD_FRC_SET_PARAMS 3
           2100                         ;
           2101                         ;#define CMD_GET_PER_INFO  0x3f
           2102                         ;
           2103                         ;// DPA peripheral type
           2104                         ;typedef enum
           2105                         ;{
           2106                         ;  PERIPHERAL_TYPE_DUMMY = 0x00,
           2107                         ;  PERIPHERAL_TYPE_COORDINATOR = 0x01,
           2108                         ;  PERIPHERAL_TYPE_NODE = 0x02,
           2109                         ;  PERIPHERAL_TYPE_OS = 0x03,
           2110                         ;  PERIPHERAL_TYPE_EEPROM = 0x04,
           2111                         ;  PERIPHERAL_TYPE_BLOCK_EEPROM = 0x05,
           2112                         ;  PERIPHERAL_TYPE_RAM = 0x06,
           2113                         ;  PERIPHERAL_TYPE_LED = 0x07,
           2114                         ;  PERIPHERAL_TYPE_SPI = 0x08,
           2115                         ;  PERIPHERAL_TYPE_IO = 0x09,
           2116                         ;  PERIPHERAL_TYPE_UART = 0x0a,
           2117                         ;  PERIPHERAL_TYPE_THERMOMETER = 0x0b,
           2118                         ;  PERIPHERAL_TYPE_ADC = 0x0c,
           2119                         ;  PERIPHERAL_TYPE_PWM = 0x0d,
           2120                         ;  PERIPHERAL_TYPE_FRC = 0x0e,
           2121                         ;  // Starts peripheral type number interval for user peripherals
           2122                         ;  PERIPHERAL_TYPE_USER_AREA = 0x80
           2123                         ;} TDpaPeripheralType;
           2124                         ;
           2125                         ;// Peripheral extended information
           2126                         ;typedef enum
           2127                         ;{
           2128                         ;  PERIPHERAL_TYPE_EXTENDED_DEFAULT = 0x00,
           2129                         ;  PERIPHERAL_TYPE_EXTENDED_READ = 0x01,
           2130                         ;  PERIPHERAL_TYPE_EXTENDED_WRITE = 0x02,
           2131                         ;  PERIPHERAL_TYPE_EXTENDED_READ_WRITE = PERIPHERAL_TYPE_EXTENDED_READ | PERIPHERAL_TYPE_EXTENDED_WRITE
           2132                         ;} TDpaPeripheralTypeExtended;
           2133                         ;
           2134                         ;// Response packet error codes
           2135                         ;typedef enum
           2136                         ;{
           2137                         ;  // No error
           2138                         ;  STATUS_NO_ERROR = 0,
           2139                         ;
           2140                         ;  // General fail
           2141                         ;  ERROR_FAIL = 1,
           2142                         ;  // Incorrect PCMD
           2143                         ;  ERROR_PCMD = 2,
           2144                         ;  // Incorrect PNUM or PCMD
           2145                         ;  ERROR_PNUM = 3,
           2146                         ;  // Incorrect Address value when addressing memory type peripherals
           2147                         ;  ERROR_ADDR = 4,
           2148                         ;  // Incorrect Data length
           2149                         ;  ERROR_DATA_LEN = 5,
           2150                         ;  // Incorrect Data
           2151                         ;  ERROR_DATA = 6,
           2152                         ;  // Incorrect HWPID used
           2153                         ;  ERROR_HWPID = 7,
           2154                         ;  // Incorrect NADR
           2155                         ;  ERROR_NADR = 8,
           2156                         ;  // IFACE data consumed by Custom DPA Handler
           2157                         ;  ERROR_IFACE_CUSTOM_HANDLER = 9,
           2158                         ;  // Custom DPA Handler is missing
           2159                         ;  ERROR_MISSING_CUSTOM_DPA_HANDLER = 10,
           2160                         ;
           2161                         ;  // Beginning of the user code error interval
           2162                         ;  ERROR_USER_FROM = 0x20,
           2163                         ;  // End of the user code error interval
           2164                         ;  ERROR_USER_TO = 0x3f,
           2165                         ;
           2166                         ;  // Bit/flag reserved for a future use
           2167                         ;  STATUS_RESERVED_FLAG = 0x40,
           2168                         ;  // Bit to flag asynchronous DPA Response from [N]
           2169                         ;  STATUS_ASYNC_RESPONSE = 0x80,
           2170                         ;  // Error code used to mark DPA Confirmation
           2171                         ;  STATUS_CONFIRMATION = 0xff
           2172                         ;} TErrorCodes;
           2173                         ;
           2174                         ;// Embedded FRC commands
           2175                         ;typedef enum
           2176                         ;{
           2177                         ;  // 2 bits
           2178                         ;  FRC_Ping = 0x00,
           2179                         ;  FRC_AcknowledgedBroadcastBits = 0x02,
           2180                         ;  FRC_PrebondedAlive = 0x03,
           2181                         ;  FRC_SupplyVoltage = 0x04,
           2182                         ;  FRC_PrebondedMemoryCompare2B = 0x05,
           2183                         ;  // 1 byte
           2184                         ;  FRC_Temperature = 0x80,
           2185                         ;  FRC_AcknowledgedBroadcastBytes = 0x81,
           2186                         ;  FRC_MemoryRead = 0x82,
           2187                         ;  FRC_MemoryReadPlus1 = 0x83,
           2188                         ;  FRC_FrcResponseTime = 0x84,
           2189                         ;  FRC_TestRFsignal = 0x85,
           2190                         ;  // 4 bytes
           2191                         ;  FRC_PrebondedMemoryRead4BPlus1 = 0xF8,
           2192                         ;  FRC_MemoryRead4B = 0xFA
           2193                         ;} TFRCommands;
           2194                         ;
           2195                         ;// Intervals of user FRC codes
           2196                         ;#define FRC_USER_BIT_FROM     0x40
           2197                         ;#define FRC_USER_BIT_TO       0x7F
           2198                         ;#define FRC_USER_BYTE_FROM    0xC0
           2199                         ;#define FRC_USER_BYTE_TO      0xDF
           2200                         ;#define FRC_USER_2BYTE_FROM   0xF0
           2201                         ;#define FRC_USER_2BYTE_TO     0xF7
           2202                         ;#define FRC_USER_4BYTE_FROM   0xFC
           2203                         ;#define FRC_USER_4BYTE_TO     0xFF
           2204                         ;
           2205                         ;// No HWPID specified
           2206                         ;#define HWPID_Default         0x0000
           2207                         ;// Use this type to override HWPID check
           2208                         ;#define HWPID_DoNotCheck      0xFfFf
           2209                         ;
           2210                         ;// RAM peripheral block definitions
           2211                         ;#ifdef TR7xD
           2212                         ;#define PERIPHERAL_RAM_LENGTH 48
           2213                         ;#else
           2214                         ;#define PERIPHERAL_RAM_LENGTH 80
           2215                         ;#endif
           2216                         ;
           2217                         ;// Start address of EEPROM peripheral in the real EEPROM
           2218                         ;#ifndef COORDINATOR_CUSTOM_HANDLER // Node
           2219                         ;#define PERIPHERAL_EEPROM_START     ( (uns8)0x00 )
           2220                         ;#else // Coordinator
           2221                         ;#define PERIPHERAL_EEPROM_START     ( (uns8)0x80 )
           2222                         ;#endif
           2223                         ;
           2224                         ;// Length of the internal EEPROM peripheral array
           2225                         ;#define PERIPHERAL_EEPROM_LENGTH            ( (uns8)( 0xC0 - PERIPHERAL_EEPROM_START ) )
           2226                         ;
           2227                         ;// Length of the readable area of serial EEEPROM from the EEEPROM DPA peripheral write point of view.
           2228                         ;#define EEEPROM_READ_LENGTH                 0x8000
           2229                         ;// Length of the writable area of serial EEEPROM from the EEEPROM DPA peripheral write point of view.
           2230                         ;#define EEEPROM_WRITE_LENGTH                0x4000
           2231                         ;
           2232                         ;// Starting address of the IO Setup DPA storage at external EEPROM
           2233                         ;#define IOSETUP_EEEPROM_ADDR                ( 0x0000 + sizeofBufferAUX )
           2234                         ;// Length of the IO setup memory block
           2235                         ;#define IOSETUP_LENGTH                      sizeofBufferAUX
           2236                         ;
           2237                         ;#if !defined( TR7xD )
           2238                         ;// Parameter at [_]DpaApi[Deep]Sleep() for not using Watchdog timer wakeup
           2239                         ;#define DpaApiSleep_WdtOff                  0b00000.0
           2240                         ;#endif
           2241                         ;
           2242                         ;// ---------------------------------------------------------
           2243                         ;
           2244                         ;// Enumerate peripherals structure
           2245                         ;typedef struct
           2246                         ;{
           2247                         ;  uns16 DpaVersion;
           2248                         ;  uns8  UserPerNr;
           2249                         ;  uns8  EmbeddedPers[PNUM_USER / 8];
           2250                         ;  uns16 HWPID;
           2251                         ;  uns16 HWPIDver;
           2252                         ;  uns8  Flags;
           2253                         ;  uns8  UserPer[( PNUM_MAX - PNUM_USER + 1 + 7 ) / 8];
           2254                         ;} STRUCTATTR TEnumPeripheralsAnswer;
           2255                         ;
           2256                         ;#define FlagUserPer(UserPersArray,UserPerNumber)    UserPersArray[((UserPerNumber)-PNUM_USER) / 8] |= (uns8)0x01 << (((UserPerNumber)-PNUM_USER) % 8);
           2257                         ;
           2258                         ;// Get peripheral info structure (CMD_GET_PER_INFO)
           2259                         ;typedef struct
           2260                         ;{
           2261                         ;  uns8  PerTE;
           2262                         ;  uns8  PerT;
           2263                         ;  uns8  Par1;
           2264                         ;  uns8  Par2;
           2265                         ;} STRUCTATTR TPeripheralInfoAnswer;
           2266                         ;
           2267                         ;// Error DPA response (PNUM_ERROR_FLAG)
           2268                         ;typedef struct
           2269                         ;{
           2270                         ;  uns8  ErrN;
           2271                         ;  uns8  PNUMoriginal;
           2272                         ;} STRUCTATTR TErrorAnswer;
           2273                         ;
           2274                         ;// Structure returned by CMD_COORDINATOR_ADDR_INFO
           2275                         ;typedef struct
           2276                         ;{
           2277                         ;  uns8  DevNr;
           2278                         ;  uns8  DID;
           2279                         ;} STRUCTATTR TPerCoordinatorAddrInfo_Response;
           2280                         ;
           2281                         ;// Structure for CMD_COORDINATOR_BOND_NODE
           2282                         ;typedef struct
           2283                         ;{
           2284                         ;  uns8  ReqAddr;
           2285                         ;  uns8  BondingTestRetries;
           2286                         ;} STRUCTATTR TPerCoordinatorBondNode_Request;
           2287                         ;
           2288                         ;// Structure returned by CMD_COORDINATOR_BOND_NODE or CMD_COORDINATOR_SMART_CONNECT
           2289                         ;typedef struct
           2290                         ;{
           2291                         ;  uns8  BondAddr;
           2292                         ;  uns8  DevNr;
           2293                         ;} STRUCTATTR TPerCoordinatorBondNodeSmartConnect_Response;
           2294                         ;
           2295                         ;// Structure for CMD_COORDINATOR_REMOVE_BOND
           2296                         ;typedef struct
           2297                         ;{
           2298                         ;  uns8  BondAddr;
           2299                         ;} STRUCTATTR TPerCoordinatorRemoveBond_Request;
           2300                         ;
           2301                         ;// Structure returned by CMD_COORDINATOR_REMOVE_BOND
           2302                         ;typedef struct
           2303                         ;{
           2304                         ;  uns8  DevNr;
           2305                         ;} STRUCTATTR TPerCoordinatorRemoveBond_Response;
           2306                         ;
           2307                         ;// Structure for CMD_COORDINATOR_DISCOVERY
           2308                         ;typedef struct
           2309                         ;{
           2310                         ;  uns8  TxPower;
           2311                         ;  uns8  MaxAddr;
           2312                         ;} STRUCTATTR TPerCoordinatorDiscovery_Request;
           2313                         ;
           2314                         ;// Structure returned by CMD_COORDINATOR_DISCOVERY
           2315                         ;typedef struct
           2316                         ;{
           2317                         ;  uns8  DiscNr;
           2318                         ;} STRUCTATTR TPerCoordinatorDiscovery_Response;
           2319                         ;
           2320                         ;// Structure for and also returned by CMD_COORDINATOR_SET_DPAPARAMS
           2321                         ;typedef struct
           2322                         ;{
           2323                         ;  uns8  DpaParam;
           2324                         ;} STRUCTATTR TPerCoordinatorSetDpaParams_Request_Response;
           2325                         ;
           2326                         ;// Structure for and also returned by CMD_COORDINATOR_SET_HOPS
           2327                         ;typedef struct
           2328                         ;{
           2329                         ;  uns8  RequestHops;
           2330                         ;  uns8  ResponseHops;
           2331                         ;} STRUCTATTR TPerCoordinatorSetHops_Request_Response;
           2332                         ;
           2333                         ;// Structure for CMD_COORDINATOR_BACKUP and CMD_NODE_BACKUP
           2334                         ;typedef struct
           2335                         ;{
           2336                         ;  uns8  Index;
           2337                         ;} STRUCTATTR TPerCoordinatorNodeBackup_Request;
           2338                         ;
           2339                         ;// Structure returned by CMD_COORDINATOR_BACKUP and CMD_NODE_BACKUP
           2340                         ;typedef struct
           2341                         ;{
           2342                         ;  uns8  NetworkData[49];
           2343                         ;} STRUCTATTR TPerCoordinatorNodeBackup_Response;
           2344                         ;
           2345                         ;// Structure for CMD_COORDINATOR_RESTORE and CMD_NODE_RESTORE
           2346                         ;typedef struct
           2347                         ;{
           2348                         ;  uns8  NetworkData[49];
           2349                         ;} STRUCTATTR TPerCoordinatorNodeRestore_Request;
           2350                         ;
           2351                         ;// Structure for CMD_COORDINATOR_AUTHORIZE_BOND
           2352                         ;typedef struct
           2353                         ;{
           2354                         ;  uns8  ReqAddr;
           2355                         ;  uns8  MID[4];
           2356                         ;} STRUCTATTR TPerCoordinatorAuthorizeBond_Request;
           2357                         ;
           2358                         ;// Structure returned by CMD_COORDINATOR_AUTHORIZE_BOND
           2359                         ;typedef struct
           2360                         ;{
           2361                         ;  uns8  BondAddr;
           2362                         ;  uns8  DevNr;
           2363                         ;} STRUCTATTR TPerCoordinatorAuthorizeBond_Response;
           2364                         ;
           2365                         ;// Structure for CMD_COORDINATOR_BRIDGE
           2366                         ;typedef struct
           2367                         ;{
           2368                         ;  TDpaIFaceHeader subHeader;
           2369                         ;  uns8  subPData[DPA_MAX_DATA_LENGTH - sizeof( TDpaIFaceHeader )];
           2370                         ;} STRUCTATTR TPerCoordinatorBridge_Request;
           2371                         ;
           2372                         ;// Structure returned by CMD_COORDINATOR_BRIDGE
           2373                         ;typedef struct
           2374                         ;{
           2375                         ;  TDpaIFaceHeader subHeader;
           2376                         ;  uns8  subRespCode;
           2377                         ;  uns8  subDpaValue;
           2378                         ;  uns8  subPData[DPA_MAX_DATA_LENGTH - sizeof( TDpaIFaceHeader ) - 2 * sizeof( uns8 )];
           2379                         ;} STRUCTATTR TPerCoordinatorBridge_Response;
           2380                         ;
           2381                         ;// Structure for CMD_COORDINATOR_SMART_CONNECT
           2382                         ;typedef struct
           2383                         ;{
           2384                         ;  uns8  ReqAddr;
           2385                         ;  uns8  BondingTestRetries;
           2386                         ;  uns8  IBK[16];
           2387                         ;  uns8  MID[4];
           2388                         ;  uns8  reserved0;
           2389                         ;  uns8  VirtualDeviceAddress;
           2390                         ;  uns8  UserData[4];
           2391                         ;  uns8  reserved1[10];
           2392                         ;} STRUCTATTR TPerCoordinatorSmartConnect_Request;
           2393                         ;
           2394                         ;// Structure for CMD_COORDINATOR_SET_MID
           2395                         ;typedef struct
           2396                         ;{
           2397                         ;  uns8  MID[4];
           2398                         ;  uns8  BondAddr;
           2399                         ;} STRUCTATTR TPerCoordinatorSetMID_Request;
           2400                         ;
           2401                         ;// Structure returned by CMD_NODE_READ
           2402                         ;typedef struct
           2403                         ;{
           2404                         ;  uns8  ntwADDR;
           2405                         ;  uns8  ntwVRN;
           2406                         ;  uns8  ntwZIN;
           2407                         ;  uns8  ntwDID;
           2408                         ;  uns8  ntwPVRN;
           2409                         ;  uns16 ntwUSERADDRESS;
           2410                         ;  uns16 ntwID;
           2411                         ;  uns8  ntwVRNFNZ;
           2412                         ;  uns8  ntwCFG;
           2413                         ;  uns8  Flags;
           2414                         ;} STRUCTATTR TPerNodeRead_Response;
           2415                         ;
           2416                         ;// Structures for CMD_NODE_VALIDATE_BONDS
           2417                         ;typedef struct
           2418                         ;{
           2419                         ;  uns8  Address;
           2420                         ;  uns8  MID[4];
           2421                         ;} STRUCTATTR TPerNodeValidateBondsItem;
           2422                         ;
           2423                         ;// Structure for CMD_NODE_VALIDATE_BONDS
           2424                         ;typedef struct
           2425                         ;{
           2426                         ;  TPerNodeValidateBondsItem Bonds[DPA_MAX_DATA_LENGTH / sizeof( TPerNodeValidateBondsItem )];
           2427                         ;} STRUCTATTR TPerNodeValidateBonds_Request;
           2428                         ;
           2429                         ;// Structure returned by CMD_OS_READ
           2430                         ;typedef struct
           2431                         ;{
           2432                         ;  uns8  MID[4];
           2433                         ;  uns8  OsVersion;
           2434                         ;  uns8  TrType;
           2435                         ;  uns16 OsBuild;
           2436                         ;  uns8  Rssi;
           2437                         ;  uns8  SupplyVoltage;
           2438                         ;  uns8  Flags;
           2439                         ;  uns8  SlotLimits;
           2440                         ;  uns8  IBK[16];
           2441                         ;  // Enumerate peripherals part, variable length because of UserPer field
           2442                         ;  uns16 DpaVersion;
           2443                         ;  uns8  UserPerNr;
           2444                         ;  uns8  EmbeddedPers[PNUM_USER / 8];
           2445                         ;  uns16 HWPID;
           2446                         ;  uns16 HWPIDver;
           2447                         ;  uns8  FlagsEnum;
           2448                         ;  uns8  UserPer[( PNUM_MAX - PNUM_USER + 1 + 7 ) / 8];
           2449                         ;} STRUCTATTR TPerOSRead_Response;
           2450                         ;
           2451                         ;// Structure returned by CMD_OS_READ_CFG
           2452                         ;typedef struct
           2453                         ;{
           2454                         ;  uns8  Checksum;
           2455                         ;  uns8  Configuration[31];
           2456                         ;  uns8  RFPGM;
           2457                         ;  uns8  Undocumented[1];
           2458                         ;} STRUCTATTR TPerOSReadCfg_Response;
           2459                         ;
           2460                         ;// Structure for CMD_OS_WRITE_CFG
           2461                         ;typedef struct
           2462                         ;{
           2463                         ;  uns8  Undefined;
           2464                         ;  uns8  Configuration[31];
           2465                         ;  uns8  RFPGM;
           2466                         ;} STRUCTATTR TPerOSWriteCfg_Request;
           2467                         ;
           2468                         ;// Structures for CMD_OS_WRITE_CFG_BYTE
           2469                         ;typedef struct
           2470                         ;{
           2471                         ;  uns8  Address;
           2472                         ;  uns8  Value;
           2473                         ;  uns8  Mask;
           2474                         ;} STRUCTATTR TPerOSWriteCfgByteTriplet;
           2475                         ;
           2476                         ;// Structure for CMD_OS_WRITE_CFG_BYTE
           2477                         ;typedef struct
           2478                         ;{
           2479                         ;  TPerOSWriteCfgByteTriplet Triplets[DPA_MAX_DATA_LENGTH / sizeof( TPerOSWriteCfgByteTriplet )];
           2480                         ;} STRUCTATTR TPerOSWriteCfgByte_Request;
           2481                         ;
           2482                         ;// Structure for CMD_OS_SET_SECURITY
           2483                         ;typedef struct
           2484                         ;{
           2485                         ;  uns8  Type;
           2486                         ;  uns8  Data[16];
           2487                         ;} STRUCTATTR TPerOSSetSecurity_Request;
           2488                         ;
           2489                         ;// Structure for CMD_OS_LOAD_CODE
           2490                         ;typedef struct
           2491                         ;{
           2492                         ;  uns8  Flags;
           2493                         ;  uns16 Address;
           2494                         ;  uns16 Length;
           2495                         ;  uns16 CheckSum;
           2496                         ;} STRUCTATTR TPerOSLoadCode_Request;
           2497                         ;
           2498                         ;// Structure for CMD_OS_SLEEP
           2499                         ;typedef struct
           2500                         ;{
           2501                         ;  uns16 Time;
           2502                         ;  uns8  Control;
           2503                         ;} STRUCTATTR TPerOSSleep_Request;
           2504                         ;
           2505                         ;// Structure for CMD_OS_SELECTIVE_BATCH
           2506                         ;typedef struct
           2507                         ;{
           2508                         ;  uns8  SelectedNodes[30];
           2509                         ;  uns8  Requests[DPA_MAX_DATA_LENGTH - 30];
           2510                         ;} STRUCTATTR TPerOSSelectiveBatch_Request;
           2511                         ;
           2512                         ;// Structure for CMD_OS_TEST_RF_SIGNAL request
           2513                         ;typedef struct
           2514                         ;{
           2515                         ;  uns8  Channel;
           2516                         ;  uns8  RXfilter;
           2517                         ;  uns16 Time;
           2518                         ;} STRUCTATTR TPerOSTestRfSignal_Request;
           2519                         ;
           2520                         ;// Structure for CMD_OS_TEST_RF_SIGNAL response
           2521                         ;typedef struct
           2522                         ;{
           2523                         ;  uns8  Counter;
           2524                         ;} STRUCTATTR TPerOSTestRfSignal_Response;
           2525                         ;
           2526                         ;// Structure for CMD_OS_INDICATE request
           2527                         ;typedef struct
           2528                         ;{
           2529                         ;  uns8  Control;
           2530                         ;} STRUCTATTR TPerOSIndicate_Request;
           2531                         ;
           2532                         ;// Structure for general memory request
           2533                         ;typedef struct
           2534                         ;{
           2535                         ;  // Address of data to write or read
           2536                         ;  uns8  Address;
           2537                         ;
           2538                         ;  union
           2539                         ;  {
           2540                         ;    // Memory read request
           2541                         ;    struct
           2542                         ;    {
           2543                         ;      // Length of data to read
           2544                         ;      uns8  Length;
           2545                         ;    } Read;
           2546                         ;
           2547                         ;    // Size of Address field
           2548                         ;#define MEMORY_WRITE_REQUEST_OVERHEAD   ( sizeof( uns8 ) )
           2549                         ;
           2550                         ;    // Memory write request
           2551                         ;    struct
           2552                         ;    {
           2553                         ;      uns8  PData[DPA_MAX_DATA_LENGTH - MEMORY_WRITE_REQUEST_OVERHEAD];
           2554                         ;    } Write;
           2555                         ;
           2556                         ;  } ReadWrite;
           2557                         ;} STRUCTATTR TPerMemoryRequest;
           2558                         ;
           2559                         ;// Structure for general extended memory request
           2560                         ;typedef struct
           2561                         ;{
           2562                         ;  // Address of data to write or read
           2563                         ;  uns16 Address;
           2564                         ;
           2565                         ;  union
           2566                         ;  {
           2567                         ;    // Memory read request
           2568                         ;    struct
           2569                         ;    {
           2570                         ;      // Length of data to read
           2571                         ;      uns8  Length;
           2572                         ;    } Read;
           2573                         ;
           2574                         ;    // Size of Address field
           2575                         ;#define XMEMORY_WRITE_REQUEST_OVERHEAD  ( sizeof( uns16 ) )
           2576                         ;
           2577                         ;    // Memory write request
           2578                         ;    struct
           2579                         ;    {
           2580                         ;      uns8  PData[DPA_MAX_DATA_LENGTH - XMEMORY_WRITE_REQUEST_OVERHEAD];
           2581                         ;    } Write;
           2582                         ;
           2583                         ;  } ReadWrite;
           2584                         ;} STRUCTATTR TPerXMemoryRequest;
           2585                         ;
           2586                         ;// Structure for CMD_IO requests
           2587                         ;typedef struct
           2588                         ;{
           2589                         ;  uns8  Port;
           2590                         ;  uns8  Mask;
           2591                         ;  uns8  Value;
           2592                         ;} STRUCTATTR TPerIOTriplet;
           2593                         ;
           2594                         ;typedef struct
           2595                         ;{
           2596                         ;  uns8  Header; // == PNUM_IO_DELAY
           2597                         ;  uns16 Delay;
           2598                         ;} STRUCTATTR TPerIODelay;
           2599                         ;
           2600                         ;// Union for CMD_IO_SET and CMD_IO_DIRECTION requests
           2601                         ;typedef union
           2602                         ;{
           2603                         ;  TPerIOTriplet Triplets[DPA_MAX_DATA_LENGTH / sizeof( TPerIOTriplet )];
           2604                         ;  TPerIODelay   Delays[DPA_MAX_DATA_LENGTH / sizeof( TPerIODelay )];
           2605                         ;} STRUCTATTR TPerIoDirectionAndSet_Request;
           2606                         ;
           2607                         ;// Structure returned by CMD_THERMOMETER_READ
           2608                         ;typedef struct
           2609                         ;{
           2610                         ;  int8  IntegerValue;
           2611                         ;  int16 SixteenthValue;
           2612                         ;} STRUCTATTR TPerThermometerRead_Response;
           2613                         ;
           2614                         ;// Structure for CMD_UART_OPEN
           2615                         ;typedef struct
           2616                         ;{
           2617                         ;  uns8  BaudRate;
           2618                         ;} STRUCTATTR TPerUartOpen_Request;
           2619                         ;
           2620                         ;// Structure for CMD_UART_[CLEAR_]WRITE_READ
           2621                         ;typedef struct
           2622                         ;{
           2623                         ;  uns8  ReadTimeout;
           2624                         ;  uns8  WrittenData[DPA_MAX_DATA_LENGTH - sizeof( uns8 )];
           2625                         ;} STRUCTATTR TPerUartWriteRead_Request;
           2626                         ;
           2627                         ;// Structure for CMD_FRC_SEND
           2628                         ;typedef struct
           2629                         ;{
           2630                         ;  uns8  FrcCommand;
           2631                         ;  uns8  UserData[30];
           2632                         ;} STRUCTATTR TPerFrcSend_Request;
           2633                         ;
           2634                         ;// Structure for CMD_FRC_SEND_SELECTIVE
           2635                         ;typedef struct
           2636                         ;{
           2637                         ;  uns8  FrcCommand;
           2638                         ;  uns8  SelectedNodes[30];
           2639                         ;  uns8  UserData[25];
           2640                         ;} STRUCTATTR TPerFrcSendSelective_Request;
           2641                         ;
           2642                         ;// Structure returned by CMD_FRC_SEND and CMD_FRC_SEND_SELECTIVE
           2643                         ;typedef struct
           2644                         ;{
           2645                         ;  uns8  Status;
           2646                         ;  uns8  FrcData[DPA_MAX_DATA_LENGTH - sizeof( uns8 )];
           2647                         ;} STRUCTATTR TPerFrcSend_Response;
           2648                         ;
           2649                         ;// Structure for request and response of CMD_FRC_SET_PARAMS
           2650                         ;typedef struct
           2651                         ;{
           2652                         ;  uns8  FrcParams;
           2653                         ;} STRUCTATTR TPerFrcSetParams_RequestResponse;
           2654                         ;
           2655                         ;// Interface and CMD_COORDINATOR_BRIDGE confirmation structure
           2656                         ;typedef struct
           2657                         ;{
           2658                         ;  // Number of hops
           2659                         ;  uns8  Hops;
           2660                         ;  // Time slot length in 10ms
           2661                         ;  uns8  TimeSlotLength;
           2662                         ;  // Number of hops for response
           2663                         ;  uns8  HopsResponse;
           2664                         ;} STRUCTATTR TIFaceConfirmation;
           2665                         ;
           2666                         ;// ---------------------------------------------------------
           2667                         ;
           2668                         ;// DPA Message data structure (packet w/o NADR, PNUM, PCMD, HWPID)
           2669                         ;typedef union
           2670                         ;{
           2671                         ;  // General DPA request
           2672                         ;  struct
           2673                         ;  {
           2674                         ;    uns8    PData[DPA_MAX_DATA_LENGTH];
           2675                         ;  } Request;
           2676                         ;
           2677                         ;  // General DPA response
           2678                         ;  struct
           2679                         ;  {
           2680                         ;    uns8    PData[DPA_MAX_DATA_LENGTH];
           2681                         ;  } Response;
           2682                         ;
           2683                         ;  // Enumerate peripherals structure
           2684                         ;  TEnumPeripheralsAnswer EnumPeripheralsAnswer;
           2685                         ;
           2686                         ;  // Get peripheral info structure (CMD_GET_PER_INFO)
           2687                         ;  TPeripheralInfoAnswer PeripheralInfoAnswer;
           2688                         ;
           2689                         ;  // Get peripheral info structure (CMD_GET_PER_INFO) for more peripherals
           2690                         ;  TPeripheralInfoAnswer PeripheralInfoAnswers[MAX_PERIPHERALS_PER_BLOCK_INFO];
           2691                         ;
           2692                         ;  // Error DPA response (PNUM_ERROR_FLAG)
           2693                         ;  TErrorAnswer ErrorAnswer;
           2694                         ;
           2695                         ;  // Structure returned by CMD_COORDINATOR_ADDR_INFO
           2696                         ;  TPerCoordinatorAddrInfo_Response PerCoordinatorAddrInfo_Response;
           2697                         ;
           2698                         ;  // Structure for CMD_COORDINATOR_BOND_NODE
           2699                         ;  TPerCoordinatorBondNode_Request PerCoordinatorBondNode_Request;
           2700                         ;
           2701                         ;  // Structure returned by CMD_COORDINATOR_BOND_NODE or CMD_COORDINATOR_SMART_CONNECT
           2702                         ;  TPerCoordinatorBondNodeSmartConnect_Response PerCoordinatorBondNodeSmartConnect_Response;
           2703                         ;
           2704                         ;  // Structure for CMD_COORDINATOR_REMOVE_BOND
           2705                         ;  TPerCoordinatorRemoveBond_Request PerCoordinatorRemoveBond_Request;
           2706                         ;
           2707                         ;  // Structure returned by CMD_COORDINATOR_REMOVE_BOND
           2708                         ;  TPerCoordinatorRemoveBond_Response PerCoordinatorRemoveBond_Response;
           2709                         ;
           2710                         ;  // Structure for CMD_COORDINATOR_DISCOVERY
           2711                         ;  TPerCoordinatorDiscovery_Request PerCoordinatorDiscovery_Request;
           2712                         ;
           2713                         ;  // Structure returned by CMD_COORDINATOR_DISCOVERY
           2714                         ;  TPerCoordinatorDiscovery_Response PerCoordinatorDiscovery_Response;
           2715                         ;
           2716                         ;  // Structure for and also returned by CMD_COORDINATOR_SET_DPAPARAMS
           2717                         ;  TPerCoordinatorSetDpaParams_Request_Response PerCoordinatorSetDpaParams_Request_Response;
           2718                         ;
           2719                         ;  // Structure for and also returned by CMD_COORDINATOR_SET_HOPS
           2720                         ;  TPerCoordinatorSetHops_Request_Response PerCoordinatorSetHops_Request_Response;
           2721                         ;
           2722                         ;  // Structure for CMD_COORDINATOR_BACKUP and CMD_NODE_BACKUP
           2723                         ;  TPerCoordinatorNodeBackup_Request PerCoordinatorNodeBackup_Request;
           2724                         ;
           2725                         ;  // Structure returned by CMD_COORDINATOR_BACKUP and CMD_NODE_BACKUP
           2726                         ;  TPerCoordinatorNodeBackup_Response PerCoordinatorNodeBackup_Response;
           2727                         ;
           2728                         ;  // Structure for CMD_COORDINATOR_RESTORE and CMD_NODE_RESTORE
           2729                         ;  TPerCoordinatorNodeRestore_Request PerCoordinatorNodeRestore_Request;
           2730                         ;
           2731                         ;  // Structure for CMD_COORDINATOR_AUTHORIZE_BOND
           2732                         ;  TPerCoordinatorAuthorizeBond_Request PerCoordinatorAuthorizeBond_Request;
           2733                         ;
           2734                         ;  // Structure returned by CMD_COORDINATOR_AUTHORIZE_BOND
           2735                         ;  TPerCoordinatorAuthorizeBond_Response PerCoordinatorAuthorizeBond_Response;
           2736                         ;
           2737                         ;  // Structure for CMD_COORDINATOR_BRIDGE
           2738                         ;  TPerCoordinatorBridge_Request PerCoordinatorBridge_Request;
           2739                         ;
           2740                         ;  // Structure returned by CMD_COORDINATOR_BRIDGE
           2741                         ;  TPerCoordinatorBridge_Response PerCoordinatorBridge_Response;
           2742                         ;
           2743                         ;  // Structure for CMD_COORDINATOR_SMART_CONNECT
           2744                         ;  TPerCoordinatorSmartConnect_Request PerCoordinatorSmartConnect_Request;
           2745                         ;
           2746                         ;  // Structure for CMD_COORDINATOR_SET_MID
           2747                         ;  TPerCoordinatorSetMID_Request PerCoordinatorSetMID_Request;
           2748                         ;
           2749                         ;  // Structure returned by CMD_NODE_READ
           2750                         ;  TPerNodeRead_Response PerNodeRead_Response;
           2751                         ;
           2752                         ;  // Structure for CMD_NODE_VALIDATE_BONDS
           2753                         ;  TPerNodeValidateBonds_Request PerNodeValidateBonds_Request;
           2754                         ;
           2755                         ;  // Structure returned by CMD_OS_READ
           2756                         ;  TPerOSRead_Response PerOSRead_Response;
           2757                         ;
           2758                         ;  // Structure returned by CMD_OS_READ_CFG
           2759                         ;  TPerOSReadCfg_Response PerOSReadCfg_Response;
           2760                         ;
           2761                         ;  // Structure for CMD_OS_WRITE_CFG
           2762                         ;  TPerOSWriteCfg_Request PerOSWriteCfg_Request;
           2763                         ;
           2764                         ;  // Structure for CMD_OS_WRITE_CFG_BYTE
           2765                         ;  TPerOSWriteCfgByte_Request PerOSWriteCfgByte_Request;
           2766                         ;
           2767                         ;  // Structure for CMD_OS_SET_SECURITY
           2768                         ;  TPerOSSetSecurity_Request PerOSSetSecurity_Request;
           2769                         ;
           2770                         ;  // Structure for CMD_OS_LOAD_CODE
           2771                         ;  TPerOSLoadCode_Request PerOSLoadCode_Request;
           2772                         ;
           2773                         ;  // Structure for CMD_OS_SLEEP
           2774                         ;  TPerOSSleep_Request PerOSSleep_Request;
           2775                         ;
           2776                         ;  // Structure for CMD_OS_SELECTIVE_BATCH
           2777                         ;  TPerOSSelectiveBatch_Request PerOSSelectiveBatch_Request;
           2778                         ;
           2779                         ;  // Structure for CMD_OS_TEST_RF_SIGNAL request
           2780                         ;  TPerOSTestRfSignal_Request PerOSTestRfSignal_Request;
           2781                         ;
           2782                         ;  // Structure for CMD_OS_INDICATE request
           2783                         ;  TPerOSIndicate_Request PerOSIndicate_Request;
           2784                         ;
           2785                         ;  // Structure for CMD_OS_TEST_RF_SIGNAL response
           2786                         ;  TPerOSTestRfSignal_Response PerOSTestRfSignal_Response;
           2787                         ;
           2788                         ;  // Structure for general memory request
           2789                         ;  TPerMemoryRequest MemoryRequest;
           2790                         ;
           2791                         ;  // Structure for general extended memory request
           2792                         ;  TPerXMemoryRequest XMemoryRequest;
           2793                         ;
           2794                         ;  // Structure for CMD_IO requests
           2795                         ;  TPerIoDirectionAndSet_Request PerIoDirectionAndSet_Request;
           2796                         ;
           2797                         ;  // Structure returned by CMD_THERMOMETER_READ
           2798                         ;  TPerThermometerRead_Response PerThermometerRead_Response;
           2799                         ;
           2800                         ;  // Structure for CMD_UART_OPEN
           2801                         ;  TPerUartOpen_Request PerUartOpen_Request;
           2802                         ;
           2803                         ;  // Structure for CMD_UART_[CLEAR_]WRITE_READ
           2804                         ;  TPerUartWriteRead_Request PerUartWriteRead_Request;
           2805                         ;
           2806                         ;  // Structure for CMD_FRC_SEND
           2807                         ;  TPerFrcSend_Request PerFrcSend_Request;
           2808                         ;
           2809                         ;  // Structure returned by CMD_FRC_SEND and CMD_FRC_SEND_SELECTIVE
           2810                         ;  TPerFrcSend_Response PerFrcSend_Response;
           2811                         ;
           2812                         ;  // Structure for CMD_FRC_SEND_SELECTIVE
           2813                         ;  TPerFrcSendSelective_Request PerFrcSendSelective_Request;
           2814                         ;
           2815                         ;  // Structure for request and response of CMD_FRC_SET_PARAMS
           2816                         ;  TPerFrcSetParams_RequestResponse PerFrcSetParams_RequestResponse;
           2817                         ;
           2818                         ;  // Interface and CMD_COORDINATOR_BRIDGE confirmation structure
           2819                         ;  TIFaceConfirmation IFaceConfirmation;
           2820                         ;} TDpaMessage;
           2821                         ;
           2822                         ;// Custom DPA Handler events
           2823                         ;#define DpaEvent_DpaRequest               0
           2824                         ;#define DpaEvent_Interrupt                1
           2825                         ;#define DpaEvent_Idle                     2
           2826                         ;#define DpaEvent_Init                     3
           2827                         ;#define DpaEvent_Notification             4
           2828                         ;#define DpaEvent_AfterRouting             5
           2829                         ;#define DpaEvent_BeforeSleep              6
           2830                         ;#define DpaEvent_AfterSleep               7
           2831                         ;#define DpaEvent_Reset                    8
           2832                         ;#define DpaEvent_DisableInterrupts        9
           2833                         ;#define DpaEvent_FrcValue                 10
           2834                         ;#define DpaEvent_ReceiveDpaResponse       11
           2835                         ;#define DpaEvent_IFaceReceive             12
           2836                         ;#define DpaEvent_ReceiveDpaRequest        13
           2837                         ;#define DpaEvent_BeforeSendingDpaResponse 14
           2838                         ;#define DpaEvent_PeerToPeer               15
           2839                         ;#define DpaEvent_UserDpaValue             17
           2840                         ;#define DpaEvent_FrcResponseTime          18
           2841                         ;#if defined( TR7xD )
           2842                         ;#define DpaEvent_BondingButton            19
           2843                         ;#endif
           2844                         ;#define DpaEvent_Indicate                 20
           2845                         ;#define DpaEvent_VerifyLocalFrc           21
           2846                         ;#if !defined( TR7xD )
           2847                         ;#define DpaEvent_MenuActivated            22
           2848                         ;#define DpaEvent_MenuItemSelected         23
           2849                         ;#define DpaEvent_MenuItemFinalize         24
           2850                         ;#define DpaEvent_InStandby                25
           2851                         ;#endif
           2852                         ;
           2853                         ;#if defined( TR7xD )
           2854                         ;#define DpaEvent_LAST                     DpaEvent_VerifyLocalFrc
           2855                         ;#else
           2856                         ;#define DpaEvent_LAST                     DpaEvent_InStandby
           2857                         ;#endif
           2858                         ;
           2859                         ;// Types of the diagnostic DPA Value that is returned inside DPA response
           2860                         ;typedef enum
           2861                         ;{
           2862                         ;  DpaValueType_RSSI = 0,
           2863                         ;  DpaValueType_SupplyVoltage = 1,
           2864                         ;  DpaValueType_System = 2,
           2865                         ;  DpaValueType_User = 3
           2866                         ;} TDpaValueType;
           2867                         ;
           2868                         ;// Type (color) of LED peripheral
           2869                         ;typedef enum
           2870                         ;{
           2871                         ;  LED_COLOR_RED = 0,
           2872                         ;  LED_COLOR_GREEN = 1,
           2873                         ;  LED_COLOR_BLUE = 2,
           2874                         ;  LED_COLOR_YELLOW = 3,
           2875                         ;  LED_COLOR_WHITE = 4,
           2876                         ;  LED_COLOR_UNKNOWN = 0xff
           2877                         ;} TLedColor;
           2878                         ;
           2879                         ;// Baud rates
           2880                         ;typedef enum
           2881                         ;{
           2882                         ;  DpaBaud_1200 = 0x00,
           2883                         ;  DpaBaud_2400 = 0x01,
           2884                         ;  DpaBaud_4800 = 0x02,
           2885                         ;  DpaBaud_9600 = 0x03,
           2886                         ;  DpaBaud_19200 = 0x04,
           2887                         ;  DpaBaud_38400 = 0x05,
           2888                         ;  DpaBaud_57600 = 0x06,
           2889                         ;  DpaBaud_115200 = 0x07,
           2890                         ;  DpaBaud_230400 = 0x08
           2891                         ;} TBaudRates;
           2892                         ;
           2893                         ;// Useful PNUM_IO definitions
           2894                         ;typedef enum
           2895                         ;{
           2896                         ;  PNUM_IO_PORTA = 0x00,
           2897                         ;  PNUM_IO_TRISA = 0x00,
           2898                         ;
           2899                         ;  PNUM_IO_PORTB = 0x01,
           2900                         ;  PNUM_IO_TRISB = 0x01,
           2901                         ;
           2902                         ;  PNUM_IO_PORTC = 0x02,
           2903                         ;  PNUM_IO_TRISC = 0x02,
           2904                         ;
           2905                         ;  PNUM_IO_PORTE = 0x04,
           2906                         ;  PNUM_IO_TRISE = 0x04,
           2907                         ;
           2908                         ;  PNUM_IO_WPUB = 0x11,
           2909                         ;#if !defined( TR7xD )
           2910                         ;  PNUM_IO_WPUA = 0x10,
           2911                         ;  PNUM_IO_WPUC = 0x12,
           2912                         ;  PNUM_IO_WPUE = 0x14,
           2913                         ;#endif
           2914                         ;  PNUM_IO_DELAY = 0xff,
           2915                         ;} PNUM_IO_Definitions;
           2916                         ;
           2917                         ;// To test for enumeration peripherals request
           2918                         ;#define IsDpaEnumPeripheralsRequestNoSize() ( _PNUM == PNUM_ENUMERATION && _PCMD == CMD_GET_PER_INFO )
           2919                         ;
           2920                         ;#if PARAM_CHECK_LEVEL >= 2
           2921                         ;#define IsDpaEnumPeripheralsRequest() ( IsDpaEnumPeripheralsRequestNoSize() && _DpaDataLength == 0 )
           2922                         ;#else
           2923                         ;#define IsDpaEnumPeripheralsRequest() IsDpaEnumPeripheralsRequestNoSize()
           2924                         ;#endif
           2925                         ;
           2926                         ;// To test for peripherals information request
           2927                         ;#define IsDpaPeripheralInfoRequestNoSize()  ( _PNUM != PNUM_ENUMERATION && _PCMD == CMD_GET_PER_INFO )
           2928                         ;
           2929                         ;#if PARAM_CHECK_LEVEL >= 2
           2930                         ;#define IsDpaPeripheralInfoRequest()  ( IsDpaPeripheralInfoRequestNoSize() && _DpaDataLength == 0 )
           2931                         ;#else
           2932                         ;#define IsDpaPeripheralInfoRequest()  IsDpaPeripheralInfoRequestNoSize()
           2933                         ;#endif
           2934                         ;
           2935                         ;// Optimized macro for both testing enumeration peripherals ELSE peripherals information. See examples
           2936                         ;#define IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequestNoSize() if ( _PCMD == CMD_GET_PER_INFO ) if ( _PNUM == PNUM_ENUMERATION )
           2937                         ;
           2938                         ;#if PARAM_CHECK_LEVEL >= 2
           2939                         ;#define IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequest() if ( _DpaDataLength == 0 && _PCMD == CMD_GET_PER_INFO ) if ( _PNUM == PNUM_ENUMERATION )
           2940                         ;#else
           2941                         ;#define IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequest() IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequestNoSize()
           2942                         ;#endif
           2943                         ;
           2944                         ;#if defined( __CC5X__ ) && !defined( CC5XnotDPA )
           2945                         ;
           2946                         ;// DPA message at bufferRF
           2947                         ;TDpaMessage DpaRfMessage @bufferRF;
           2948                         ;
           2949                         ;// Note: Works only, because _DpaMessage.Request.PData is at the same location as bufferRF!
           2950                         ;#define _FSR_DPA    _FSR_RF
           2951                         ;
           2952                         ;// Actual allocation of the RAM Peripheral memory block @ UserBank_02
           2953                         ;bank12 uns8  PeripheralRam[PERIPHERAL_RAM_LENGTH] @ 0x620;
           2954                         ;
           2955                         ;// Actual DPA message parameters at memory
           2956                         ;#define _NADR           RX
           2957                         ;#define _NADRhigh       RTAUX
           2958                         ;#define _PNUM           PNUM
           2959                         ;#define _PCMD           PCMD
           2960                         ;#define _DpaDataLength  DLEN
           2961                         ;#define _DpaMessage     DpaRfMessage
           2962                         ;
           2963                         ;// Return actual DPA user routine event
           2964                         ;#define GetDpaEvent()   userReg0
           2965                         ;
           2966                         ;// Stores DPA Params inside DPA request/response
           2967                         ;#define _DpaParams      PPAR
           2968                         ;// Get DPA Value type out of the DPA Params
           2969                         ;#define DpaValueType()  ( _DpaParams & 0b11 )
           2970                         ;
           2971                         ;// When TRUE then encryptBufferRF/decryptBufferRF is done by AccessPassord
           2972                         ;bit encryptByAccessPassword @ usedBank0[0x23].7;
           2973                         ;
           2974                         ;// DP2P response time-slot time in 10 ms
           2975                         ;#define DP2P_TIMESLOT   11
           2976                         ;
           2977                         ;// DP2P request packet. Fills out the whole bufferRF.
           2978                         ;typedef struct
           2979                         ;{
           2980                         ;  uns8  Header[3];  // 0x000000
           2981                         ;  uns8  SelectedNodes[30];
           2982                         ;  uns8  SlotLength;
           2983                         ;  uns8  ResponseTxPower;
           2984                         ;  uns8  Reserved;
           2985                         ;  uns16 HWPID;
           2986                         ;  uns8  PDATA[sizeofBufferRF - ( 3 + 30 + 1 + 1 + 1 ) * sizeof( uns8 ) - ( 1 ) * sizeof( uns16 )]; // size is 26 bytes
           2987                         ;} STRUCTATTR TDP2Prequest;
           2988                         ;
           2989                         ;// DP2P invite packet.
           2990                         ;typedef struct
           2991                         ;{
           2992                         ;  uns8  Header[3];  // 0x000001
           2993                         ;  uns8  NADR;
           2994                         ;  uns8  Rand[12];
           2995                         ;} STRUCTATTR TDP2Invite;
           2996                         ;
           2997                         ;// DP2P confirm packet.
           2998                         ;typedef struct
           2999                         ;{
           3000                         ;  uns8  Header[3];  // 0x000003
           3001                         ;  uns8  NADR;
           3002                         ;  uns8  Rand[12];
           3003                         ;} STRUCTATTR TDP2Confirm;
           3004                         ;
           3005                         ;// DP2P response packet.
           3006                         ;typedef struct
           3007                         ;{
           3008                         ;  uns8  Header[3];  // 0xFfFfFf
           3009                         ;  uns8  NADR;
           3010                         ;  uns8  PDATA[DPA_MAX_DATA_LENGTH];
           3011                         ;} STRUCTATTR TDP2Presponse;
           3012                         ;
           3013                         ;#ifndef TR7xD
           3014                         ;
           3015                         ;// Menus
           3016                         ;#define DMENU_Online                                  0x0
           3017                         ;#define DMENU_ReadyToBond                             0x1
           3018                         ;#define DMENU_Beaming                                 0x2
           3019                         ;#define DMENU_Standby                                 0x3
           3020                         ;
           3021                         ;// Menu items
           3022                         ;#define DMENU_Item_None                               0x0
           3023                         ;#define DMENU_Item_Beaming                            ( DMENU_Online + 1 )
           3024                         ;#define DMENU_Item_BondRequest                        ( DMENU_ReadyToBond + 1 )
           3025                         ;#define DMENU_Item_ConnectivityCheck                  ( DMENU_Beaming + 1 )
           3026                         ;#define DMENU_Item_ExitStandby                        ( DMENU_Standby + 1 )
           3027                         ;#define DMENU_Item_StateIndication                    ( DMENU_Item_ExitStandby + 1 )
           3028                         ;#define DMENU_Item_User1                              ( DMENU_Item_StateIndication + 1 )
           3029                         ;#define DMENU_Item_User2                              ( DMENU_Item_User1 + 1 )
           3030                         ;#define DMENU_Item_Standby                            ( DMENU_Item_User2 + 1 )
           3031                         ;#define DMENU_Item_Reset                              ( DMENU_Item_Standby + 1 )
           3032                         ;#define DMENU_Item_UnbondAndRestart                   ( DMENU_Item_Reset + 2 )
           3033                         ;#define DMENU_Item_UnbondFactorySettingsAndRestart    ( DMENU_Item_UnbondAndRestart + 1 )
           3034                         ;
           3035                         ;// Flags for enabling/disabling menu items at event DpaEvent_MenuActivated (when TRUE is returned) and at DpaApiMenu call
           3036                         ;#define DMENU_Item_Implemented_Beaming                            0b0000.0001
           3037                         ;#define DMENU_Item_Implemented_User1                              0b0000.0100
           3038                         ;#define DMENU_Item_Implemented_User1Confirmed                     ( DMENU_Item_Implemented_User1 | DMENU_Item_Confirm_User1 )
           3039                         ;#define DMENU_Item_Implemented_User2                              0b0000.1000
           3040                         ;#define DMENU_Item_Implemented_User2Confirmed                     ( DMENU_Item_Implemented_User2 | DMENU_Item_Confirm_User2 )
           3041                         ;
           3042                         ;#define DMENU_Item_Unimplemented_Standby                          0b0001.0000
           3043                         ;#define DMENU_Item_Unimplemented_UnbondAndRestart                 0b0100.0000
           3044                         ;#define DMENU_Item_Unimplemented_UnbondFactorySettingsAndRestart  0b1000.0000
           3045                         ;
           3046                         ;#define DMENU_Item_Confirm_User1                                  0b0000.0010
           3047                         ;#define DMENU_Item_Confirm_User2                                  0b0010.0000
           3048                         ;
           3049                         ;// Flags for DpaEvent_MenuActivated when FALSE is returned
           3050                         ;#define DMENU_MenuActivated_DoNotOpen                             0b1000.0000
           3051                         ;
           3052                         ;// Macro to construct value containing both menu and item values
           3053                         ;#define MakeDMenuAndItem( menu, menuItem )            ( ((menu) << 4 ) | (menuItem) )
           3054                         ;// Macro to get menu from menu&item value
           3055                         ;#define GetDMenu( menuAndItem )                       ( (menuAndItem) >> 4 )
           3056                         ;// Macro to get menu item from menu&item value
           3057                         ;#define GetDMenuItem( menuAndItem )                   ( (menuAndItem) & 0x0F )
           3058                         ;
           3059                         ;#endif
           3060                         ;// Include assembler definitions
           3061                         ;#include "HexCodes.h"
           3062                         ;// CC5X fix
           3063                         ;#if __CC5X__ <= 3800 && _16LF18877 == 1
           3064                         ;#undef  __MOVLB
           3065                         ;#define __MOVLB(k)    (0x0140+((k)&0x3F))
           3066                         ;#endif
           3067                         ;
           3068                         ;// Next code must start at the IQRF APPLICATION routine entry point
           3069                         ;#pragma origin __APPLICATION_ADDRESS
     0000  3070         ORG 0x3A00
           3071 
           3072   ; FILE C:\customdpa\CustomDpaHandlerExample\..\Include\DPAcustomHandler.h
           3073                         ;// *********************************************************************
           3074                         ;//   Main Custom DPA Handler header                                    *
           3075                         ;// *********************************************************************
           3076                         ;// Copyright (c) MICRORISC s.r.o.
           3077                         ;//
           3078                         ;// File:    $RCSfile: DPAcustomHandler.h,v $
           3079                         ;// Version: $Revision: 1.167 $
           3080                         ;// Date:    $Date: 2024/12/05 09:28:58 $
           3081                         ;//
           3082                         ;// Revision history:
           3083                         ;//   2024/11/05  Release for DPA 4.32
           3084                         ;//   2024/04/17  Release for DPA 4.31
           3085                         ;//   2023/03/07  Release for DPA 4.30
           3086                         ;//   2022/10/05  Release for DPA 4.18
           3087                         ;//   2022/02/24  Release for DPA 4.17
           3088                         ;//   2021/08/20  Release for DPA 4.16
           3089                         ;//   2020/09/03  Release for DPA 4.15
           3090                         ;//   2020/04/03  Release for DPA 4.14
           3091                         ;//   2020/02/27  Release for DPA 4.13
           3092                         ;//   2020/01/09  Release for DPA 4.12
           3093                         ;//   2019/12/11  Release for DPA 4.11
           3094                         ;//   2019/10/09  Release for DPA 4.10
           3095                         ;//   2019/06/12  Release for DPA 4.03
           3096                         ;//   2019/06/03  Release for DPA 4.02
           3097                         ;//   2019/03/07  Release for DPA 4.01
           3098                         ;//   2019/01/10  Release for DPA 4.00
           3099                         ;//   2018/10/25  Release for DPA 3.03
           3100                         ;//   2017/11/16  Release for DPA 3.02
           3101                         ;//   2017/08/14  Release for DPA 3.01
           3102                         ;//   2017/03/13  Release for DPA 3.00
           3103                         ;//   2016/09/12  Release for DPA 2.28
           3104                         ;//   2016/04/14  Release for DPA 2.27
           3105                         ;//   2016/03/03  Release for DPA 2.26
           3106                         ;//   2016/01/21  Release for DPA 2.25
           3107                         ;//   2015/12/01  Release for DPA 2.24
           3108                         ;//   2015/10/23  Release for DPA 2.23
           3109                         ;//   2015/09/25  Release for DPA 2.22
           3110                         ;//   2015/09/03  Release for DPA 2.21
           3111                         ;//   2015/08/05  Release for DPA 2.20
           3112                         ;//   2014/10/31  Release for DPA 2.10
           3113                         ;//   2014/04/30  Release for DPA 2.00
           3114                         ;//   2013/10/03  Release for DPA 1.00
           3115                         ;//
           3116                         ;// *********************************************************************
           3117                         ;
           3118                         ;// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
           3119                         ;// IQRF Standards documentation https://doc.iqrf.org/
           3120                         ;
           3121                         ;#ifndef _CUSTOM_DPA_HANDLER_
           3122                         ;#define _CUSTOM_DPA_HANDLER_
           3123                         ;
           3124                         ;//############################################################################################
           3125                         ;// 1st include
           3126                         ;
           3127                         ;// Custom DPA Handler routine declaration
           3128                         ;bit CustomDpaHandler();
           3129                         ;
           3130                         ;// Various DPA flags shared between DPA and Custom DPA Handler
           3131                         ;uns8 DpaFlags @ usedBank4[0];
           3132                         ;
           3133                         ;// [C][N] TRUE if I2C timeout occurred at the last DpaApiI2C?() call
           3134                         ;bit I2CwasTimeout @ DpaFlags.0;
           3135                         ;// [N] Flag for the 1st DpaApiSleep
           3136                         ;bit FirstDpaApiSleep @ DpaFlags.1;
           3137                         ;
           3138                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           3139                         ;// [C] TRUE if interface master is not connected (detected)
           3140                         ;bit IFaceMasterNotConnected @ DpaFlags.2;
           3141                         ;#endif
           3142                         ;// [N] DPA by interface notification is sent also when there was a "reading" like DPA request
           3143                         ;bit EnableIFaceNotificationOnRead @ DpaFlags.3;
           3144                         ;// [N] TRUE when node was just bonded using default bonding procedure
           3145                         ;bit NodeWasBonded @ DpaFlags.4;
           3146                         ;// [N] When TRUE, then next call of DpaApiRfTxDpaPacket sends non-routed packet
           3147                         ;bit NonroutedRfTxDpaPacket @ DpaFlags.7;
           3148                         ;
           3149                         ;// [C] Ticks (decrementing) counter usable for timing in the coordinator's Customer DPA Handler
           3150                         ;uns16 DpaTicks @ usedBank4[1];
           3151                         ;// [N] toutRF for LP mode, read from configuration memory after reset
           3152                         ;uns8 LPtoutRF @ usedBank4[3];
           3153                         ;// DPA Request/Response HWPID
           3154                         ;uns16 _HWPID @ usedBank4[4];
           3155                         ;// Identifies type of reset (stored at UserReg0 upon module reset). See Reset chapter at IQRF User's Guide for more information
           3156                         ;uns8 ResetType @ usedBank4[6];
           3157                         ;// User DPA Values to return
           3158                         ;uns8 UserDpaValue @ usedBank4[7];
           3159                         ;// Network depth of the DPA request/response, increases on bridging, decreases on back-bridging
           3160                         ;uns8 NetDepth @ usedBank4[8];
           3161                         ;// TRUE when node was at DPA Service Mode after last boot
           3162                         ;bit DSMactivated @ usedBank4[9].0;
           3163                         ;// If set to TRUE, then LP RX mode in the main loop can be terminated by pin, see _RLPMAT
           3164                         ;bit LpRxPinTerminate @ usedBank4[9].1;
           3165                         ;// If set to TRUE, then [C] executes asynchronous DPA requests received from [N]
           3166                         ;bit AsyncReqAtCoordinator @ usedBank4[9].2;
           3167                         ;// RX filter used at the DPA main loop checkRF call
           3168                         ;uns8 RxFilter @ usedBank4[11];
           3169                         ;// Countdown variable for button bonding before going to deep sleep
           3170                         ;uns16 BondingSleepCountdown @ usedBank4[12];
           3171                         ;#define BONDING_SLEEP_COUNTDOWN_UNIT  290
           3172                         ;// Non-zero pseudo-random value, read-only, updated on every Reset and Idle event, at [N] only.
           3173                         ;uns16 Random @ usedBank4[14];
           3174                         ;// DPA value from the received packet or just to be sent to the interface.
           3175                         ;uns8 DpaValue @ usedBank4[16];
           3176                         ;// If non-zero then timeout value for DpaApiI2C?() calls
           3177                         ;uns8 I2Ctimeout @ usedBank4[17];
           3178                         ;
           3179                         ;// Macro to return an error from the peripheral handler. If the code size is not an issue this macro is the right choice.
           3180                         ;#define DpaApiReturnPeripheralError(error) do { \
           3181                         ;    DpaApiSetPeripheralError( error ); \
           3182                         ;    return Carry; \
           3183                         ;  } while( 0 )
           3184                         ;
           3185                         ;// DPA API functions, see documentation for details
           3186                         ;#define DpaApiRfTxDpaPacket( dpaValue, netDepthAndFlags ) DpaApiEntry( dpaValue, netDepthAndFlags, DPA_API_RFTX_DPAPACKET )
           3187                         ;#define DpaApiReadConfigByte( index )                     DpaApiEntry( index, param3.low8, DPA_API_READ_CONFIG_BYTE )
           3188                         ;#define DpaApiLocalRequest()                              DpaApiEntry( param2, param3.low8, DPA_API_LOCAL_REQUEST )
           3189                         ;#define DpaApiSetPeripheralError( error )                 DpaApiEntry( error, param3.low8, DPA_API_SET_PERIPHERAL_ERROR )
           3190                         ;#define DpaApiSendToIFaceMaster( dpaValue, flags )        DpaApiEntry( dpaValue, flags, DPA_API_SEND_TO_IFACEMASTER )
           3191                         ;#define DpaApiSetRfDefaults()                             DpaApiEntry( param2, param3.low8, DPA_API_SET_RF_DEFAULTS )
           3192                         ;#define DpaApiLocalFrc( frcCommand, replyTxPower )        DpaApiEntry( frcCommand, replyTxPower, DPA_API_LOCAL_FRC )
           3193                         ;#define DpaApiCrc8( crc8, data )                          DpaApiEntry( crc8, data, DPA_API_CRC8 )
           3194                         ;#define DpaApiAggregateFrc()                              DpaApiEntry( param2, param3.low8, DPA_API_AGGREGATE_FRC )
           3195                         ;#define DpaApiSetOTK()                                    DpaApiEntry( param2, param3.low8, DPA_API_SET_OTK )
           3196                         ;#define DpaApiI2Cinit( frequency )                        DpaApiEntry( frequency, param3.low8, DPA_API_I2C_INIT )
           3197                         ;#define DpaApiI2Cstart( address )                         DpaApiEntry( address, param3.low8, DPA_API_I2C_START )
           3198                         ;#define DpaApiI2Cwrite( data )                            DpaApiEntry( data, param3.low8, DPA_API_I2C_WRITE )
           3199                         ;#define DpaApiI2Cread( ack )                              DpaApiEntry( ack, param3.low8, DPA_API_I2C_READ )
           3200                         ;#define DpaApiI2Cstop()                                   DpaApiEntry( param2, param3.low8, DPA_API_I2C_STOP )
           3201                         ;#define DpaApiI2CwaitForACK( address )                    DpaApiEntry( address, param3.low8, DPA_API_I2C_WAIT_FOR_ACK )
           3202                         ;#define DpaApiI2Cshutdown()                               DpaApiEntry( param2, param3.low8, DPA_API_I2C_SHUTDOWN )
           3203                         ;#define DpaApiI2CwaitForIdle()                            DpaApiEntry( param2, param3.low8, DPA_API_I2C_WAIT_FOR_IDLE )
           3204                         ;#define DpaApiSleep( wdtcon )                             DpaApiEntry( wdtcon, param3.low8, DPA_API_SLEEP )
           3205                         ;#define DpaApiAfterSleep()                                DpaApiEntry( param2, param3.low8, DPA_API_AFTER_SLEEP )
           3206                         ;#define DpaApiRandom()                                    DpaApiEntry( param2, param3.low8, DPA_API_RANDOM )
           3207                         ;
           3208                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           3209                         ;#define DpaApiRfTxDpaPacketCoordinator()                  DpaApiEntry( param2, param3.low8, DPA_API_COORDINATOR_RFTX_DPAPACKET )
           3210                         ;#endif
           3211                         ;
           3212                         ;#if !defined( TR7xD )
           3213                         ;#define DpaApiMenu( menu, flags )                         DpaApiEntry( menu, flags, DPA_API_MENU )
           3214                         ;#define DpaApiMenuIndicateResult( ok )                    DpaApiEntry( ok, param3.low8, DPA_API_MENU_INDICATE_RESULT )
           3215                         ;#define DpaApiMenuExecute( menuAndItem )                  DpaApiEntry( menuAndItem, param3.low8, DPA_API_MENU_EXECUTE )
           3216                         ;#define DpaApiDeepSleep( wdtcon )                         DpaApiEntry( wdtcon, param3.low8, DPA_API_DEEP_SLEEP )
           3217                         ;#endif
           3218                         ;
           3219                         ;#define DpaApiLocalFrc_StackSaver( frcCommand, replyTxPower ) \
           3220                         ;  param2 = frcCommand; \
           3221                         ;  param3.low8 = replyTxPower; \
           3222                         ;  W = DPA_API_LOCAL_FRC; \
           3223                         ;  #asm \
           3224                         ;    DW  __MOVLP( DPA_API_ADDRESS >> 8 ); \
           3225                         ;    DW  __CALL( DPA_API_ADDRESS ); \
           3226                         ;    DW  __MOVLP( CUSTOM_HANDLER_ADDRESS >> 8 ); \
           3227                         ;  #endasm \
           3228                         ;
           3229                         ;#define I2CcomputeFrequency( I2Cfrequency)                ( ( ( F_OSC ) / ( ( I2Cfrequency ) * 4 ) ) - 1 )
           3230                         ;
           3231                         ;// Wrapper routines to be called instead of DpaApi??? macros to decrease code size if more than ~2 calls are needed
           3232                         ;void _DpaApiI2Cinit( uns8 frequency );
           3233                         ;void _DpaApiI2Cstart( uns8 address );
           3234                         ;void _DpaApiI2Cwrite( uns8 data );
           3235                         ;uns8 _DpaApiI2Cread( uns8 ack );
           3236                         ;void _DpaApiI2Cstop();
           3237                         ;void _DpaApiI2CwaitForACK( uns8 address );
           3238                         ;void _DpaApiI2Cshutdown();
           3239                         ;void _DpaApiI2CwaitForIdle();
           3240                         ;void _DpaApiSleep( uns8 wdtcon );
           3241                         ;#if !defined( TR7xD )
           3242                         ;void _DpaApiDeepSleep( uns8 wdtcon );
           3243                         ;#endif
           3244                         ;void _DpaApiSleepFirst( uns8 wdtcon );
           3245                         ;void _DpaApiAfterSleep();
           3246                         ;uns8 _DpaApiRandom();
           3247                         ;void _DpaApiSetRfDefaults();
           3248                         ;
           3249                         ;// Helper "multi" function to decrease code size if used more times
           3250                         ;void _DpaApiI2Cwrite0();
           3251                         ;void _DpaApiI2CwriteAndStop( uns8 data );
           3252                         ;uns8 _DpaApiI2CreadACK();
           3253                         ;uns8 _DpaApiI2CreadNACK();
           3254                         ;uns8 _DpaApiI2CreadNACKandStop();
           3255                         ;
           3256                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           3257                         ;#undef  DpaEvent_Interrupt
           3258                         ;#undef  DpaEvent_BeforeSleep
           3259                         ;#undef  DpaEvent_AfterSleep
           3260                         ;#undef  DpaEvent_FrcValue
           3261                         ;#undef  DpaEvent_FrcResponseTime
           3262                         ;#else
           3263                         ;#undef  DpaEvent_ReceiveDpaResponse
           3264                         ;#undef  DpaEvent_IFaceReceive
           3265                         ;#endif
           3266                         ;
           3267                         ;// To detect overlapping code in case someone would put some code before this header by mistake
           3268                         ;#pragma origin __APPLICATION_ADDRESS
     0000  3269         ORG 0x3A00
           3270                         ;#pragma updateBank 0
           3271                         ;
           3272                         ;//############################################################################################
           3273                         ;// Main IQRF entry point jumps to the main DPA entry point
           3274                         ;void APPLICATION()
           3275                         ;//############################################################################################
           3276                         ;{
           3277 APPLICATION
           3278                         ;  #asm
           3279                         ;    DW  __MOVLP( MAIN_DPA_ADDRESS >> 8 );
3A00 31AC  3280         DW    0x31AC
           3281                         ;  DW  __GOTO( MAIN_DPA_ADDRESS );
3A01 2C04  3282         DW    0x2C04
           3283                         ;  #endasm
           3284                         ;
           3285                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           3286                         ;    // Fake call to force CustomDpaHandler() compilation
           3287                         ;    CustomDpaHandler();
3A02 2220  3288         CALL  CustomDpaHandler
           3289                         ;#endif
           3290                         ;
           3291                         ;  // Fake call to force DpaApiEntry() compilation
           3292                         ;  DpaApiEntry( param2, param3.low8, W );
3A03 2A08  3293         GOTO  DpaApiEntry
           3294                         ;}
           3295                         ;
           3296                         ;//############################################################################################
           3297                         ;// Entry stub to the real DPA API entry
           3298                         ;#pragma origin DPA_API_ADDRESS_ENTRY
     0000  3299         ORG 0x3A08
           3300                         ;uns8  DpaApiEntry( uns8 par1 @ param2, uns8 par2 @ param3.low8, uns8 apiIndex @ W )
           3301                         ;//############################################################################################
           3302                         ;{
           3303 DpaApiEntry
           3304                         ;  #asm
           3305                         ;    DW  __MOVLP( DPA_API_ADDRESS >> 8 );
3A08 31AC  3306         DW    0x31AC
           3307                         ;  DW  __CALL( DPA_API_ADDRESS );
3A09 2400  3308         DW    0x2400
           3309                         ;  DW  __MOVLP( DPA_API_ADDRESS_ENTRY >> 8 );
3A0A 31BA  3310         DW    0x31BA
           3311                         ;  #endasm
           3312                         ;
           3313                         ;    return W;
3A0B 0008  3314         RETURN
           3315                         ;}
           3316                         ;
           3317                         ;//############################################################################################
           3318                         ;#pragma origin DPA_API_ADDRESS_ENTRY + 0x08
     0000  3319         ORG 0x3A10
           3320                         ;
           3321                         ;//############################################################################################
           3322                         ;
           3323                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           3324                         ;// Next comes Custom DPA handler routine
           3325                         ;#pragma origin CUSTOM_HANDLER_ADDRESS
     0000  3326         ORG 0x3A20
           3327                         ;#endif
           3328                         ;
           3329                         ;#pragma updateBank 1
           3330 
           3331   ; FILE C:\customdpa\CustomDpaHandlerExample\CustomDpaHandler-UserPeripheral-ADC.c
           3332                         ;// **************************************************************************
           3333                         ;//   Custom DPA Handler code example - User peripheral implementation - ADC *
           3334                         ;// **************************************************************************
           3335                         ;// Copyright (c) MICRORISC s.r.o.
           3336                         ;//
           3337                         ;// File:    $RCSfile: CustomDpaHandler-UserPeripheral-ADC.c,v $
           3338                         ;// Version: $Revision: 1.36 $
           3339                         ;// Date:    $Date: 2022/02/25 09:41:25 $
           3340                         ;//
           3341                         ;// Revision history:
           3342                         ;//   2022/02/24  Release for DPA 4.17
           3343                         ;//   2017/03/13  Release for DPA 3.00
           3344                         ;//   2015/08/05  Release for DPA 2.20
           3345                         ;//   2014/10/31  Release for DPA 2.10
           3346                         ;//   2014/04/30  Release for DPA 2.00
           3347                         ;//
           3348                         ;// *********************************************************************
           3349                         ;
           3350                         ;// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
           3351                         ;
           3352                         ;// This example implements the user peripherals ADC
           3353                         ;// PNUM = 0x20 and PCMD = 0 returns 2 bytes with 10b ADC result from pin C5 at PData
           3354                         ;// PNUM = 0x21 and PCMD = 0 returns 2 bytes with 10b ADC result from pin C1 at PData
           3355                         ;// Works with TR-72 having connected pins RA.5, RC.6 and RB.4
           3356                         ;// At DDC-SE-01 allows to read:
           3357                         ;// * Light intensity measurement using a photoresistor
           3358                         ;// * Voltage measurement using a potentiometer
           3359                         ;
           3360                         ;// Default IQRF include (modify the path according to your setup)
           3361                         ;#include "..\Include\IQRF.h"
           3362                         ;
           3363                         ;// Default DPA header (modify the path according to your setup)
           3364                         ;#include "..\Include\DPA.h"
           3365                         ;// Default Custom DPA Handler header (modify the path according to your setup)
           3366                         ;#include "..\Include\DPAcustomHandler.h"
           3367                         ;
           3368                         ;// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
           3369                         ;//############################################################################################
           3370                         ;bit CustomDpaHandler()
           3371                         ;//############################################################################################
           3372                         ;{
           3373 CustomDpaHandler
           3374                         ;  // Handler presence mark
           3375                         ;  clrwdt();
3A20 0064  3376         CLRWDT
           3377                         ;
           3378                         ;  // Detect DPA event to handle
           3379                         ;  switch ( GetDpaEvent() )
3A21 0870  3380         MOVF  userReg0,W
3A22 3A01  3381         XORLW 0x01
3A23 1903  3382         BTFSC 0x03,Zero_
3A24 3207  3383         BRA   m001
3A25 3A02  3384         XORLW 0x02
3A26 1903  3385         BTFSC 0x03,Zero_
3A27 3206  3386         BRA   m002
3A28 3A03  3387         XORLW 0x03
3A29 1903  3388         BTFSC 0x03,Zero_
3A2A 3209  3389         BRA   m003
3A2B 3285  3390         BRA   m014
           3391                         ;  {
           3392                         ;    // -------------------------------------------------
           3393                         ;    case DpaEvent_Interrupt:
           3394                         ;      // Do an extra quick background interrupt work
           3395                         ;      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
           3396                         ;      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
           3397                         ;      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the empty return handler ensures the shortest possible interrupt routine response time.
           3398                         ;      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
           3399                         ;      // ! Make sure race condition does not occur when accessing those variables at other places.
           3400                         ;      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
           3401                         ;      // ! Do not call any OS functions except setINDFx().
           3402                         ;      // ! Do not use any OS variables especially for writing access.
           3403                         ;      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.
           3404                         ;
           3405                         ;DpaHandleReturnTRUE:
           3406                         ;      return TRUE;
3A2C 1403  3407 m001    BSF   0x03,Carry
3A2D 0008  3408         RETURN
           3409                         ;
           3410                         ;      // -------------------------------------------------
           3411                         ;    case DpaEvent_Init:
           3412                         ;      // Do a one time initialization before main loop starts
           3413                         ;
           3414                         ;      // C5 as input
           3415                         ;      TRISA.5 = 1;
3A2E 0140  3416 m002    MOVLB 0x00
3A2F 1691  3417         BSF   TRISA,5
           3418                         ;      TRISC.6 = 1;
3A30 1713  3419         BSF   TRISC,6
           3420                         ;      TRISB.4 = 1;
3A31 1612  3421         BSF   TRISB,4
           3422                         ;      // C1 as input
           3423                         ;      TRISA.0 = 1;
3A32 1411  3424         BSF   TRISA,0
           3425                         ;
           3426                         ;      break;
3A33 327D  3427         BRA   m014
           3428                         ;
           3429                         ;      // -------------------------------------------------
           3430                         ;    case DpaEvent_DpaRequest:
           3431                         ;      // Called to interpret DPA request for peripherals
           3432                         ;      // -------------------------------------------------
           3433                         ;      // Peripheral enumeration
           3434                         ;      if ( IsDpaEnumPeripheralsRequest() )
3A34 0145  3435 m003    MOVLB 0x05
3A35 0F2E  3436         INCFSZ PNUM,W
3A36 3212  3437         BRA   m004
3A37 082F  3438         MOVF  PCMD,W
3A38 3A3F  3439         XORLW 0x3F
3A39 1D03  3440         BTFSS 0x03,Zero_
3A3A 320E  3441         BRA   m004
3A3B 08A1  3442         MOVF  DLEN,1
3A3C 1D03  3443         BTFSS 0x03,Zero_
3A3D 320B  3444         BRA   m004
           3445                         ;      {
           3446                         ;        // We implement 1 user peripheral
           3447                         ;        _DpaMessage.EnumPeripheralsAnswer.UserPerNr |= 2;
3A3E 0149  3448         MOVLB 0x09
3A3F 14A2  3449         BSF   DpaRfMessage+2,1
           3450                         ;        FlagUserPer( _DpaMessage.EnumPeripheralsAnswer.UserPer, PNUM_USER + 0 );
3A40 142C  3451         BSF   DpaRfMessage+12,0
           3452                         ;        FlagUserPer( _DpaMessage.EnumPeripheralsAnswer.UserPer, PNUM_USER + 1 );
3A41 14AC  3453         BSF   DpaRfMessage+12,1
           3454                         ;        _DpaMessage.EnumPeripheralsAnswer.HWPID |= 0x000F;
3A42 300F  3455         MOVLW 0x0F
3A43 04A7  3456         IORWF DpaRfMessage+7,1
           3457                         ;        _DpaMessage.EnumPeripheralsAnswer.HWPIDver |= 0xabcd;
3A44 30AB  3458         MOVLW 0xAB
3A45 04AA  3459         IORWF DpaRfMessage+10,1
3A46 30CD  3460         MOVLW 0xCD
3A47 04A9  3461         IORWF DpaRfMessage+9,1
           3462                         ;
           3463                         ;        goto DpaHandleReturnTRUE;
3A48 33E3  3464         BRA   m001
           3465                         ;      }
           3466                         ;      // -------------------------------------------------
           3467                         ;      // Get information about peripheral
           3468                         ;      else if ( IsDpaPeripheralInfoRequest() )
3A49 0145  3469 m004    MOVLB 0x05
3A4A 0A2E  3470         INCF  PNUM,W
3A4B 1903  3471         BTFSC 0x03,Zero_
3A4C 3215  3472         BRA   m006
3A4D 082F  3473         MOVF  PCMD,W
3A4E 3A3F  3474         XORLW 0x3F
3A4F 1D03  3475         BTFSS 0x03,Zero_
3A50 3211  3476         BRA   m006
3A51 08A1  3477         MOVF  DLEN,1
3A52 1D03  3478         BTFSS 0x03,Zero_
3A53 320E  3479         BRA   m006
           3480                         ;      {
           3481                         ;        if ( _PNUM == PNUM_USER + 0 || _PNUM == PNUM_USER + 1 )
3A54 082E  3482         MOVF  PNUM,W
3A55 3A20  3483         XORLW 0x20
3A56 1903  3484         BTFSC 0x03,Zero_
3A57 3204  3485         BRA   m005
3A58 082E  3486         MOVF  PNUM,W
3A59 3A21  3487         XORLW 0x21
3A5A 1D03  3488         BTFSS 0x03,Zero_
3A5B 3255  3489         BRA   m014
           3490                         ;        {
           3491                         ;          _DpaMessage.PeripheralInfoAnswer.PerT = PERIPHERAL_TYPE_ADC;
3A5C 300C  3492 m005    MOVLW 0x0C
3A5D 0149  3493         MOVLB 0x09
3A5E 00A1  3494         MOVWF DpaRfMessage+1
           3495                         ;          _DpaMessage.PeripheralInfoAnswer.PerTE = PERIPHERAL_TYPE_EXTENDED_READ;
3A5F 3001  3496         MOVLW 0x01
3A60 00A0  3497         MOVWF DpaRfMessage
           3498                         ;          goto DpaHandleReturnTRUE;
3A61 33CA  3499         BRA   m001
           3500                         ;        }
           3501                         ;
           3502                         ;        break;
           3503                         ;      }
           3504                         ;      // -------------------------------------------------
           3505                         ;      else
           3506                         ;      {
           3507                         ;        // Handle peripheral command
           3508                         ;        if ( _PNUM == PNUM_USER + 0 || _PNUM == PNUM_USER + 1 )
3A62 0145  3509 m006    MOVLB 0x05
3A63 082E  3510         MOVF  PNUM,W
3A64 3A20  3511         XORLW 0x20
3A65 1903  3512         BTFSC 0x03,Zero_
3A66 3204  3513         BRA   m007
3A67 082E  3514         MOVF  PNUM,W
3A68 3A21  3515         XORLW 0x21
3A69 1D03  3516         BTFSS 0x03,Zero_
3A6A 3246  3517         BRA   m014
           3518                         ;        {
           3519                         ;          // Check command
           3520                         ;          if ( _PCMD != 0 )
3A6B 0145  3521 m007    MOVLB 0x05
3A6C 08AF  3522         MOVF  PCMD,1
3A6D 1903  3523         BTFSC 0x03,Zero_
3A6E 3204  3524         BRA   m008
           3525                         ;            DpaApiReturnPeripheralError( ERROR_PCMD );
3A6F 3002  3526         MOVLW 0x02
3A70 00F3  3527         MOVWF par1
3A71 3005  3528         MOVLW 0x05
3A72 2A08  3529         GOTO  DpaApiEntry
           3530                         ;
           3531                         ;          // Check data length
           3532                         ;          if ( _DpaDataLength != 0 )
3A73 0145  3533 m008    MOVLB 0x05
3A74 08A1  3534         MOVF  DLEN,1
3A75 1903  3535         BTFSC 0x03,Zero_
3A76 3204  3536         BRA   m009
           3537                         ;            DpaApiReturnPeripheralError( ERROR_DATA_LEN );
3A77 3005  3538         MOVLW 0x05
3A78 00F3  3539         MOVWF par1
3A79 3005  3540         MOVLW 0x05
3A7A 2A08  3541         GOTO  DpaApiEntry
           3542                         ;
           3543                         ;#if defined( TR7xG )
           3544                         ;          // Enable ADC
           3545                         ;          ADCMD = 0;
3A7B 014F  3546 m009    MOVLB 0x0F
3A7C 1298  3547         BCF   0x798,ADCMD
           3548                         ;
           3549                         ;          // Might not be needed if ADC registers are kept default
           3550                         ;          {
           3551                         ;            // Start reseting ADC registers from ADCON0 to ADPCH
           3552                         ;            // VREF- is connected to AVSS, VREF+ is connected to VDD
           3553                         ;            FSR0 = &ADCON0;
3A7D 3093  3554         MOVLW 0x93
3A7E 0084  3555         MOVWF FSR0
3A7F 0185  3556         CLRF  FSR0+1
           3557                         ;            do
           3558                         ;            {
           3559                         ;              setINDF0( 0 );
3A80 3000  3560 m010    MOVLW 0x00
3A81 2131  3561         CALL  setINDF0
           3562                         ;              FSR0++;
3A82 3101  3563         ADDFSR INDF0,1
           3564                         ;              // Stop reseting at 1st GPR register, ADPCH is the last implemented register before GPR
           3565                         ;            } while ( !FSR0L.5 );
3A83 1E84  3566         BTFSS FSR0L,5
3A84 33FB  3567         BRA   m010
           3568                         ;          }
           3569                         ;#endif
           3570                         ;
           3571                         ;          if ( _PNUM == PNUM_USER + 0 )
3A85 0145  3572         MOVLB 0x05
3A86 082E  3573         MOVF  PNUM,W
3A87 3A20  3574         XORLW 0x20
3A88 1D03  3575         BTFSS 0x03,Zero_
3A89 3208  3576         BRA   m011
           3577                         ;          {
           3578                         ;#if defined( TR7xG )
           3579                         ;            //  ADC Positive Input Channel = ANA5
           3580                         ;            setADPCH( 0x05 );
3A8A 309E  3581         MOVLW 0x9E
3A8B 0084  3582         MOVWF FSR0
3A8C 0185  3583         CLRF  FSR0+1
3A8D 3005  3584         MOVLW 0x05
3A8E 2131  3585         CALL  setINDF0
           3586                         ;#else
           3587                         ;            // ADC setting (AN4 channel)
           3588                         ;            ADCON0 = 0b0.00100.01;
           3589                         ;#endif
           3590                         ;            // ADC initialization (for more info see PIC datasheet) pin C5 (AN4-D/ANA5-G) as analog input
           3591                         ;            ANSELA.5 = 1;
3A8F 017E  3592         MOVLB 0x3E
3A90 16B8  3593         BSF   ANSELA,5
           3594                         ;          }
           3595                         ;          else
3A91 3207  3596         BRA   m012
           3597                         ;          {
           3598                         ;#if defined( TR7xG )
           3599                         ;            //  ADC Positive Input Channel = ANA0
           3600                         ;            setADPCH( 0x00 );
3A92 309E  3601 m011    MOVLW 0x9E
3A93 0084  3602         MOVWF FSR0
3A94 0185  3603         CLRF  FSR0+1
3A95 3000  3604         MOVLW 0x00
3A96 2131  3605         CALL  setINDF0
           3606                         ;#else
           3607                         ;            // ADC setting (AN0 channel)
           3608                         ;            ADCON0 = 0b0.00000.01;
           3609                         ;#endif
           3610                         ;            // ADC initialization (for more info see PIC datasheet) pin C1 (AN0-D/ANA0-G) as analog input
           3611                         ;            ANSELA.0 = 1;
3A97 017E  3612         MOVLB 0x3E
3A98 1438  3613         BSF   ANSELA,0
           3614                         ;          }
           3615                         ;
           3616                         ;#if defined( TR7xG )
           3617                         ;          // ADC is enabled, ADGO is cleared upon completion, Clock supplied according to ADCLK register, right-justified
           3618                         ;          ADCON0 = 0b1000.0100;
3A99 3084  3619 m012    MOVLW 0x84
3A9A 0141  3620         MOVLB 0x01
3A9B 0093  3621         MOVWF ADCON0
           3622                         ;          // ADC Conversion Clock = FOSC/8
           3623                         ;          ADCLK = 8 / 2 - 1;
3A9C 3003  3624         MOVLW 0x03
3A9D 0098  3625         MOVWF ADCLK
           3626                         ;#else
           3627                         ;          // ADC result - right justified, Fosc/8
           3628                         ;          ADCON1 = 0b1001.0000;
           3629                         ;#endif
           3630                         ;
           3631                         ;          // Short delay to stabilize
           3632                         ;          updateCRC16( W );
3A9E 2173  3633         CALL  updateCRC16
           3634                         ;          // start ADC
           3635                         ;          _GO = 1;
3A9F 0141  3636         MOVLB 0x01
3AA0 1413  3637         BSF   0x93,ADGO
           3638                         ;          // wait for ADC finish
           3639                         ;          while ( _GO );
3AA1 0141  3640 m013    MOVLB 0x01
3AA2 1813  3641         BTFSC 0x93,ADGO
3AA3 33FD  3642         BRA   m013
           3643                         ;
           3644                         ;          // 10b result is stored in ADRESH and ADRESL
           3645                         ;          _DpaMessage.Response.PData[0] = ADRESL;
3AA4 0141  3646         MOVLB 0x01
3AA5 080C  3647         MOVF  ADRESL,W
3AA6 0149  3648         MOVLB 0x09
3AA7 00A0  3649         MOVWF DpaRfMessage
           3650                         ;          _DpaMessage.Response.PData[1] = ADRESH & 0x03;
3AA8 3003  3651         MOVLW 0x03
3AA9 0141  3652         MOVLB 0x01
3AAA 050D  3653         ANDWF ADRESH,W
3AAB 0149  3654         MOVLB 0x09
3AAC 00A1  3655         MOVWF DpaRfMessage+1
           3656                         ;          _DpaDataLength = sizeof( uns16 );
3AAD 3002  3657         MOVLW 0x02
3AAE 0145  3658         MOVLB 0x05
3AAF 00A1  3659         MOVWF DLEN
           3660                         ;
           3661                         ;          goto DpaHandleReturnTRUE;
3AB0 337B  3662         BRA   m001
           3663                         ;        }
           3664                         ;      }
           3665                         ;  }
           3666                         ;
           3667                         ;  return FALSE;
3AB1 1003  3668 m014    BCF   0x03,Carry
3AB2 0008  3669         RETURN
           3670 
           3671   ; FILE C:\customdpa\CustomDpaHandlerExample\..\Include\DPAcustomHandler.h
           3672                         ;// *********************************************************************
           3673                         ;//   Main Custom DPA Handler header                                    *
           3674                         ;// *********************************************************************
           3675                         ;// Copyright (c) MICRORISC s.r.o.
           3676                         ;//
           3677                         ;// File:    $RCSfile: DPAcustomHandler.h,v $
           3678                         ;// Version: $Revision: 1.167 $
           3679                         ;// Date:    $Date: 2024/12/05 09:28:58 $
           3680                         ;//
           3681                         ;// Revision history:
           3682                         ;//   2024/11/05  Release for DPA 4.32
           3683                         ;//   2024/04/17  Release for DPA 4.31
           3684                         ;//   2023/03/07  Release for DPA 4.30
           3685                         ;//   2022/10/05  Release for DPA 4.18
           3686                         ;//   2022/02/24  Release for DPA 4.17
           3687                         ;//   2021/08/20  Release for DPA 4.16
           3688                         ;//   2020/09/03  Release for DPA 4.15
           3689                         ;//   2020/04/03  Release for DPA 4.14
           3690                         ;//   2020/02/27  Release for DPA 4.13
           3691                         ;//   2020/01/09  Release for DPA 4.12
           3692                         ;//   2019/12/11  Release for DPA 4.11
           3693                         ;//   2019/10/09  Release for DPA 4.10
           3694                         ;//   2019/06/12  Release for DPA 4.03
           3695                         ;//   2019/06/03  Release for DPA 4.02
           3696                         ;//   2019/03/07  Release for DPA 4.01
           3697                         ;//   2019/01/10  Release for DPA 4.00
           3698                         ;//   2018/10/25  Release for DPA 3.03
           3699                         ;//   2017/11/16  Release for DPA 3.02
           3700                         ;//   2017/08/14  Release for DPA 3.01
           3701                         ;//   2017/03/13  Release for DPA 3.00
           3702                         ;//   2016/09/12  Release for DPA 2.28
           3703                         ;//   2016/04/14  Release for DPA 2.27
           3704                         ;//   2016/03/03  Release for DPA 2.26
           3705                         ;//   2016/01/21  Release for DPA 2.25
           3706                         ;//   2015/12/01  Release for DPA 2.24
           3707                         ;//   2015/10/23  Release for DPA 2.23
           3708                         ;//   2015/09/25  Release for DPA 2.22
           3709                         ;//   2015/09/03  Release for DPA 2.21
           3710                         ;//   2015/08/05  Release for DPA 2.20
           3711                         ;//   2014/10/31  Release for DPA 2.10
           3712                         ;//   2014/04/30  Release for DPA 2.00
           3713                         ;//   2013/10/03  Release for DPA 1.00
           3714                         ;//
           3715                         ;// *********************************************************************
           3716                         ;
           3717                         ;// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
           3718                         ;// IQRF Standards documentation https://doc.iqrf.org/
           3719                         ;
           3720                         ;#ifndef _CUSTOM_DPA_HANDLER_
           3721                         ;#define _CUSTOM_DPA_HANDLER_
           3722                         ;
           3723                         ;//############################################################################################
           3724                         ;// 1st include
           3725                         ;
           3726                         ;// Custom DPA Handler routine declaration
           3727                         ;bit CustomDpaHandler();
           3728                         ;
           3729                         ;// Various DPA flags shared between DPA and Custom DPA Handler
           3730                         ;uns8 DpaFlags @ usedBank4[0];
           3731                         ;
           3732                         ;// [C][N] TRUE if I2C timeout occurred at the last DpaApiI2C?() call
           3733                         ;bit I2CwasTimeout @ DpaFlags.0;
           3734                         ;// [N] Flag for the 1st DpaApiSleep
           3735                         ;bit FirstDpaApiSleep @ DpaFlags.1;
           3736                         ;
           3737                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           3738                         ;// [C] TRUE if interface master is not connected (detected)
           3739                         ;bit IFaceMasterNotConnected @ DpaFlags.2;
           3740                         ;#endif
           3741                         ;// [N] DPA by interface notification is sent also when there was a "reading" like DPA request
           3742                         ;bit EnableIFaceNotificationOnRead @ DpaFlags.3;
           3743                         ;// [N] TRUE when node was just bonded using default bonding procedure
           3744                         ;bit NodeWasBonded @ DpaFlags.4;
           3745                         ;// [N] When TRUE, then next call of DpaApiRfTxDpaPacket sends non-routed packet
           3746                         ;bit NonroutedRfTxDpaPacket @ DpaFlags.7;
           3747                         ;
           3748                         ;// [C] Ticks (decrementing) counter usable for timing in the coordinator's Customer DPA Handler
           3749                         ;uns16 DpaTicks @ usedBank4[1];
           3750                         ;// [N] toutRF for LP mode, read from configuration memory after reset
           3751                         ;uns8 LPtoutRF @ usedBank4[3];
           3752                         ;// DPA Request/Response HWPID
           3753                         ;uns16 _HWPID @ usedBank4[4];
           3754                         ;// Identifies type of reset (stored at UserReg0 upon module reset). See Reset chapter at IQRF User's Guide for more information
           3755                         ;uns8 ResetType @ usedBank4[6];
           3756                         ;// User DPA Values to return
           3757                         ;uns8 UserDpaValue @ usedBank4[7];
           3758                         ;// Network depth of the DPA request/response, increases on bridging, decreases on back-bridging
           3759                         ;uns8 NetDepth @ usedBank4[8];
           3760                         ;// TRUE when node was at DPA Service Mode after last boot
           3761                         ;bit DSMactivated @ usedBank4[9].0;
           3762                         ;// If set to TRUE, then LP RX mode in the main loop can be terminated by pin, see _RLPMAT
           3763                         ;bit LpRxPinTerminate @ usedBank4[9].1;
           3764                         ;// If set to TRUE, then [C] executes asynchronous DPA requests received from [N]
           3765                         ;bit AsyncReqAtCoordinator @ usedBank4[9].2;
           3766                         ;// RX filter used at the DPA main loop checkRF call
           3767                         ;uns8 RxFilter @ usedBank4[11];
           3768                         ;// Countdown variable for button bonding before going to deep sleep
           3769                         ;uns16 BondingSleepCountdown @ usedBank4[12];
           3770                         ;#define BONDING_SLEEP_COUNTDOWN_UNIT  290
           3771                         ;// Non-zero pseudo-random value, read-only, updated on every Reset and Idle event, at [N] only.
           3772                         ;uns16 Random @ usedBank4[14];
           3773                         ;// DPA value from the received packet or just to be sent to the interface.
           3774                         ;uns8 DpaValue @ usedBank4[16];
           3775                         ;// If non-zero then timeout value for DpaApiI2C?() calls
           3776                         ;uns8 I2Ctimeout @ usedBank4[17];
           3777                         ;
           3778                         ;// Macro to return an error from the peripheral handler. If the code size is not an issue this macro is the right choice.
           3779                         ;#define DpaApiReturnPeripheralError(error) do { \
           3780                         ;    DpaApiSetPeripheralError( error ); \
           3781                         ;    return Carry; \
           3782                         ;  } while( 0 )
           3783                         ;
           3784                         ;// DPA API functions, see documentation for details
           3785                         ;#define DpaApiRfTxDpaPacket( dpaValue, netDepthAndFlags ) DpaApiEntry( dpaValue, netDepthAndFlags, DPA_API_RFTX_DPAPACKET )
           3786                         ;#define DpaApiReadConfigByte( index )                     DpaApiEntry( index, param3.low8, DPA_API_READ_CONFIG_BYTE )
           3787                         ;#define DpaApiLocalRequest()                              DpaApiEntry( param2, param3.low8, DPA_API_LOCAL_REQUEST )
           3788                         ;#define DpaApiSetPeripheralError( error )                 DpaApiEntry( error, param3.low8, DPA_API_SET_PERIPHERAL_ERROR )
           3789                         ;#define DpaApiSendToIFaceMaster( dpaValue, flags )        DpaApiEntry( dpaValue, flags, DPA_API_SEND_TO_IFACEMASTER )
           3790                         ;#define DpaApiSetRfDefaults()                             DpaApiEntry( param2, param3.low8, DPA_API_SET_RF_DEFAULTS )
           3791                         ;#define DpaApiLocalFrc( frcCommand, replyTxPower )        DpaApiEntry( frcCommand, replyTxPower, DPA_API_LOCAL_FRC )
           3792                         ;#define DpaApiCrc8( crc8, data )                          DpaApiEntry( crc8, data, DPA_API_CRC8 )
           3793                         ;#define DpaApiAggregateFrc()                              DpaApiEntry( param2, param3.low8, DPA_API_AGGREGATE_FRC )
           3794                         ;#define DpaApiSetOTK()                                    DpaApiEntry( param2, param3.low8, DPA_API_SET_OTK )
           3795                         ;#define DpaApiI2Cinit( frequency )                        DpaApiEntry( frequency, param3.low8, DPA_API_I2C_INIT )
           3796                         ;#define DpaApiI2Cstart( address )                         DpaApiEntry( address, param3.low8, DPA_API_I2C_START )
           3797                         ;#define DpaApiI2Cwrite( data )                            DpaApiEntry( data, param3.low8, DPA_API_I2C_WRITE )
           3798                         ;#define DpaApiI2Cread( ack )                              DpaApiEntry( ack, param3.low8, DPA_API_I2C_READ )
           3799                         ;#define DpaApiI2Cstop()                                   DpaApiEntry( param2, param3.low8, DPA_API_I2C_STOP )
           3800                         ;#define DpaApiI2CwaitForACK( address )                    DpaApiEntry( address, param3.low8, DPA_API_I2C_WAIT_FOR_ACK )
           3801                         ;#define DpaApiI2Cshutdown()                               DpaApiEntry( param2, param3.low8, DPA_API_I2C_SHUTDOWN )
           3802                         ;#define DpaApiI2CwaitForIdle()                            DpaApiEntry( param2, param3.low8, DPA_API_I2C_WAIT_FOR_IDLE )
           3803                         ;#define DpaApiSleep( wdtcon )                             DpaApiEntry( wdtcon, param3.low8, DPA_API_SLEEP )
           3804                         ;#define DpaApiAfterSleep()                                DpaApiEntry( param2, param3.low8, DPA_API_AFTER_SLEEP )
           3805                         ;#define DpaApiRandom()                                    DpaApiEntry( param2, param3.low8, DPA_API_RANDOM )
           3806                         ;
           3807                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           3808                         ;#define DpaApiRfTxDpaPacketCoordinator()                  DpaApiEntry( param2, param3.low8, DPA_API_COORDINATOR_RFTX_DPAPACKET )
           3809                         ;#endif
           3810                         ;
           3811                         ;#if !defined( TR7xD )
           3812                         ;#define DpaApiMenu( menu, flags )                         DpaApiEntry( menu, flags, DPA_API_MENU )
           3813                         ;#define DpaApiMenuIndicateResult( ok )                    DpaApiEntry( ok, param3.low8, DPA_API_MENU_INDICATE_RESULT )
           3814                         ;#define DpaApiMenuExecute( menuAndItem )                  DpaApiEntry( menuAndItem, param3.low8, DPA_API_MENU_EXECUTE )
           3815                         ;#define DpaApiDeepSleep( wdtcon )                         DpaApiEntry( wdtcon, param3.low8, DPA_API_DEEP_SLEEP )
           3816                         ;#endif
           3817                         ;
           3818                         ;#define DpaApiLocalFrc_StackSaver( frcCommand, replyTxPower ) \
           3819                         ;  param2 = frcCommand; \
           3820                         ;  param3.low8 = replyTxPower; \
           3821                         ;  W = DPA_API_LOCAL_FRC; \
           3822                         ;  #asm \
           3823                         ;    DW  __MOVLP( DPA_API_ADDRESS >> 8 ); \
           3824                         ;    DW  __CALL( DPA_API_ADDRESS ); \
           3825                         ;    DW  __MOVLP( CUSTOM_HANDLER_ADDRESS >> 8 ); \
           3826                         ;  #endasm \
           3827                         ;
           3828                         ;#define I2CcomputeFrequency( I2Cfrequency)                ( ( ( F_OSC ) / ( ( I2Cfrequency ) * 4 ) ) - 1 )
           3829                         ;
           3830                         ;// Wrapper routines to be called instead of DpaApi??? macros to decrease code size if more than ~2 calls are needed
           3831                         ;void _DpaApiI2Cinit( uns8 frequency );
           3832                         ;void _DpaApiI2Cstart( uns8 address );
           3833                         ;void _DpaApiI2Cwrite( uns8 data );
           3834                         ;uns8 _DpaApiI2Cread( uns8 ack );
           3835                         ;void _DpaApiI2Cstop();
           3836                         ;void _DpaApiI2CwaitForACK( uns8 address );
           3837                         ;void _DpaApiI2Cshutdown();
           3838                         ;void _DpaApiI2CwaitForIdle();
           3839                         ;void _DpaApiSleep( uns8 wdtcon );
           3840                         ;#if !defined( TR7xD )
           3841                         ;void _DpaApiDeepSleep( uns8 wdtcon );
           3842                         ;#endif
           3843                         ;void _DpaApiSleepFirst( uns8 wdtcon );
           3844                         ;void _DpaApiAfterSleep();
           3845                         ;uns8 _DpaApiRandom();
           3846                         ;void _DpaApiSetRfDefaults();
           3847                         ;
           3848                         ;// Helper "multi" function to decrease code size if used more times
           3849                         ;void _DpaApiI2Cwrite0();
           3850                         ;void _DpaApiI2CwriteAndStop( uns8 data );
           3851                         ;uns8 _DpaApiI2CreadACK();
           3852                         ;uns8 _DpaApiI2CreadNACK();
           3853                         ;uns8 _DpaApiI2CreadNACKandStop();
           3854                         ;
           3855                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           3856                         ;#undef  DpaEvent_Interrupt
           3857                         ;#undef  DpaEvent_BeforeSleep
           3858                         ;#undef  DpaEvent_AfterSleep
           3859                         ;#undef  DpaEvent_FrcValue
           3860                         ;#undef  DpaEvent_FrcResponseTime
           3861                         ;#else
           3862                         ;#undef  DpaEvent_ReceiveDpaResponse
           3863                         ;#undef  DpaEvent_IFaceReceive
           3864                         ;#endif
           3865                         ;
           3866                         ;// To detect overlapping code in case someone would put some code before this header by mistake
           3867                         ;#pragma origin __APPLICATION_ADDRESS
           3868                         ;#pragma updateBank 0
           3869                         ;
           3870                         ;//############################################################################################
           3871                         ;// Main IQRF entry point jumps to the main DPA entry point
           3872                         ;void APPLICATION()
           3873                         ;//############################################################################################
           3874                         ;{
           3875                         ;  #asm
           3876                         ;    DW  __MOVLP( MAIN_DPA_ADDRESS >> 8 );
           3877                         ;  DW  __GOTO( MAIN_DPA_ADDRESS );
           3878                         ;  #endasm
           3879                         ;
           3880                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           3881                         ;    // Fake call to force CustomDpaHandler() compilation
           3882                         ;    CustomDpaHandler();
           3883                         ;#endif
           3884                         ;
           3885                         ;  // Fake call to force DpaApiEntry() compilation
           3886                         ;  DpaApiEntry( param2, param3.low8, W );
           3887                         ;}
           3888                         ;
           3889                         ;//############################################################################################
           3890                         ;// Entry stub to the real DPA API entry
           3891                         ;#pragma origin DPA_API_ADDRESS_ENTRY
           3892                         ;uns8  DpaApiEntry( uns8 par1 @ param2, uns8 par2 @ param3.low8, uns8 apiIndex @ W )
           3893                         ;//############################################################################################
           3894                         ;{
           3895                         ;  #asm
           3896                         ;    DW  __MOVLP( DPA_API_ADDRESS >> 8 );
           3897                         ;  DW  __CALL( DPA_API_ADDRESS );
           3898                         ;  DW  __MOVLP( DPA_API_ADDRESS_ENTRY >> 8 );
           3899                         ;  #endasm
           3900                         ;
           3901                         ;    return W;
           3902                         ;}
           3903                         ;
           3904                         ;//############################################################################################
           3905                         ;#pragma origin DPA_API_ADDRESS_ENTRY + 0x08
           3906                         ;
           3907                         ;//############################################################################################
           3908                         ;
           3909                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           3910                         ;// Next comes Custom DPA handler routine
           3911                         ;#pragma origin CUSTOM_HANDLER_ADDRESS
           3912                         ;#endif
           3913                         ;
           3914                         ;#pragma updateBank 1
           3915                         ;
           3916                         ;//############################################################################################
           3917                         ;#else // _CUSTOM_DPA_HANDLER_
           3918                         ;//############################################################################################
           3919                         ;// 2nd include
           3920                         ;
           3921                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           3922                         ;
           3923                         ;// Library wrappers and helpers to decrease code size
           3924                         ;//############################################################################################
           3925                         ;#pragma library 1
           3926                         ;//############################################################################################
           3927                         ;uns8 _DpaApiUserBank_01( uns8 apiIndex @ W )
           3928                         ;//############################################################################################
           3929                         ;{
           3930 _DpaApiUserBank_01
           3931                         ;#pragma updateBank exit = UserBank_01
           3932                         ;  return DpaApiEntry( param2, param3.low8, apiIndex );
           3933                         ;}
           3934                         ;//############################################################################################
           3935                         ;void _DpaApiI2Cinit( uns8 frequency @ W )
           3936                         ;//############################################################################################
           3937                         ;{
           3938 _DpaApiI2Cinit
           3939                         ;#pragma updateBank exit = UserBank_01
           3940                         ;  param2 = frequency;
           3941                         ;  _DpaApiUserBank_01( DPA_API_I2C_INIT );
           3942                         ;}
           3943                         ;//############################################################################################
           3944                         ;void _DpaApiI2Cstart( uns8 address @ W )
           3945                         ;//############################################################################################
           3946                         ;{
           3947 _DpaApiI2Cstart
           3948                         ;#pragma updateBank exit = UserBank_01
           3949                         ;  param2 = address;
           3950                         ;  _DpaApiUserBank_01( DPA_API_I2C_START );
           3951                         ;}
           3952                         ;//############################################################################################
           3953                         ;void _DpaApiI2Cwrite0()
           3954                         ;//############################################################################################
           3955                         ;{
           3956 _DpaApiI2Cwrite0
           3957                         ;#pragma updateBank exit = UserBank_01
           3958                         ;  _DpaApiI2Cwrite( 0 );
           3959                         ;}
           3960                         ;//############################################################################################
           3961                         ;void _DpaApiI2Cwrite( uns8 data @ W )
           3962                         ;//############################################################################################
           3963                         ;{
           3964 _DpaApiI2Cwrite
           3965                         ;#pragma updateBank exit = UserBank_01
           3966                         ;  param2 = data;
           3967                         ;  _DpaApiUserBank_01( DPA_API_I2C_WRITE );
           3968                         ;}
           3969                         ;//############################################################################################
           3970                         ;uns8 _DpaApiI2CreadNACKandStop()
           3971                         ;//############################################################################################
           3972                         ;{
           3973 _DpaApiI2CreadNACKandStop
           3974                         ;#pragma updateBank exit = UserBank_01
           3975                         ;  param2 = _DpaApiI2CreadNACK();
           3976                         ;  _DpaApiI2Cstop(); /* Must not use param2 */
           3977                         ;  return param2;
           3978                         ;}
           3979                         ;//############################################################################################
           3980                         ;uns8 _DpaApiI2CreadACK()
           3981                         ;//############################################################################################
           3982                         ;{
           3983 _DpaApiI2CreadACK
           3984                         ;#pragma updateBank exit = UserBank_01
           3985                         ;  return _DpaApiI2Cread( 1 );
           3986                         ;}
           3987                         ;//############################################################################################
           3988                         ;uns8 _DpaApiI2CreadNACK()
           3989                         ;//############################################################################################
           3990                         ;{
           3991 _DpaApiI2CreadNACK
           3992                         ;#pragma updateBank exit = UserBank_01
           3993                         ;  return _DpaApiI2Cread( 0 );
           3994                         ;}
           3995                         ;//############################################################################################
           3996                         ;uns8 _DpaApiI2Cread( uns8 ack @ W )
           3997                         ;//############################################################################################
           3998                         ;{
           3999 _DpaApiI2Cread
           4000                         ;#pragma updateBank exit = UserBank_01
           4001                         ;  param2 = ack;
           4002                         ;  return _DpaApiUserBank_01( DPA_API_I2C_READ );
           4003                         ;}
           4004                         ;//############################################################################################
           4005                         ;void _DpaApiI2CwriteAndStop( uns8 data @ W )
           4006                         ;//############################################################################################
           4007                         ;{
           4008 _DpaApiI2CwriteAndStop
           4009                         ;#pragma updateBank exit = UserBank_01
           4010                         ;  _DpaApiI2Cwrite( data );
           4011                         ;  _DpaApiI2Cstop();
           4012                         ;}
           4013                         ;//############################################################################################
           4014                         ;void _DpaApiI2Cstop()
           4015                         ;//############################################################################################
           4016                         ;{
           4017 _DpaApiI2Cstop
           4018                         ;#pragma updateBank exit = UserBank_01
           4019                         ;  _DpaApiUserBank_01( DPA_API_I2C_STOP );
           4020                         ;}
           4021                         ;//############################################################################################
           4022                         ;void _DpaApiI2CwaitForACK( uns8 address @ W )
           4023                         ;//############################################################################################
           4024                         ;{
           4025 _DpaApiI2CwaitForACK
           4026                         ;#pragma updateBank exit = UserBank_01
           4027                         ;  DpaApiI2CwaitForACK( address );
           4028                         ;}
           4029                         ;//############################################################################################
           4030                         ;void _DpaApiI2Cshutdown()
           4031                         ;//############################################################################################
           4032                         ;{
           4033 _DpaApiI2Cshutdown
           4034                         ;#pragma updateBank exit = UserBank_01
           4035                         ;  _DpaApiUserBank_01( DPA_API_I2C_SHUTDOWN );
           4036                         ;}
           4037                         ;//############################################################################################
           4038                         ;void _DpaApiI2CwaitForIdle()
           4039                         ;//############################################################################################
           4040                         ;{
           4041 _DpaApiI2CwaitForIdle
           4042                         ;#pragma updateBank exit = UserBank_01
           4043                         ;  _DpaApiUserBank_01( DPA_API_I2C_WAIT_FOR_IDLE );
           4044                         ;}
           4045                         ;//############################################################################################
           4046                         ;void _DpaApiSleep( uns8 wdtcon @ W )
           4047                         ;//############################################################################################
           4048                         ;{
           4049 _DpaApiSleep
           4050                         ;#pragma updateBank exit = UserBank_01
           4051                         ;  param2 = wdtcon;
           4052                         ;  _DpaApiUserBank_01( DPA_API_SLEEP );
           4053                         ;}
           4054                         ;#if !defined( TR7xD )
           4055                         ;//############################################################################################
           4056                         ;void _DpaApiDeepSleep( uns8 wdtcon @ W )
           4057                         ;//############################################################################################
           4058                         ;{
           4059 _DpaApiDeepSleep
           4060                         ;#pragma updateBank exit = UserBank_01
           4061                         ;  param2 = wdtcon;
           4062                         ;  _DpaApiUserBank_01( DPA_API_DEEP_SLEEP );
           4063                         ;}
           4064                         ;#endif
           4065                         ;//############################################################################################
           4066                         ;void _DpaApiSleepFirst( uns8 wdtcon @ W )
           4067                         ;//############################################################################################
           4068                         ;{
           4069 _DpaApiSleepFirst
           4070                         ;#pragma updateBank exit = UserBank_01
           4071                         ;  FirstDpaApiSleep = TRUE;
           4072                         ;  _DpaApiSleep( wdtcon );
           4073                         ;}
           4074                         ;//############################################################################################
           4075                         ;void _DpaApiAfterSleep()
           4076                         ;//############################################################################################
           4077                         ;{
           4078 _DpaApiAfterSleep
           4079                         ;#pragma updateBank exit = UserBank_01
           4080                         ;  _DpaApiUserBank_01( DPA_API_AFTER_SLEEP );
           4081                         ;}
           4082                         ;//############################################################################################
           4083                         ;uns8 _DpaApiRandom()
           4084                         ;//############################################################################################
           4085                         ;{
           4086 _DpaApiRandom
           4087                         ;#pragma updateBank exit = UserBank_01
           4088                         ;  return _DpaApiUserBank_01( DPA_API_RANDOM );
           4089                         ;}
           4090                         ;//############################################################################################
           4091                         ;void _DpaApiSetRfDefaults()
           4092                         ;//############################################################################################
           4093                         ;{
           4094 _DpaApiSetRfDefaults
           4095                         ;#pragma updateBank exit = UserBank_01
           4096                         ;  _DpaApiUserBank_01( DPA_API_SET_RF_DEFAULTS );
           4097                         ;}
           4098                         ;//############################################################################################
           4099                         ;
           4100                         ;// Code bumper to detect too long code of Custom DPA handler + other routines
           4101                         ;#pragma origin CUSTOM_HANDLER_ADDRESS_END
     0000  4102         ORG 0x4F00
           4103                         ;// To avoid adding some code after handler by mistake
           4104                         ;#pragma origin __MAX_FLASH_ADDRESS
     0000  4105         ORG 0x7FFF
           4106 
     0000  4107         ORG 0x3800
3800 0046  4108         DATA 0046H
3801 0005  4109         DATA 0005H
3802 0082  4110         DATA 0082H
           4111         END
           4112 
           4113 
           4114 ; *** KEY INFO ***
           4115 
           4116 ; 0x0100 P0    5 word(s)  0 % : main
           4117 
           4118 ; 0x3A00 P7    4 word(s)  0 % : APPLICATION
           4119 ; 0x3810 P7    2 word(s)  0 % : dummy
           4120 ; 0x3816 P7    2 word(s)  0 % : iqrfSleep
           4121 ; 0x3819 P7    2 word(s)  0 % : _debug
           4122 ; 0x381C P7    2 word(s)  0 % : moduleInfo
           4123 ; 0x3822 P7    2 word(s)  0 % : pulsingLEDR
           4124 ; 0x3825 P7    2 word(s)  0 % : pulseLEDR
           4125 ; 0x3828 P7    2 word(s)  0 % : stopLEDR
           4126 ; 0x382B P7    2 word(s)  0 % : pulsingLEDG
           4127 ; 0x382E P7    2 word(s)  0 % : pulseLEDG
           4128 ; 0x3831 P7    2 word(s)  0 % : stopLEDG
           4129 ; 0x3834 P7    2 word(s)  0 % : setOnPulsingLED
           4130 ; 0x3837 P7    2 word(s)  0 % : setOffPulsingLED
           4131 ; 0x383A P7    2 word(s)  0 % : eeReadByte
           4132 ; 0x383D P7    2 word(s)  0 % : eeReadData
           4133 ; 0x3840 P7    2 word(s)  0 % : eeWriteByte
           4134 ; 0x3843 P7    2 word(s)  0 % : eeWriteData
           4135 ; 0x3846 P7    2 word(s)  0 % : readFromRAM
           4136 ; 0x384C P7    2 word(s)  0 % : clearBufferINFO
           4137 ; 0x384F P7    2 word(s)  0 % : swapBufferINFO
           4138 ; 0x3852 P7    2 word(s)  0 % : compareBufferINFO2RF
           4139 ; 0x3855 P7    2 word(s)  0 % : copyBufferINFO2COM
           4140 ; 0x3858 P7    2 word(s)  0 % : copyBufferINFO2RF
           4141 ; 0x385B P7    2 word(s)  0 % : copyBufferRF2COM
           4142 ; 0x385E P7    2 word(s)  0 % : copyBufferRF2INFO
           4143 ; 0x3861 P7    2 word(s)  0 % : copyBufferCOM2RF
           4144 ; 0x3864 P7    2 word(s)  0 % : copyBufferCOM2INFO
           4145 ; 0x3867 P7    2 word(s)  0 % : copyMemoryBlock
           4146 ; 0x386A P7    2 word(s)  0 % : startDelay
           4147 ; 0x386D P7    2 word(s)  0 % : startLongDelay
           4148 ; 0x3870 P7    2 word(s)  0 % : isDelay
           4149 ; 0x3873 P7    2 word(s)  0 % : waitDelay
           4150 ; 0x3876 P7    2 word(s)  0 % : waitMS
           4151 ; 0x3879 P7    2 word(s)  0 % : startCapture
           4152 ; 0x387C P7    2 word(s)  0 % : captureTicks
           4153 ; 0x3882 P7    2 word(s)  0 % : waitNewTick
           4154 ; 0x3885 P7    2 word(s)  0 % : enableSPI
           4155 ; 0x3888 P7    2 word(s)  0 % : disableSPI
           4156 ; 0x388B P7    2 word(s)  0 % : startSPI
           4157 ; 0x388E P7    2 word(s)  0 % : stopSPI
           4158 ; 0x3891 P7    2 word(s)  0 % : restartSPI
           4159 ; 0x3894 P7    2 word(s)  0 % : getStatusSPI
           4160 ; 0x3897 P7    2 word(s)  0 % : setRFpower
           4161 ; 0x389A P7    2 word(s)  0 % : setLEDG
           4162 ; 0x389D P7    2 word(s)  0 % : setRFchannel
           4163 ; 0x38A0 P7    2 word(s)  0 % : setRFmode
           4164 ; 0x38A3 P7    2 word(s)  0 % : setRFspeed
           4165 ; 0x38A6 P7    2 word(s)  0 % : setRFsleep
           4166 ; 0x38A9 P7    2 word(s)  0 % : setRFready
           4167 ; 0x38AC P7    2 word(s)  0 % : RFTXpacket
           4168 ; 0x38AF P7    2 word(s)  0 % : RFRXpacket
           4169 ; 0x38B2 P7    2 word(s)  0 % : checkRF
           4170 ; 0x38B8 P7    2 word(s)  0 % : amIBonded
           4171 ; 0x38BB P7    2 word(s)  0 % : removeBond
           4172 ; 0x38BE P7    2 word(s)  0 % : bondNewNode
           4173 ; 0x38C1 P7    2 word(s)  0 % : isBondedNode
           4174 ; 0x38C4 P7    2 word(s)  0 % : removeBondedNode
           4175 ; 0x38C7 P7    2 word(s)  0 % : rebondNode
           4176 ; 0x38CA P7    2 word(s)  0 % : clearAllBonds
           4177 ; 0x38CD P7    2 word(s)  0 % : setNonetMode
           4178 ; 0x38D0 P7    2 word(s)  0 % : setCoordinatorMode
           4179 ; 0x38D3 P7    2 word(s)  0 % : setNodeMode
           4180 ; 0x38D6 P7    2 word(s)  0 % : setNetworkFilteringOn
           4181 ; 0x38D9 P7    2 word(s)  0 % : setNetworkFilteringOff
           4182 ; 0x38DC P7    2 word(s)  0 % : getNetworkParams
           4183 ; 0x38DF P7    2 word(s)  0 % : setRoutingOn
           4184 ; 0x38E2 P7    2 word(s)  0 % : setRoutingOff
           4185 ; 0x38E8 P7    2 word(s)  0 % : answerSystemPacket
           4186 ; 0x38EB P7    2 word(s)  0 % : discovery
           4187 ; 0x38EE P7    2 word(s)  0 % : wasRouted
           4188 ; 0x38F1 P7    2 word(s)  0 % : optimizeHops
           4189 ; 0x38F4 P7    2 word(s)  0 % : getSupplyVoltage
           4190 ; 0x38F7 P7    2 word(s)  0 % : getTemperature
           4191 ; 0x38FA P7    2 word(s)  0 % : clearBufferRF
           4192 ; 0x3910 P7    2 word(s)  0 % : isDiscoveredNode
           4193 ; 0x3913 P7    2 word(s)  0 % : enableRFPGM
           4194 ; 0x3916 P7    2 word(s)  0 % : disableRFPGM
           4195 ; 0x3919 P7    2 word(s)  0 % : setupRFPGM
           4196 ; 0x391C P7    2 word(s)  0 % : runRFPGM
           4197 ; 0x391F P7    2 word(s)  0 % : iqrfDeepSleep
           4198 ; 0x3922 P7    2 word(s)  0 % : wasRFICrestarted
           4199 ; 0x3925 P7    2 word(s)  0 % : eeeWriteData
           4200 ; 0x3928 P7    2 word(s)  0 % : eeeReadData
           4201 ; 0x3931 P7    2 word(s)  0 % : setINDF0
           4202 ; 0x3934 P7    2 word(s)  0 % : setINDF1
           4203 ; 0x3937 P7    2 word(s)  0 % : getRSSI
           4204 ; 0x393A P7    2 word(s)  0 % : removeBondAddress
           4205 ; 0x393D P7    2 word(s)  0 % : sendFRC
           4206 ; 0x3940 P7    2 word(s)  0 % : responseFRC
           4207 ; 0x3943 P7    2 word(s)  0 % : bondRequestAdvanced
           4208 ; 0x3946 P7    2 word(s)  0 % : prebondNodeAtNode
           4209 ; 0x3949 P7    2 word(s)  0 % : nodeAuthorization
           4210 ; 0x394C P7    2 word(s)  0 % : dummy01
           4211 ; 0x3958 P7    2 word(s)  0 % : setAccessPassword
           4212 ; 0x395B P7    2 word(s)  0 % : setUserKey
           4213 ; 0x3961 P7    2 word(s)  0 % : amIRecipientOfFRC
           4214 ; 0x3964 P7    2 word(s)  0 % : setLEDR
           4215 ; 0x3967 P7    2 word(s)  0 % : encryptBufferRF
           4216 ; 0x396A P7    2 word(s)  0 % : decryptBufferRF
           4217 ; 0x396D P7    2 word(s)  0 % : prebondNodeAtCoordinator
           4218 ; 0x3970 P7    2 word(s)  0 % : setFSRs
           4219 ; 0x3973 P7    2 word(s)  0 % : updateCRC16
           4220 ; 0x3976 P7    2 word(s)  0 % : smartConnect
           4221 ; 0x3979 P7    2 word(s)  0 % : addressBitmap
           4222 ; 0x397C P7    2 word(s)  0 % : setServiceChannel
           4223 ; 0x3A08 P7    4 word(s)  0 % : DpaApiEntry
           4224 ; 0x3A20 P7  147 word(s)  7 % : CustomDpaHandler
           4225 
           4226 ; RAM usage: 1088 bytes (0 local), 3008 bytes free
           4227 ; Maximum call level: 3
           4228 ;  Codepage 0 has    6 word(s) :   0 %
           4229 ;  Codepage 1 has    0 word(s) :   0 %
           4230 ;  Codepage 2 has    0 word(s) :   0 %
           4231 ;  Codepage 3 has    0 word(s) :   0 %
           4232 ;  Codepage 4 has    0 word(s) :   0 %
           4233 ;  Codepage 5 has    0 word(s) :   0 %
           4234 ;  Codepage 6 has    0 word(s) :   0 %
           4235 ;  Codepage 7 has  366 word(s) :  17 %
           4236 ;  Codepage 8 has    0 word(s) :   0 %
           4237 ;  Codepage 9 has    0 word(s) :   0 %
           4238 ;  Codepage 10 has    0 word(s) :   0 %
           4239 ;  Codepage 11 has    0 word(s) :   0 %
           4240 ;  Codepage 12 has    0 word(s) :   0 %
           4241 ;  Codepage 13 has    0 word(s) :   0 %
           4242 ;  Codepage 14 has    0 word(s) :   0 %
           4243 ;  Codepage 15 has    0 word(s) :   0 %
           4244 ; Total of 372 code words (1 %)
