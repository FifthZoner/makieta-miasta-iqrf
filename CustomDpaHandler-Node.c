// *********************************************************************
//   Custom DPA Handler code template                                  *
// *********************************************************************
// Copyright (c) MICRORISC s.r.o.
//
// File:    $RCSfile: CustomDpaHandler-Template-Node.c,v $
// Version: $Revision: 1.23 $
// Date:    $Date: 2024/01/22 14:51:08 $
//
// Revision history:
//   2023/03/07  Release for DPA 4.30
//   2022/10/05  Release for DPA 4.18
//   2022/02/24  Release for DPA 4.17
//   2021/08/20  Release for DPA 4.16
//   2020/09/03  Release for DPA 4.15
//   2020/02/27  Release for DPA 4.13
//   2019/01/10  Release for DPA 4.00
//   2017/08/14  Release for DPA 3.01
//   2017/03/13  Release for DPA 3.00
//   2015/08/05  Release for DPA 2.20
//   2014/10/31  Release for DPA 2.10
//   2014/04/30  Release for DPA 2.00
//
// *********************************************************************

// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/

// Default IQRF include (modify the path according to your setup)
#include "IQRF.h"

// Default DPA header (modify the path according to your setup)
#include "DPA.h"
// Default Custom DPA Handler header (modify the path according to your setup)
#include "DPAcustomHandler.h"

// Uncomment the following includes if the respective component is needed
// IQRF standards header (modify the path according to your setup)
//#include "IQRFstandard.h"
//#include "IQRF_HWPID.h"
//#include "NFC.c"

//############################################################################################

// Place for global variables shared among CustomDpaHandler() and other function, otherwise local [static] variables are recommended
// example: uns8 globalCounter;

// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
//############################################################################################
// https://doc.iqrf.org/DpaTechGuide/pages/custom-dpa-handler.html
#define PIN1 2
#define PIN2 3
#define PIN3 5

#define currentIndex PeripheralRam[55]
#define currentCounts PeripheralRam[56]
#define currentCounter PeripheralRam[57]
#define currentBlinks PeripheralRam[58]
#define currentMeta PeripheralRam[59]
#define currentGroup PeripheralRam[60]
#define currentRepeat PeripheralRam[61]

#define idleIndex 55
#define last 54
#define maxIdleTime 5

bit CustomDpaHandler()
//############################################################################################
{
  // Handler presence mark
  clrwdt();

  // Place for local static variables used only within CustomDpaHandler() among more events
  // example: static bit interruptOccured;

  // Detect DPA event to handle (unused event handlers can be commented out or even deleted)
  switch ( GetDpaEvent() )
  {
    // -------------------------------------------------
    case DpaEvent_Interrupt:
      // Do an extra quick background interrupt work
      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the �empty� return handler ensures the shortest possible interrupt routine response time.
      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
      // ! Make sure race condition does not occur when accessing those variables at other places.
      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
      // ! Do not call any OS functions except setINDFx().
      // ! Do not use any OS variables especially for writing access.
      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.
      // https://doc.iqrf.org/DpaTechGuide/pages/EventInterrupt.html
      return Carry;

      // -------------------------------------------------
    case DpaEvent_Idle:
        // akcja przy bezczynności
        // trzeba założyć, że ten kod może być przerwany!
        // trzeba zapisać wszystkie dane i wykonać operacje, dopiero po czym można wprowadzić zmiany

        // na początku sprawdzamy co w ogóle robimy
        if (currentIndex != idleIndex) {
            // to oznacza, że jest instrukcja do wykonania
            // pobieranie zmiennych na wypadek przerwania
            uns8 index = currentIndex;
            uns8 oldIndex = index;
            uns8 counts = currentCounts;
            uns8 counter = currentCounter;
            uns8 counterTarget = 0;
            uns8 countTarget = 0;
            uns8 blinks = currentBlinks;
            uns8 next = 0;
            
            // dane o obecnej instrukcji
            uns8 action = PeripheralRam[currentIndex] & 0x0F;
            uns8 instructionGroup = (PeripheralRam[currentIndex] & 0xF0) >> 4;
            
            // metadane - obecny status instrukcji skomplikowanej i grupa
            uns8 meta = currentMeta;
            uns8 group = currentGroup;
            

            // sprawdzanie czy ta grupa ma to robić
            if (group == instructionGroup || instructionGroup == 0) {

                if (action == 0) {
                    next = 1;
                }
                else if (action == 10) {
                    if (index > last - 1) {
                        next = 1;
                        action = 0;
                    }
                    else {
                        next = 1;
                        group = PeripheralRam[index + 1];
                    }

                }
                else if (action == 11) {
                    next = 1;
                    currentRepeat = 1;
                }
                else if (action == 12) {
                    next = 1;
                    currentRepeat = 0;
                }
                else if (action == 3 || action == 6 || action == 9) {
                    // miganie
                    if (blinks == PeripheralRam[index + 4]) {
                        next = 1;
                    }
                    else if (index > last - 5) {
                        next = 1;
                        action = 0;
                    }
                    else if (meta == 0) {
                        counterTarget = PeripheralRam[index + 1];
                        countTarget = PeripheralRam[index + 2];
                        switch (action) {
                            case 3:
                                LATC.PIN1 = 0;
                                break;
                            case 6:
                                LATC.PIN2 = 0;
                                break;
                            case 9:
                                LATC.PIN3 = 0;
                                break;
                        }
                        if (counts < countTarget && counter < counterTarget) {
                            if (counter <= (255 - maxIdleTime) && counterTarget >= counter + maxIdleTime) {
                                waitMS(maxIdleTime);
                                counter += maxIdleTime;
                            }
                            else {
                                waitMS(counterTarget - counter);
                                counter = counterTarget;
                            }

                            if (counter >= counterTarget) {
                                counter = 0;
                                counts++;
                                if (counts >= countTarget) {
                                    meta = 1;
                                    stopLEDR();
                                    counts = 0;
                                }
                            }
                        }
                        else {
                            meta = 1;
                            counter = 0;
                            counts = 0;
                        }
                    }
                    else {
                        counterTarget = PeripheralRam[index + 1];
                        countTarget = PeripheralRam[index + 3];
                        switch (action) {
                            case 3:
                                LATC.PIN1 = 1;
                                break;
                            case 6:
                                LATC.PIN2 = 1;
                                break;
                            case 9:
                                LATC.PIN3 = 1;
                                break;
                        }
                        if (counts < countTarget && counter < counterTarget) {
                            if (counter <= (255 - maxIdleTime) && counterTarget >= counter + maxIdleTime) {
                                waitMS(maxIdleTime);
                                counter += maxIdleTime;
                            }
                            else {
                                waitMS(counterTarget - counter);
                                counter = counterTarget;
                            }

                            if (counter >= counterTarget) {
                                counter = 0;
                                counts++;
                                if (counts >= countTarget) {
                                    meta = 0;
                                    counts = 0;
                                    blinks++;
                                }
                            }
                        }
                        else {
                            meta = 0;
                            counter = 0;
                            counts = 0;
                            blinks = blinks + 1;
                            if (blinks >= PeripheralRam[index + 4]) {
                                next = 1;
                            }
                        }

                        if (next) {
                            switch (action) {
                                case 3:
                                    LATC.PIN1 = 0;
                                    break;
                                case 6:
                                    LATC.PIN2 = 0;
                                    break;
                                case 9:
                                    LATC.PIN3 = 0;
                                    break;
                            }
                        }
                    }
                }
                else {
                    // włączenie / wyłączenie
                    // tylko liczenie

                    counterTarget = PeripheralRam[index + 1];
                    countTarget = PeripheralRam[index + 2];
                    if (index > last - 3) {
                        next = 1;
                        action = 0;
                    }
                    else if (counts < countTarget && counter < counterTarget) {
                        if (counter <= (255 - maxIdleTime) && counterTarget >= counter + maxIdleTime) {
                            waitMS(maxIdleTime);
                            counter += maxIdleTime;
                        }
                        else {
                            waitMS(counterTarget - counter);
                            counter = counterTarget;
                        }

                        if (counter >= counterTarget) {
                            counter = 0;
                            counts = counts + 1;
                            if (counts >= countTarget) {
                                next = 1;
                            }
                        }
                    }
                    else {
                        next = 1;
                    }

                    if (next) {
                        switch (action) {
                            case 1:
                                LATC.PIN1 = 0;
                                break;
                            case 2:
                                LATC.PIN1 = 1;
                                break;
                            case 4:
                                LATC.PIN2 = 0;
                                break;
                            case 5:
                                LATC.PIN2 = 1;
                                break;
                            case 7:
                                LATC.PIN3 = 0;
                                break;
                            case 8:
                                LATC.PIN3 = 1;
                                break;
                        }
                    }
                }
            }
            else {
                next = 1;
            }

            // po tym wszystkim ustawianie kolejnej instrukcji jeżeli trzeba i jeżeli nie było zmian
            if (next/* && index == currentIndex && action + (instructionGroup << 4) == PeripheralRam[oldIndex]*/) {
                blinks = 0;
                meta = 0;
                counts = 0;
                counter = 0;
                if (action == 0) {
                    if (currentRepeat) index = 0;
                    else index = idleIndex;
                }
                else if (action == 3 || action == 6 || action == 9) {
                    index += 5;
                }
                else if (action == 10) {
                    index += 2;
                }
                else if (action == 10 || action == 11) {
                    index++;
                }
                else {
                    index += 3;
                }
            }

            //if (action + (instructionGroup << 4) == PeripheralRam[oldIndex]) {
                currentIndex = index;
                currentBlinks = blinks;
                currentMeta = meta;
                currentGroup = group;
                currentCounts = counts;
                currentCounter = counter;
            //}

            // ustawianie nowych wartości jeżeli się nie zmieniły
        }

      // Do a quick background work when RF packet is not received
      // https://doc.iqrf.org/DpaTechGuide/pages/idle.html
      break;

      // -------------------------------------------------
    case DpaEvent_Reset:
      // Called after module is reset
      // https://doc.iqrf.org/DpaTechGuide/pages/ResetEvent.html

      //goto DpaHandleReturnTRUE; // return TRUE only if you handle node bonding/unbonding
      break;

      // -------------------------------------------------
#if defined( DpaEvent_BondingButton )
    case DpaEvent_BondingButton:
      // Called to allow a bonding button customization
      // https://doc.iqrf.org/DpaTechGuide/pages/bondingbutton.html

      //goto DpaHandleReturnTRUE; // return TRUE to handle bonding button
      break;
#endif

      // -------------------------------------------------
    case DpaEvent_Indicate:
      // Called to allow a customization of the device indication
      // https://doc.iqrf.org/DpaTechGuide/pages/IndicateEvent.html

      //goto DpaHandleReturnTRUE; // return TRUE to skip default indication
      break;

      // -------------------------------------------------
    case DpaEvent_Init:
      // Do a one time initialization before main loop starts
      // https://doc.iqrf.org/DpaTechGuide/pages/init.html
        TRISC.PIN1 = 0;
	    TRISC.PIN2 = 0;
        TRISC.PIN3 = 0;
	    LATC.PIN1 = 0;
	    LATC.PIN2 = 0;
	    LATC.PIN3 = 0;
          currentMeta = 0;
          currentGroup = 0;
          currentBlinks = 0;
          currentIndex = idleIndex;
          currentCounter = 0;
          currentCounts = 0;
          currentRepeat = 0;
          PeripheralRam[0] = 0;
      break;

      // -------------------------------------------------
    case DpaEvent_ReceiveDpaRequest:
      // Called after DPA request was received
      // https://doc.iqrf.org/DpaTechGuide/pages/receivedparequest.html

      //goto DpaHandleReturnTRUE; // return TRUE to skip default processing
      break;

      // -------------------------------------------------
    case DpaEvent_BeforeSendingDpaResponse:
      // Called before sending DPA response back to originator of DPA response
      // https://doc.iqrf.org/DpaTechGuide/pages/beforesendingdparesponse.html
      break;

      // -------------------------------------------------
    case DpaEvent_Notification:
        if ( _PNUM == PNUM_RAM && _PCMD == CMD_RAM_WRITE )
        {
            currentIndex = 0;
            currentBlinks = 0;
            currentMeta = 0;
            currentCounts = 0;
            currentCounter = 0;
            currentRepeat = 0;
        }
      // Called after DPA request was processed and after DPA response was sent
      // https://doc.iqrf.org/DpaTechGuide/pages/notification.html
      break;

      // -------------------------------------------------
    case DpaEvent_AfterRouting:
      // Called after Notification and after routing of the DPA response was finished
      // https://doc.iqrf.org/DpaTechGuide/pages/afterrouting.html
      break;

      // -------------------------------------------------
    case DpaEvent_FrcValue:
      // Called to get FRC value
      // https://doc.iqrf.org/DpaTechGuide/pages/frcvalue.html
      break;

      // -------------------------------------------------
    case DpaEvent_FrcResponseTime:
      // Called to get FRC response time
      // https://doc.iqrf.org/DpaTechGuide/pages/frcresponsetime.html
      break;

      // -------------------------------------------------
    case DpaEvent_BeforeSleep:
      // Called before going to sleep
      // https://doc.iqrf.org/DpaTechGuide/pages/beforesleep.html
      break;

      // -------------------------------------------------
    case DpaEvent_AfterSleep:
      // Called after woken up after sleep
      // https://doc.iqrf.org/DpaTechGuide/pages/aftersleep.html
      break;

      // -------------------------------------------------
    case DpaEvent_DisableInterrupts:
      // Called when device needs all hardware interrupts to be disabled (before Reset, Restart, LoadCode, Remove bond and run RFPGM)
      // https://doc.iqrf.org/DpaTechGuide/pages/eventDisableInterrupts.html
      break;

      // -------------------------------------------------
    case DpaEvent_PeerToPeer:
      // Called when peer-to-peer (non-networking) packet is received
      // https://doc.iqrf.org/DpaTechGuide/pages/peertopeer.html
      break;

      // -------------------------------------------------
    case DpaEvent_UserDpaValue:
      // Called when DPA is required to return User defined DPA value in the response
      // https://doc.iqrf.org/DpaTechGuide/pages/userdpavalue.html
      break;

      // -------------------------------------------------
#ifdef DpaEvent_InStandby
    case DpaEvent_InStandby:
      // Called to set WDT during Standby
      // https://doc.iqrf.org/DpaTechGuide/pages/instandby.html

      //goto DpaHandleReturnTRUE; // return TRUE to indicate that userReg1 contains WDT settings
      break;
#endif

      // -------------------------------------------------
    case DpaEvent_VerifyLocalFrc:
      // Called to verify local FRC command
      // https://doc.iqrf.org/DpaTechGuide/pages/verifylocalfrc.html

      //goto DpaHandleReturnTRUE; // return TRUE allow FRC command
      break;

      // -------------------------------------------------
#ifdef DpaEvent_MenuActivated
    case DpaEvent_MenuActivated:
      // Called to customize DPA menu
      // https://doc.iqrf.org/DpaTechGuide/pages/menuactivated.html

      //goto DpaHandleReturnTRUE; // return TRUE to allow customizing menu specified by userReg1
      break;
#endif

      // -------------------------------------------------
#ifdef DpaEvent_MenuItemSelected
    case DpaEvent_MenuItemSelected:
      // Called to indicate "OK" or "Error" for selected menu item
      // https://doc.iqrf.org/DpaTechGuide/pages/menuitemselected.html

      //goto DpaHandleReturnTRUE; // return TRUE to indicate "OK" for menu item specified by userReg1, otherwise to indicate Error
      break;
#endif

      // -------------------------------------------------
#ifdef DpaEvent_MenuItemFinalize
    case DpaEvent_MenuItemFinalize:
      // Called to finalize menu item execution
      // https://doc.iqrf.org/DpaTechGuide/pages/menuitemfinalize.html

      break;
#endif

      // -------------------------------------------------
    case DpaEvent_DpaRequest:
      // Called to interpret DPA request for peripherals
      // https://doc.iqrf.org/DpaTechGuide/pages/EventDpaRequest.html
      IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequest()
      {
        // -------------------------------------------------
        // Peripheral enumeration
        // https://doc.iqrf.org/DpaTechGuide/pages/enumerate-peripherals.html

        _DpaMessage.EnumPeripheralsAnswer.UserPerNr |= 0; // ?
        // FlagUserPer( _DpaMessage.EnumPeripheralsAnswer.UserPer, PNUM_USER + 0 ); // ?
        _DpaMessage.EnumPeripheralsAnswer.HWPID |= 0x000F; // ????
        _DpaMessage.EnumPeripheralsAnswer.HWPIDver |= 0; // ????

DpaHandleReturnTRUE:
        return TRUE;
      }
      else
      {
      // -------------------------------------------------
      // Get information about peripheral
      // https://doc.iqrf.org/DpaTechGuide/pages/get-peripheral-info.html

      if ( _PNUM == PNUM_USER + 0 ) // ?
      {
        _DpaMessage.PeripheralInfoAnswer.PerT = 0; // PERIPHERAL_TYPE_?
        _DpaMessage.PeripheralInfoAnswer.PerTE = 0; // PERIPHERAL_TYPE_EXTENDED_?
        _DpaMessage.PeripheralInfoAnswer.Par1 = 0; // ?
        _DpaMessage.PeripheralInfoAnswer.Par2 = 0; // ?
        goto DpaHandleReturnTRUE;
      }

      break;
      }

      // -------------------------------------------------
      // Handle peripheral command
      // https://doc.iqrf.org/DpaTechGuide/pages/handle-peripheral-request.html

      if ( _PNUM == PNUM_USER + 0 ) // ?
      {
        if ( _PCMD == 0 ) // ????
        {
          goto DpaHandleReturnTRUE;
        }
      }

      break;
  }

DpaHandleReturnFALSE:
  return FALSE;
}

//############################################################################################
// Uncomment the following includes if the respective component is needed
//#include "NFC.c"

// Default Custom DPA Handler header; 2nd include implementing a Code bumper to detect too long code of the Custom DPA Handler (modify the path according to your setup)
#include "DPAcustomHandler.h"
//############################################################################################
