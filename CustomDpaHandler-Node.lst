CC5X Version 3.8A,   File: C:\makieta-miasta-iqrf\CustomDpaHandler-Node.c 12. Feb 2025  21:58   Page 1

ADDR CODE  LINE SOURCE

           0001 
           0002 ; CC5X Version 3.8A, Copyright (c) B Knudsen Data
           0003 ; C compiler for the PICmicro family
           0004 ; ************  12. Feb 2025  21:58  *************
           0005 
           0006         processor  16LF18877
           0007         radix  DEC
           0008 
     0000  0009 INDF0       EQU   0x00
     0004  0010 FSR0L       EQU   0x04
     0005  0011 FSR0H       EQU   0x05
     0000  0012 Carry       EQU   0
     0002  0013 Zero_       EQU   2
     0013  0014 TRISC       EQU   0x13
     0018  0015 LATC        EQU   0x18
     0070  0016 userReg0    EQU   0x70
     02A1  0017 DLEN        EQU   0x2A1
     02AE  0018 PNUM        EQU   0x2AE
     02AF  0019 PCMD        EQU   0x2AF
     04A0  0020 DpaRfMessage EQU   0x4A0
     05C0  0021 index       EQU   0x5C0
     05C1  0022 counter     EQU   0x5C1
     05C1  0023 counter_2   EQU   0x5C1
     05C1  0024 blinks      EQU   0x5C1
     05C2  0025 counter_3   EQU   0x5C2
     05C1  0026 counter_4   EQU   0x5C1
     05C1  0027 counter_5   EQU   0x5C1
     05C1  0028 blinks_2    EQU   0x5C1
     05C2  0029 counter_6   EQU   0x5C2
     05C1  0030 counter_7   EQU   0x5C1
     05C1  0031 counter_8   EQU   0x5C1
     05C1  0032 blinks_3    EQU   0x5C1
     05C2  0033 counter_9   EQU   0x5C2
           0034 
0000 2900  0035         GOTO main
           0036 
           0037   ; FILE C:\makieta-miasta-iqrf\IQRF.h
           0038                         ;// *********************************************************************
           0039                         ;//                     IQRF OS basic include file                      *
           0040                         ;// *********************************************************************
           0041                         ;//
           0042                         ;// Online IQRF OS Reference Guide: http://www.iqrf.org/IQRF-OS-Reference-guide/
           0043                         ;//
           0044                         ;// Copyright (c) MICRORISC s.r.o.
           0045                         ;//
           0046                         ;// Intended for:
           0047                         ;//   HW: TR-72D, TR-76D, TR-77D, TR-78D, TR-75D, TR-72G, TR-76G, TR-75G, TR-82G
           0048                         ;//   OS: 4.06D, 4.06G
           0049                         ;//
           0050                         ;// File:    IQRF.h
           0051                         ;// Version: v1.00                                   Revision: 03/06/2022
           0052                         ;//
           0053                         ;// Revision history:
           0054                         ;//   v1.00: 03/06/2022  First release for OS 4.06D and 4.06G.
           0055                         ;//
           0056                         ;// *********************************************************************
           0057                         ;
           0058                         ;#if IQRFOS != 406
           0059                         ;    #error Invalid IQRF OS version, v4.06D or v4.06G is expected. Make sure matching header files and project IQRF OS version setting are used.
           0060                         ;#endif
           0061                         ;
           0062                         ;#if __CC5X__ < 3701
           0063                         ;    #warning Insufficient CC5X compiler version, V3.7A or higher is recommended.
           0064                         ;#endif
           0065                         ;
           0066                         ;#define OS_VERSION 0x46
           0067                         ;
           0068                         ;#if defined TR72D
           0069                         ;    #message Compilation for TR-72D modules (PIC16LF1938) and IQRF OS 4.06D.
           0070                         ;    #define TR7xD
           0071                         ;#elif defined TR76D
           0072                         ;    #message Compilation for TR-76D modules (PIC16LF1938) and IQRF OS 4.06D.
           0073                         ;    #define TR7xD
           0074                         ;#elif defined TR77D
           0075                         ;    #message Compilation for TR-77D modules (PIC16LF1938) and IQRF OS 4.06D.
           0076                         ;    #define TR7xD
           0077                         ;#elif defined TR78D
           0078                         ;    #message Compilation for TR-78D modules (PIC16LF1938) and IQRF OS 4.06D.
           0079                         ;    #define TR7xD
           0080                         ;#elif defined TR75D
           0081                         ;    #message Compilation for TR-75D modules (PIC16LF1938) and IQRF OS 4.06D.
           0082                         ;    #define TR7xD
           0083                         ;#elif defined TR72G
           0084                         ;    #message Compilation for TR-72G modules (PIC16LF18877) and IQRF OS 4.06G.
           0085                         ;    #define TR7xG
           0086                         ;#elif defined TR76G
           0087                         ;    #message Compilation for TR-76G modules (PIC16LF18877) and IQRF OS 4.06G.
           0088                         ;    #define TR7xG
           0089                         ;#elif defined TR75G
           0090                         ;    #message Compilation for TR-75G modules (PIC16LF18877) and IQRF OS 4.06G.
           0091                         ;    #define TR7xG
           0092                         ;#elif defined TR82G
           0093                         ;    #message Compilation for TR-82G modules (PIC16LF18877) and IQRF OS 4.06G.
           0094                         ;    #define TR8xG
           0095                         ;#else
           0096                         ;    #error Unsupported TR module type.
           0097                         ;#endif
           0098                         ;
           0099                         ;// TR-7xD
           0100                         ;#if defined TR7xD
           0101                         ;    #if _16LF1938 != 1
           0102                         ;        #pragma chip      PIC16LF1938
           0103                         ;    #endif
           0104                         ;    
           0105                         ;    #define MCU_ID    4
           0106                         ;    #define TR_FAMILY 1 // TR-7xD
           0107                         ;
           0108                         ;    #define _ACKDT    ACKDT
           0109                         ;    #define _ACKEN    ACKEN
           0110                         ;    #define _ACKSTAT  ACKSTAT
           0111                         ;    #define _BAUDCON  BAUDCON
           0112                         ;    #define _BF       BF
           0113                         ;    #define _CKE      CKE
           0114                         ;    #define _DACCON0  DACCON0
           0115                         ;    #define _DACCON1  DACCON1
           0116                         ;    #define _EEADRH   EEADRH
           0117                         ;    #define _EEADRL   EEADRL
           0118                         ;    #define _EECON1   EECON1
           0119                         ;    #define _EECON2   EECON2
           0120                         ;    #define _EEDATH   EEDATH
           0121                         ;    #define _EEDATL   EEDATL
           0122                         ;    #define _GO       GO
           0123                         ;    #define _PEN      PEN
           0124                         ;    #define _PR6      PR6
           0125                         ;    #define _RCEN     RCEN
           0126                         ;    #define _RCREG    RCREG
           0127                         ;    #define _RCSTA    RCSTA
           0128                         ;    #define _RW_      RW_
           0129                         ;    #define _SEN      SEN
           0130                         ;    #define _SMP      SMP
           0131                         ;    #define _SPBRGH   SPBRGH
           0132                         ;    #define _SPBRGL   SPBRGL
           0133                         ;    #define _SSPADD   SSPADD
           0134                         ;    #define _SSPBUF   SSPBUF
           0135                         ;    #define _SSPCON1  SSPCON1
           0136                         ;    #define _SSPCON2  SSPCON2
           0137                         ;    #define _SSPIF    SSPIF
           0138                         ;    #define _SSPEN    SSPEN
           0139                         ;    #define _SSPSTAT  SSPSTAT
           0140                         ;    #define _SWDTEN   SWDTEN
           0141                         ;    #define _T1SYNC_  T1SYNC_
           0142                         ;    #define _TMR1ON   TMR1ON
           0143                         ;    #define _TMR6     TMR6
           0144                         ;    #define _TMR6ON   TMR6ON
           0145                         ;    #define _TXREG    TXREG
           0146                         ;    #define _TXSTA    TXSTA
           0147                         ;    #define _WDTCON   WDTCON
           0148                         ;
           0149                         ;// TR-7xG, TR-8xG
           0150                         ;#elif defined TR7xG || defined TR8xG
           0151                         ;    #if _16LF18877 != 1
           0152                         ;        #pragma chip      PIC16LF18877
           0153                         ;    #endif
           0154                         ;    
           0155                         ;    #define MCU_ID    5
           0156                         ;    
           0157                         ;    #if defined TR7xG
           0158                         ;        #define TR_FAMILY 2 // TR-7xG
           0159                         ;    #else
           0160                         ;        #define TR_FAMILY 3 // TR-8xG
           0161                         ;    #endif
           0162                         ;
           0163                         ;    #define _ACKDT    SSP1CON2.5
           0164                         ;    #define _ACKEN    SSP1CON2.4
           0165                         ;    #define _ACKSTAT  SSP1CON2.6
           0166                         ;    #define _BAUDCON  BAUD1CON
           0167                         ;    #define _BF       SSP1STAT.0
           0168                         ;    #define _CKE      SSP1STAT.6
           0169                         ;    #define _DACCON0  DAC1CON0
           0170                         ;    #define _DACCON1  DAC1CON1
           0171                         ;    #define _EEADRH   NVMADRH
           0172                         ;    #define _EEADRL   NVMADRL
           0173                         ;    #define _EECON1   NVMCON1
           0174                         ;    #define _EECON2   NVMCON2
           0175                         ;    #define _EEDATH   NVMDATH
           0176                         ;    #define _EEDATL   NVMDATL
           0177                         ;    #define _GO       ADGO
           0178                         ;    #define _PEN      SSP1CON2.2
           0179                         ;    #define _PR6      T6PR
           0180                         ;    #define _RCEN     SSP1CON2.3
           0181                         ;    #define _RCREG    RC1REG
           0182                         ;    #define _RCSTA    RC1STA
           0183                         ;    #define _RW_      SSP1STAT.2
           0184                         ;    #define _SEN      SSP1CON2.0
           0185                         ;    #define _SMP      SSP1STAT.7
           0186                         ;    #define _SPBRGH   SP1BRGH
           0187                         ;    #define _SPBRGL   SP1BRGL
           0188                         ;    #define _SSPADD   SSP1ADD
           0189                         ;    #define _SSPBUF   SSP1BUF
           0190                         ;    #define _SSPCON1  SSP1CON1
           0191                         ;    #define _SSPCON2  SSP1CON2
           0192                         ;    #define _SSPIF    SSP1IF
           0193                         ;    #define _SSPEN    SSP1CON1.5
           0194                         ;    #define _SSPSTAT  SSP1STAT
           0195                         ;    #define _SWDTEN   WDTCON0.0
           0196                         ;    #define _T1SYNC_  T1CON.2
           0197                         ;    #define _TMR1ON   T1CON.0
           0198                         ;    #define _TMR6     T6TMR
           0199                         ;    #define _TMR6ON   T6CON.7
           0200                         ;    #define _TXREG    TX1REG
           0201                         ;    #define _TXSTA    TX1STA
           0202                         ;    #define _WDTCON   WDTCON0
           0203                         ;#else
           0204                         ;    #error Unsupported TR module family.
           0205                         ;#endif
           0206                         ;
           0207                         ;#pragma origin 0x100
     0000  0208         ORG 0x0100
           0209                         ;#pragma update_RP 0
           0210                         ;
           0211                         ;void APPLICATION();
           0212                         ;
           0213                         ;void main()                                 // Skipped during Upload
           0214                         ;{
           0215 main
           0216                         ;    APPLICATION();
0100 31B8  0217         MOVLP 0x38
0101 2200  0218         CALL  APPLICATION
0102 3180  0219         MOVLP 0x00
           0220                         ;}
0103 0063  0221         SLEEP
0104 2900  0222         GOTO main
           0223 
           0224   ; FILE C:\makieta-miasta-iqrf\IQRF-functions.h
           0225                         ;// *********************************************************************
           0226                         ;//                         IQRF OS functions                           *
           0227                         ;// *********************************************************************
           0228                         ;//
           0229                         ;// Online IQRF OS Reference Guide: http://www.iqrf.org/IQRF-OS-Reference-guide/
           0230                         ;//
           0231                         ;// Copyright (c) MICRORISC s.r.o.
           0232                         ;//
           0233                         ;// Intended for:
           0234                         ;//   HW: TR-72D, TR-76D, TR-77D, TR-78D, TR-75D, TR-72G, TR-76G, TR-75G, TR-82G
           0235                         ;//   OS: 4.06D, 4.06G
           0236                         ;//
           0237                         ;// File:    IQRF-functions.h
           0238                         ;// Version: v1.01                                   Revision: 05/12/2024
           0239                         ;//
           0240                         ;// Revision history:
           0241                         ;//   v1.01: 05/12/2024  The return value of the wasRFICrestarted function is different for TR-7xD and TR-7xG module lines.
           0242                         ;//   v1.00: 03/06/2022  First release for OS 4.06D and 4.06G.
           0243                         ;//
           0244                         ;// *********************************************************************
           0245                         ;
           0246                         ;#pragma optimize 0
           0247                         ;#pragma update_PAGE 0
           0248                         ;#pragma update_RP 0
           0249                         ;
           0250                         ;// Identification header for internal use only
           0251                         ;#pragma cdata[0x3800] = OS_VERSION /* OS Version */, MCU_ID /* MCU ID */, TR_FAMILY | 0x80 /*TR Family*/
           0252                         ;
           0253                         ;#define dummy_address   0x3810
           0254                         ;#pragma origin dummy_address
     0000  0255         ORG 0x3810
           0256                         ;void dummy()
           0257                         ;{
           0258 dummy
           0259                         ;  #asm
           0260                         ;    DW 0x2000
3810 2000  0261         DW    0x2000
           0262                         ;  #endasm
           0263                         ;  #pragma updateBank exit=UserBank_01
           0264                         ;}
3811 0008  0265         RETURN
           0266                         ;
           0267                         ;#define iqrfSleep_address   0x3816
           0268                         ;#pragma origin iqrfSleep_address
     0000  0269         ORG 0x3816
           0270                         ;void iqrfSleep()
           0271                         ;{
           0272 iqrfSleep
           0273                         ;  #asm
           0274                         ;    DW 0x2000
3816 2000  0275         DW    0x2000
           0276                         ;  #endasm
           0277                         ;  #pragma updateBank exit=UserBank_01
           0278                         ;}
3817 0008  0279         RETURN
           0280                         ;
           0281                         ;#define _debug_address  0x3819
           0282                         ;#pragma origin _debug_address
     0000  0283         ORG 0x3819
           0284                         ;void _debug()
           0285                         ;{
           0286 _debug
           0287                         ;  #asm
           0288                         ;    DW 0x2000
3819 2000  0289         DW    0x2000
           0290                         ;  #endasm
           0291                         ;  #pragma updateBank exit=UserBank_01
           0292                         ;}
381A 0008  0293         RETURN
           0294                         ;
           0295                         ;#define debug()     \
           0296                         ;    do {            \
           0297                         ;        _debug();   \
           0298                         ;        nop();      \
           0299                         ;    } while (0)
           0300                         ;
           0301                         ;#define moduleInfo_address  0x381c
           0302                         ;#pragma origin moduleInfo_address
     0000  0303         ORG 0x381C
           0304                         ;void moduleInfo()
           0305                         ;{
           0306 moduleInfo
           0307                         ;  #asm
           0308                         ;    DW 0x2000
381C 2000  0309         DW    0x2000
           0310                         ;  #endasm
           0311                         ;  #pragma updateBank exit=UserBank_01
           0312                         ;}
381D 0008  0313         RETURN
           0314                         ;
           0315                         ;#define pulsingLEDR_address 0x3822
           0316                         ;#pragma origin pulsingLEDR_address
     0000  0317         ORG 0x3822
           0318                         ;void pulsingLEDR()
           0319                         ;{
           0320 pulsingLEDR
           0321                         ;  #asm
           0322                         ;    DW 0x2000
3822 2000  0323         DW    0x2000
           0324                         ;  #endasm
           0325                         ;  #pragma updateBank exit=UserBank_01
           0326                         ;}
3823 0008  0327         RETURN
           0328                         ;
           0329                         ;#define pulseLEDR_address   0x3825
           0330                         ;#pragma origin pulseLEDR_address
     0000  0331         ORG 0x3825
           0332                         ;void pulseLEDR()
           0333                         ;{
           0334 pulseLEDR
           0335                         ;  #asm
           0336                         ;    DW 0x2000
3825 2000  0337         DW    0x2000
           0338                         ;  #endasm
           0339                         ;  #pragma updateBank exit=UserBank_01
           0340                         ;}
3826 0008  0341         RETURN
           0342                         ;
           0343                         ;#define stopLEDR_address    0x3828
           0344                         ;#pragma origin stopLEDR_address
     0000  0345         ORG 0x3828
           0346                         ;void stopLEDR()
           0347                         ;{
           0348 stopLEDR
           0349                         ;  #asm
           0350                         ;    DW 0x2000
3828 2000  0351         DW    0x2000
           0352                         ;  #endasm
           0353                         ;  #pragma updateBank exit=UserBank_01
           0354                         ;}
3829 0008  0355         RETURN
           0356                         ;
           0357                         ;#define pulsingLEDG_address 0x382b
           0358                         ;#pragma origin pulsingLEDG_address
     0000  0359         ORG 0x382B
           0360                         ;void pulsingLEDG()
           0361                         ;{
           0362 pulsingLEDG
           0363                         ;  #asm
           0364                         ;    DW 0x2000
382B 2000  0365         DW    0x2000
           0366                         ;  #endasm
           0367                         ;  #pragma updateBank exit=UserBank_01
           0368                         ;}
382C 0008  0369         RETURN
           0370                         ;
           0371                         ;#define pulseLEDG_address   0x382e
           0372                         ;#pragma origin pulseLEDG_address
     0000  0373         ORG 0x382E
           0374                         ;void pulseLEDG()
           0375                         ;{
           0376 pulseLEDG
           0377                         ;  #asm
           0378                         ;    DW 0x2000
382E 2000  0379         DW    0x2000
           0380                         ;  #endasm
           0381                         ;  #pragma updateBank exit=UserBank_01
           0382                         ;}
382F 0008  0383         RETURN
           0384                         ;
           0385                         ;#define stopLEDG_address    0x3831
           0386                         ;#pragma origin stopLEDG_address
     0000  0387         ORG 0x3831
           0388                         ;void stopLEDG()
           0389                         ;{
           0390 stopLEDG
           0391                         ;  #asm
           0392                         ;    DW 0x2000
3831 2000  0393         DW    0x2000
           0394                         ;  #endasm
           0395                         ;  #pragma updateBank exit=UserBank_01
           0396                         ;}
3832 0008  0397         RETURN
           0398                         ;
           0399                         ;#define setOnPulsingLED_address 0x3834
           0400                         ;#pragma origin setOnPulsingLED_address
     0000  0401         ORG 0x3834
           0402                         ;void setOnPulsingLED(uns8 ticks @ W)
           0403                         ;{
           0404 setOnPulsingLED
           0405                         ;  #asm
           0406                         ;    DW 0x2000
3834 2000  0407         DW    0x2000
           0408                         ;  #endasm
           0409                         ;  #pragma updateBank exit=UserBank_01
           0410                         ;}
3835 0008  0411         RETURN
           0412                         ;
           0413                         ;#define setOffPulsingLED_address    0x3837
           0414                         ;#pragma origin setOffPulsingLED_address
     0000  0415         ORG 0x3837
           0416                         ;void setOffPulsingLED(uns8 ticks @ W)
           0417                         ;{
           0418 setOffPulsingLED
           0419                         ;  #asm
           0420                         ;    DW 0x2000
3837 2000  0421         DW    0x2000
           0422                         ;  #endasm
           0423                         ;  #pragma updateBank exit=UserBank_01
           0424                         ;}
3838 0008  0425         RETURN
           0426                         ;
           0427                         ;#define eeReadByte_address  0x383a
           0428                         ;#pragma origin eeReadByte_address
     0000  0429         ORG 0x383A
           0430                         ;uns8 eeReadByte(uns8 address @ W)
           0431                         ;{
           0432 eeReadByte
           0433                         ;  #asm
           0434                         ;    DW 0x2000
383A 2000  0435         DW    0x2000
           0436                         ;  #endasm
           0437                         ;  #pragma updateBank exit=UserBank_01
           0438                         ;  return W;
383B 0008  0439         RETURN
           0440                         ;}
           0441                         ;
           0442                         ;#define eeReadData_address  0x383d
           0443                         ;#pragma origin eeReadData_address
     0000  0444         ORG 0x383D
           0445                         ;bit eeReadData(uns8 address @ param2, uns8 length @ W)
           0446                         ;{
           0447 eeReadData
           0448                         ;  #asm
           0449                         ;    DW 0x2000
383D 2000  0450         DW    0x2000
           0451                         ;  #endasm
           0452                         ;  #pragma updateBank exit=UserBank_01
           0453                         ;  return Carry;
383E 0008  0454         RETURN
           0455                         ;}
           0456                         ;
           0457                         ;#define eeWriteByte_address 0x3840
           0458                         ;#pragma origin eeWriteByte_address
     0000  0459         ORG 0x3840
           0460                         ;void eeWriteByte(uns8 address @ param2, uns8 data @ W)
           0461                         ;{
           0462 eeWriteByte
           0463                         ;  #asm
           0464                         ;    DW 0x2000
3840 2000  0465         DW    0x2000
           0466                         ;  #endasm
           0467                         ;  #pragma updateBank exit=UserBank_01
           0468                         ;}
3841 0008  0469         RETURN
           0470                         ;
           0471                         ;#define eeWriteData_address 0x3843
           0472                         ;#pragma origin eeWriteData_address
     0000  0473         ORG 0x3843
           0474                         ;void eeWriteData(uns8 address @ param2, uns8 length @ W)
           0475                         ;{
           0476 eeWriteData
           0477                         ;  #asm
           0478                         ;    DW 0x2000
3843 2000  0479         DW    0x2000
           0480                         ;  #endasm
           0481                         ;  #pragma updateBank exit=UserBank_01
           0482                         ;}
3844 0008  0483         RETURN
           0484                         ;
           0485                         ;#define readFromRAM_address 0x3846
           0486                         ;#pragma origin readFromRAM_address
     0000  0487         ORG 0x3846
           0488                         ;uns8 readFromRAM(uns16 address @ FSR0)
           0489                         ;{
           0490 readFromRAM
           0491                         ;  #asm
           0492                         ;    DW 0x2000
3846 2000  0493         DW    0x2000
           0494                         ;  #endasm
           0495                         ;  #pragma updateBank exit=UserBank_01
           0496                         ;  return W;
3847 0008  0497         RETURN
           0498                         ;}
           0499                         ;
           0500                         ;#define clearBufferINFO_address 0x384c
           0501                         ;#pragma origin clearBufferINFO_address
     0000  0502         ORG 0x384C
           0503                         ;void clearBufferINFO()
           0504                         ;{
           0505 clearBufferINFO
           0506                         ;  #asm
           0507                         ;    DW 0x2000
384C 2000  0508         DW    0x2000
           0509                         ;  #endasm
           0510                         ;  #pragma updateBank exit=UserBank_01
           0511                         ;}
384D 0008  0512         RETURN
           0513                         ;
           0514                         ;#define swapBufferINFO_address  0x384f
           0515                         ;#pragma origin swapBufferINFO_address
     0000  0516         ORG 0x384F
           0517                         ;void swapBufferINFO()
           0518                         ;{
           0519 swapBufferINFO
           0520                         ;  #asm
           0521                         ;    DW 0x2000
384F 2000  0522         DW    0x2000
           0523                         ;  #endasm
           0524                         ;  #pragma updateBank exit=UserBank_01
           0525                         ;}
3850 0008  0526         RETURN
           0527                         ;
           0528                         ;#define compareBufferINFO2RF_address    0x3852
           0529                         ;#pragma origin compareBufferINFO2RF_address
     0000  0530         ORG 0x3852
           0531                         ;bit compareBufferINFO2RF(uns8 length @ W)
           0532                         ;{
           0533 compareBufferINFO2RF
           0534                         ;  #asm
           0535                         ;    DW 0x2000
3852 2000  0536         DW    0x2000
           0537                         ;  #endasm
           0538                         ;  #pragma updateBank exit=UserBank_01
           0539                         ;  return Carry;
3853 0008  0540         RETURN
           0541                         ;}
           0542                         ;
           0543                         ;#define copyBufferINFO2COM_address  0x3855
           0544                         ;#pragma origin copyBufferINFO2COM_address
     0000  0545         ORG 0x3855
           0546                         ;void copyBufferINFO2COM()
           0547                         ;{
           0548 copyBufferINFO2COM
           0549                         ;  #asm
           0550                         ;    DW 0x2000
3855 2000  0551         DW    0x2000
           0552                         ;  #endasm
           0553                         ;  #pragma updateBank exit=UserBank_01
           0554                         ;}
3856 0008  0555         RETURN
           0556                         ;
           0557                         ;#define copyBufferINFO2RF_address   0x3858
           0558                         ;#pragma origin copyBufferINFO2RF_address
     0000  0559         ORG 0x3858
           0560                         ;void copyBufferINFO2RF()
           0561                         ;{
           0562 copyBufferINFO2RF
           0563                         ;  #asm
           0564                         ;    DW 0x2000
3858 2000  0565         DW    0x2000
           0566                         ;  #endasm
           0567                         ;  #pragma updateBank exit=UserBank_01
           0568                         ;}
3859 0008  0569         RETURN
           0570                         ;
           0571                         ;#define copyBufferRF2COM_address    0x385b
           0572                         ;#pragma origin copyBufferRF2COM_address
     0000  0573         ORG 0x385B
           0574                         ;void copyBufferRF2COM()
           0575                         ;{
           0576 copyBufferRF2COM
           0577                         ;  #asm
           0578                         ;    DW 0x2000
385B 2000  0579         DW    0x2000
           0580                         ;  #endasm
           0581                         ;  #pragma updateBank exit=UserBank_01
           0582                         ;}
385C 0008  0583         RETURN
           0584                         ;
           0585                         ;#define copyBufferRF2INFO_address   0x385e
           0586                         ;#pragma origin copyBufferRF2INFO_address
     0000  0587         ORG 0x385E
           0588                         ;void copyBufferRF2INFO()
           0589                         ;{
           0590 copyBufferRF2INFO
           0591                         ;  #asm
           0592                         ;    DW 0x2000
385E 2000  0593         DW    0x2000
           0594                         ;  #endasm
           0595                         ;  #pragma updateBank exit=UserBank_01
           0596                         ;}
385F 0008  0597         RETURN
           0598                         ;
           0599                         ;#define copyBufferCOM2RF_address    0x3861
           0600                         ;#pragma origin copyBufferCOM2RF_address
     0000  0601         ORG 0x3861
           0602                         ;void copyBufferCOM2RF()
           0603                         ;{
           0604 copyBufferCOM2RF
           0605                         ;  #asm
           0606                         ;    DW 0x2000
3861 2000  0607         DW    0x2000
           0608                         ;  #endasm
           0609                         ;  #pragma updateBank exit=UserBank_01
           0610                         ;}
3862 0008  0611         RETURN
           0612                         ;
           0613                         ;#define copyBufferCOM2INFO_address  0x3864
           0614                         ;#pragma origin copyBufferCOM2INFO_address
     0000  0615         ORG 0x3864
           0616                         ;void copyBufferCOM2INFO()
           0617                         ;{
           0618 copyBufferCOM2INFO
           0619                         ;  #asm
           0620                         ;    DW 0x2000
3864 2000  0621         DW    0x2000
           0622                         ;  #endasm
           0623                         ;  #pragma updateBank exit=UserBank_01
           0624                         ;}
3865 0008  0625         RETURN
           0626                         ;
           0627                         ;#define copyMemoryBlock_address 0x3867
           0628                         ;#pragma origin copyMemoryBlock_address
     0000  0629         ORG 0x3867
           0630                         ;void copyMemoryBlock(uns16 from @ FSR0, uns16 to @ FSR1, uns8 length @ W)
           0631                         ;{
           0632 copyMemoryBlock
           0633                         ;  #asm
           0634                         ;    DW 0x2000
3867 2000  0635         DW    0x2000
           0636                         ;  #endasm
           0637                         ; #pragma updateBank exit=UserBank_01
           0638                         ;}
3868 0008  0639         RETURN
           0640                         ;
           0641                         ;#define startDelay_address  0x386a
           0642                         ;#pragma origin startDelay_address
     0000  0643         ORG 0x386A
           0644                         ;void startDelay(uns8 ticks @ W)
           0645                         ;{
           0646 startDelay
           0647                         ;  #asm
           0648                         ;    DW 0x2000
386A 2000  0649         DW    0x2000
           0650                         ;  #endasm
           0651                         ;  #pragma updateBank exit=UserBank_01
           0652                         ;}
386B 0008  0653         RETURN
           0654                         ;
           0655                         ;#define startLongDelay_address  0x386d
           0656                         ;#pragma origin startLongDelay_address
     0000  0657         ORG 0x386D
           0658                         ;void startLongDelay(uns16 ticks @ param3)
           0659                         ;{
           0660 startLongDelay
           0661                         ;  #asm
           0662                         ;    DW 0x2000
386D 2000  0663         DW    0x2000
           0664                         ;  #endasm
           0665                         ;  #pragma updateBank exit=UserBank_01
           0666                         ;}
386E 0008  0667         RETURN
           0668                         ;
           0669                         ;#define isDelay_address 0x3870
           0670                         ;#pragma origin isDelay_address
     0000  0671         ORG 0x3870
           0672                         ;bit isDelay()
           0673                         ;{
           0674 isDelay
           0675                         ;  #asm
           0676                         ;    DW 0x2000
3870 2000  0677         DW    0x2000
           0678                         ;  #endasm
           0679                         ;  #pragma updateBank exit=UserBank_01
           0680                         ;  return Carry;
3871 0008  0681         RETURN
           0682                         ;}
           0683                         ;
           0684                         ;#define waitDelay_address   0x3873
           0685                         ;#pragma origin waitDelay_address
     0000  0686         ORG 0x3873
           0687                         ;void waitDelay(uns8 ticks @ W)
           0688                         ;{
           0689 waitDelay
           0690                         ;  #asm
           0691                         ;    DW 0x2000
3873 2000  0692         DW    0x2000
           0693                         ;  #endasm
           0694                         ;  #pragma updateBank exit=UserBank_01
           0695                         ;}
3874 0008  0696         RETURN
           0697                         ;
           0698                         ;#define waitMS_address  0x3876
           0699                         ;#pragma origin waitMS_address
     0000  0700         ORG 0x3876
           0701                         ;void waitMS(uns8 ms @ W)
           0702                         ;{
           0703 waitMS
           0704                         ;  #asm
           0705                         ;    DW 0x2000
3876 2000  0706         DW    0x2000
           0707                         ;  #endasm
           0708                         ;  #pragma updateBank exit=UserBank_01
           0709                         ;}
3877 0008  0710         RETURN
           0711                         ;
           0712                         ;#define startCapture_address    0x3879
           0713                         ;#pragma origin startCapture_address
     0000  0714         ORG 0x3879
           0715                         ;void startCapture()
           0716                         ;{
           0717 startCapture
           0718                         ;  #asm
           0719                         ;    DW 0x2000
3879 2000  0720         DW    0x2000
           0721                         ;  #endasm
           0722                         ;  #pragma updateBank exit=UserBank_01
           0723                         ;}
387A 0008  0724         RETURN
           0725                         ;
           0726                         ;#define captureTicks_address    0x387c
           0727                         ;#pragma origin captureTicks_address
     0000  0728         ORG 0x387C
           0729                         ;void captureTicks()
           0730                         ;{
           0731 captureTicks
           0732                         ;  #asm
           0733                         ;    DW 0x2000
387C 2000  0734         DW    0x2000
           0735                         ;  #endasm
           0736                         ;  #pragma updateBank exit=UserBank_01
           0737                         ;}
387D 0008  0738         RETURN
           0739                         ;
           0740                         ;#define waitNewTick_address 0x3882
           0741                         ;#pragma origin waitNewTick_address
     0000  0742         ORG 0x3882
           0743                         ;void waitNewTick()
           0744                         ;{
           0745 waitNewTick
           0746                         ;  #asm
           0747                         ;    DW 0x2000
3882 2000  0748         DW    0x2000
           0749                         ;  #endasm
           0750                         ;  #pragma updateBank exit=UserBank_01
           0751                         ;}
3883 0008  0752         RETURN
           0753                         ;
           0754                         ;#define enableSPI_address   0x3885
           0755                         ;#pragma origin enableSPI_address
     0000  0756         ORG 0x3885
           0757                         ;void enableSPI()
           0758                         ;{
           0759 enableSPI
           0760                         ;  #asm
           0761                         ;    DW 0x2000
3885 2000  0762         DW    0x2000
           0763                         ;  #endasm
           0764                         ;  #pragma updateBank exit=UserBank_01
           0765                         ;}
3886 0008  0766         RETURN
           0767                         ;
           0768                         ;#define disableSPI_address  0x3888
           0769                         ;#pragma origin disableSPI_address
     0000  0770         ORG 0x3888
           0771                         ;void disableSPI()
           0772                         ;{
           0773 disableSPI
           0774                         ;  #asm
           0775                         ;    DW 0x2000
3888 2000  0776         DW    0x2000
           0777                         ;  #endasm
           0778                         ;  #pragma updateBank exit=UserBank_01
           0779                         ;}
3889 0008  0780         RETURN
           0781                         ;
           0782                         ;#define startSPI_address    0x388b
           0783                         ;#pragma origin startSPI_address
     0000  0784         ORG 0x388B
           0785                         ;void startSPI(uns8 length @ W)
           0786                         ;{
           0787 startSPI
           0788                         ;  #asm
           0789                         ;    DW 0x2000
388B 2000  0790         DW    0x2000
           0791                         ;  #endasm
           0792                         ;  #pragma updateBank exit=UserBank_01
           0793                         ;}
388C 0008  0794         RETURN
           0795                         ;
           0796                         ;#define stopSPI_address 0x388e
           0797                         ;#pragma origin stopSPI_address
     0000  0798         ORG 0x388E
           0799                         ;void stopSPI()
           0800                         ;{
           0801 stopSPI
           0802                         ;  #asm
           0803                         ;    DW 0x2000
388E 2000  0804         DW    0x2000
           0805                         ;  #endasm
           0806                         ;  #pragma updateBank exit=UserBank_01
           0807                         ;}
388F 0008  0808         RETURN
           0809                         ;
           0810                         ;#define restartSPI_address  0x3891
           0811                         ;#pragma origin restartSPI_address
     0000  0812         ORG 0x3891
           0813                         ;void restartSPI()
           0814                         ;{
           0815 restartSPI
           0816                         ;  #asm
           0817                         ;    DW 0x2000
3891 2000  0818         DW    0x2000
           0819                         ;  #endasm
           0820                         ;  #pragma updateBank exit=UserBank_01
           0821                         ;}
3892 0008  0822         RETURN
           0823                         ;
           0824                         ;#define getStatusSPI_address    0x3894
           0825                         ;#pragma origin getStatusSPI_address
     0000  0826         ORG 0x3894
           0827                         ;bit getStatusSPI()
           0828                         ;{
           0829 getStatusSPI
           0830                         ;  #asm
           0831                         ;    DW 0x2000
3894 2000  0832         DW    0x2000
           0833                         ;  #endasm
           0834                         ;  #pragma updateBank exit=UserBank_01
           0835                         ;  return Carry;
3895 0008  0836         RETURN
           0837                         ;}
           0838                         ;
           0839                         ;#define setRFpower_address  0x3897
           0840                         ;#pragma origin setRFpower_address
     0000  0841         ORG 0x3897
           0842                         ;void setRFpower(uns8 level @ W)
           0843                         ;{
           0844 setRFpower
           0845                         ;  #asm
           0846                         ;    DW 0x2000
3897 2000  0847         DW    0x2000
           0848                         ;  #endasm
           0849                         ;  #pragma updateBank exit=UserBank_01
           0850                         ;}
3898 0008  0851         RETURN
           0852                         ;
           0853                         ;#define setLEDG_address 0x389a
           0854                         ;#pragma origin setLEDG_address
     0000  0855         ORG 0x389A
           0856                         ;void setLEDG()
           0857                         ;{
           0858 setLEDG
           0859                         ;  #asm
           0860                         ;    DW 0x2000
389A 2000  0861         DW    0x2000
           0862                         ;  #endasm
           0863                         ;  #pragma updateBank exit=UserBank_01
           0864                         ;}
389B 0008  0865         RETURN
           0866                         ;
           0867                         ;#define setRFchannel_address    0x389d
           0868                         ;#pragma origin setRFchannel_address
     0000  0869         ORG 0x389D
           0870                         ;void setRFchannel(uns8 channel @ W)
           0871                         ;{
           0872 setRFchannel
           0873                         ;  #asm
           0874                         ;    DW 0x2000
389D 2000  0875         DW    0x2000
           0876                         ;  #endasm
           0877                         ;  #pragma updateBank exit=UserBank_01
           0878                         ;}
389E 0008  0879         RETURN
           0880                         ;
           0881                         ;#define setRFmode_address   0x38a0
           0882                         ;#pragma origin setRFmode_address
     0000  0883         ORG 0x38A0
           0884                         ;void setRFmode(uns8 mode @ W)
           0885                         ;{
           0886 setRFmode
           0887                         ;  #asm
           0888                         ;    DW 0x2000
38A0 2000  0889         DW    0x2000
           0890                         ;  #endasm
           0891                         ;  #pragma updateBank exit=UserBank_01
           0892                         ;}
38A1 0008  0893         RETURN
           0894                         ;
           0895                         ;#define setRFspeed_address  0x38a3
           0896                         ;#pragma origin setRFspeed_address
     0000  0897         ORG 0x38A3
           0898                         ;void setRFspeed(uns8 speed @ W)
           0899                         ;{
           0900 setRFspeed
           0901                         ;  #asm
           0902                         ;    DW 0x2000
38A3 2000  0903         DW    0x2000
           0904                         ;  #endasm
           0905                         ;  #pragma updateBank exit=UserBank_01
           0906                         ;}
38A4 0008  0907         RETURN
           0908                         ;
           0909                         ;#define setRFsleep_address  0x38a6
           0910                         ;#pragma origin setRFsleep_address
     0000  0911         ORG 0x38A6
           0912                         ;void setRFsleep()
           0913                         ;{
           0914 setRFsleep
           0915                         ;  #asm
           0916                         ;    DW 0x2000
38A6 2000  0917         DW    0x2000
           0918                         ;  #endasm
           0919                         ;  #pragma updateBank exit=UserBank_01
           0920                         ;}
38A7 0008  0921         RETURN
           0922                         ;
           0923                         ;#define setRFready_address  0x38a9
           0924                         ;#pragma origin setRFready_address
     0000  0925         ORG 0x38A9
           0926                         ;void setRFready()
           0927                         ;{
           0928 setRFready
           0929                         ;  #asm
           0930                         ;    DW 0x2000
38A9 2000  0931         DW    0x2000
           0932                         ;  #endasm
           0933                         ;  #pragma updateBank exit=UserBank_01
           0934                         ;}
38AA 0008  0935         RETURN
           0936                         ;
           0937                         ;#define RFTXpacket_address  0x38ac
           0938                         ;#pragma origin RFTXpacket_address
     0000  0939         ORG 0x38AC
           0940                         ;void RFTXpacket()
           0941                         ;{
           0942 RFTXpacket
           0943                         ;  #asm
           0944                         ;    DW 0x2000
38AC 2000  0945         DW    0x2000
           0946                         ;  #endasm
           0947                         ;  #pragma updateBank exit=UserBank_01
           0948                         ;}
38AD 0008  0949         RETURN
           0950                         ;
           0951                         ;#define RFRXpacket_address  0x38af
           0952                         ;#pragma origin RFRXpacket_address
     0000  0953         ORG 0x38AF
           0954                         ;bit RFRXpacket()
           0955                         ;{
           0956 RFRXpacket
           0957                         ;  #asm
           0958                         ;    DW 0x2000
38AF 2000  0959         DW    0x2000
           0960                         ;  #endasm
           0961                         ;  #pragma updateBank exit=UserBank_01
           0962                         ;  return Carry;
38B0 0008  0963         RETURN
           0964                         ;}
           0965                         ;
           0966                         ;#define checkRF_address 0x38b2
           0967                         ;#pragma origin checkRF_address
     0000  0968         ORG 0x38B2
           0969                         ;bit checkRF(uns8 level @ W)
           0970                         ;{
           0971 checkRF
           0972                         ;  #asm
           0973                         ;    DW 0x2000
38B2 2000  0974         DW    0x2000
           0975                         ;  #endasm
           0976                         ;  #pragma updateBank exit=UserBank_01
           0977                         ;  return Carry;
38B3 0008  0978         RETURN
           0979                         ;}
           0980                         ;
           0981                         ;#define amIBonded_address   0x38b8
           0982                         ;#pragma origin amIBonded_address
     0000  0983         ORG 0x38B8
           0984                         ;bit amIBonded()
           0985                         ;{
           0986 amIBonded
           0987                         ;  #asm
           0988                         ;    DW 0x2000
38B8 2000  0989         DW    0x2000
           0990                         ;  #endasm
           0991                         ;  #pragma updateBank exit=UserBank_01
           0992                         ;  return Carry;
38B9 0008  0993         RETURN
           0994                         ;}
           0995                         ;
           0996                         ;#define removeBond_address  0x38bb
           0997                         ;#pragma origin removeBond_address
     0000  0998         ORG 0x38BB
           0999                         ;void removeBond()
           1000                         ;{
           1001 removeBond
           1002                         ;  #asm
           1003                         ;    DW 0x2000
38BB 2000  1004         DW    0x2000
           1005                         ;  #endasm
           1006                         ;  #pragma updateBank exit=UserBank_01
           1007                         ;}
38BC 0008  1008         RETURN
           1009                         ;
           1010                         ;#define bondNewNode_address 0x38be
           1011                         ;#pragma origin bondNewNode_address
     0000  1012         ORG 0x38BE
           1013                         ;bit bondNewNode(uns8 address @ W)
           1014                         ;{
           1015 bondNewNode
           1016                         ;  #asm
           1017                         ;    DW 0x2000
38BE 2000  1018         DW    0x2000
           1019                         ;  #endasm
           1020                         ;  #pragma updateBank exit=UserBank_01
           1021                         ;  return Carry;
38BF 0008  1022         RETURN
           1023                         ;}
           1024                         ;
           1025                         ;#define isBondedNode_address    0x38c1
           1026                         ;#pragma origin isBondedNode_address
     0000  1027         ORG 0x38C1
           1028                         ;bit isBondedNode(uns8 address @ W)
           1029                         ;{
           1030 isBondedNode
           1031                         ;  #asm
           1032                         ;    DW 0x2000
38C1 2000  1033         DW    0x2000
           1034                         ;  #endasm
           1035                         ;  #pragma updateBank exit=UserBank_01
           1036                         ;  return Carry;
38C2 0008  1037         RETURN
           1038                         ;}
           1039                         ;
           1040                         ;#define removeBondedNode_address    0x38c4
           1041                         ;#pragma origin removeBondedNode_address
     0000  1042         ORG 0x38C4
           1043                         ;void removeBondedNode(uns8 address @ W)
           1044                         ;{
           1045 removeBondedNode
           1046                         ;  #asm
           1047                         ;    DW 0x2000
38C4 2000  1048         DW    0x2000
           1049                         ;  #endasm
           1050                         ;  #pragma updateBank exit=UserBank_01
           1051                         ;}
38C5 0008  1052         RETURN
           1053                         ;
           1054                         ;#define rebondNode_address  0x38c7
           1055                         ;#pragma origin rebondNode_address
     0000  1056         ORG 0x38C7
           1057                         ;bit rebondNode(uns8 address @ W)
           1058                         ;{
           1059 rebondNode
           1060                         ;  #asm
           1061                         ;    DW 0x2000
38C7 2000  1062         DW    0x2000
           1063                         ;  #endasm
           1064                         ;  #pragma updateBank exit=UserBank_01
           1065                         ;  return Carry;
38C8 0008  1066         RETURN
           1067                         ;}
           1068                         ;
           1069                         ;#define clearAllBonds_address   0x38ca
           1070                         ;#pragma origin clearAllBonds_address
     0000  1071         ORG 0x38CA
           1072                         ;void clearAllBonds()
           1073                         ;{
           1074 clearAllBonds
           1075                         ;  #asm
           1076                         ;    DW 0x2000
38CA 2000  1077         DW    0x2000
           1078                         ;  #endasm
           1079                         ;  #pragma updateBank exit=UserBank_01
           1080                         ;}
38CB 0008  1081         RETURN
           1082                         ;
           1083                         ;#define setNonetMode_address    0x38cd
           1084                         ;#pragma origin setNonetMode_address
     0000  1085         ORG 0x38CD
           1086                         ;void setNonetMode()
           1087                         ;{
           1088 setNonetMode
           1089                         ;  #asm
           1090                         ;    DW 0x2000
38CD 2000  1091         DW    0x2000
           1092                         ;  #endasm
           1093                         ;  #pragma updateBank exit=UserBank_01
           1094                         ;}
38CE 0008  1095         RETURN
           1096                         ;
           1097                         ;#define setCoordinatorMode_address  0x38d0
           1098                         ;#pragma origin setCoordinatorMode_address
     0000  1099         ORG 0x38D0
           1100                         ;void setCoordinatorMode()
           1101                         ;{
           1102 setCoordinatorMode
           1103                         ;  #asm
           1104                         ;    DW 0x2000
38D0 2000  1105         DW    0x2000
           1106                         ;  #endasm
           1107                         ;  #pragma updateBank exit=UserBank_01
           1108                         ;}
38D1 0008  1109         RETURN
           1110                         ;
           1111                         ;#define setNodeMode_address 0x38d3
           1112                         ;#pragma origin setNodeMode_address
     0000  1113         ORG 0x38D3
           1114                         ;void setNodeMode()
           1115                         ;{
           1116 setNodeMode
           1117                         ;  #asm
           1118                         ;    DW 0x2000
38D3 2000  1119         DW    0x2000
           1120                         ;  #endasm
           1121                         ;  #pragma updateBank exit=UserBank_01
           1122                         ;}
38D4 0008  1123         RETURN
           1124                         ;
           1125                         ;#define setNetworkFilteringOn_address   0x38d6
           1126                         ;#pragma origin setNetworkFilteringOn_address
     0000  1127         ORG 0x38D6
           1128                         ;void setNetworkFilteringOn()
           1129                         ;{
           1130 setNetworkFilteringOn
           1131                         ;  #asm
           1132                         ;    DW 0x2000
38D6 2000  1133         DW    0x2000
           1134                         ;  #endasm
           1135                         ;  #pragma updateBank exit=UserBank_01
           1136                         ;}
38D7 0008  1137         RETURN
           1138                         ;
           1139                         ;#define setNetworkFilteringOff_address  0x38d9
           1140                         ;#pragma origin setNetworkFilteringOff_address
     0000  1141         ORG 0x38D9
           1142                         ;void setNetworkFilteringOff()
           1143                         ;{
           1144 setNetworkFilteringOff
           1145                         ;  #asm
           1146                         ;    DW 0x2000
38D9 2000  1147         DW    0x2000
           1148                         ;  #endasm
           1149                         ;  #pragma updateBank exit=UserBank_01
           1150                         ;}
38DA 0008  1151         RETURN
           1152                         ;
           1153                         ;#define getNetworkParams_address    0x38dc
           1154                         ;#pragma origin getNetworkParams_address
     0000  1155         ORG 0x38DC
           1156                         ;uns8 getNetworkParams()
           1157                         ;{
           1158 getNetworkParams
           1159                         ;  #asm
           1160                         ;    DW 0x2000
38DC 2000  1161         DW    0x2000
           1162                         ;  #endasm
           1163                         ;  #pragma updateBank exit=UserBank_01
           1164                         ;  return W;
38DD 0008  1165         RETURN
           1166                         ;}
           1167                         ;
           1168                         ;#define setRoutingOn_address    0x38df
           1169                         ;#pragma origin setRoutingOn_address
     0000  1170         ORG 0x38DF
           1171                         ;void setRoutingOn()
           1172                         ;{
           1173 setRoutingOn
           1174                         ;  #asm
           1175                         ;    DW 0x2000
38DF 2000  1176         DW    0x2000
           1177                         ;  #endasm
           1178                         ;  #pragma updateBank exit=UserBank_01
           1179                         ;}
38E0 0008  1180         RETURN
           1181                         ;
           1182                         ;#define setRoutingOff_address   0x38e2
           1183                         ;#pragma origin setRoutingOff_address
     0000  1184         ORG 0x38E2
           1185                         ;void setRoutingOff()
           1186                         ;{
           1187 setRoutingOff
           1188                         ;  #asm
           1189                         ;    DW 0x2000
38E2 2000  1190         DW    0x2000
           1191                         ;  #endasm
           1192                         ;  #pragma updateBank exit=UserBank_01
           1193                         ;}
38E3 0008  1194         RETURN
           1195                         ;
           1196                         ;#define answerSystemPacket_address  0x38e8
           1197                         ;#pragma origin answerSystemPacket_address
     0000  1198         ORG 0x38E8
           1199                         ;void answerSystemPacket()
           1200                         ;{
           1201 answerSystemPacket
           1202                         ;  #asm
           1203                         ;    DW 0x2000
38E8 2000  1204         DW    0x2000
           1205                         ;  #endasm
           1206                         ;  #pragma updateBank exit=UserBank_01
           1207                         ;}
38E9 0008  1208         RETURN
           1209                         ;
           1210                         ;#define discovery_address   0x38eb
           1211                         ;#pragma origin discovery_address
     0000  1212         ORG 0x38EB
           1213                         ;uns8 discovery(uns8 MaxNodeAddress @ W)
           1214                         ;{
           1215 discovery
           1216                         ;  #asm
           1217                         ;    DW 0x2000
38EB 2000  1218         DW    0x2000
           1219                         ;  #endasm
           1220                         ;  #pragma updateBank exit=UserBank_01
           1221                         ;  return W;
38EC 0008  1222         RETURN
           1223                         ;}
           1224                         ;
           1225                         ;#define wasRouted_address   0x38ee
           1226                         ;#pragma origin wasRouted_address
     0000  1227         ORG 0x38EE
           1228                         ;bit wasRouted()
           1229                         ;{
           1230 wasRouted
           1231                         ;  #asm
           1232                         ;    DW 0x2000
38EE 2000  1233         DW    0x2000
           1234                         ;  #endasm
           1235                         ;  #pragma updateBank exit=UserBank_01
           1236                         ;  return Carry;
38EF 0008  1237         RETURN
           1238                         ;}
           1239                         ;
           1240                         ;#define optimizeHops_address    0x38f1
           1241                         ;#pragma origin optimizeHops_address
     0000  1242         ORG 0x38F1
           1243                         ;bit optimizeHops(uns8 method @ W)
           1244                         ;{
           1245 optimizeHops
           1246                         ;  #asm
           1247                         ;    DW 0x2000
38F1 2000  1248         DW    0x2000
           1249                         ;  #endasm
           1250                         ;  #pragma updateBank exit=UserBank_01
           1251                         ;  return Carry;
38F2 0008  1252         RETURN
           1253                         ;}
           1254                         ;
           1255                         ;#define getSupplyVoltage_address    0x38f4
           1256                         ;#pragma origin getSupplyVoltage_address
     0000  1257         ORG 0x38F4
           1258                         ;uns8 getSupplyVoltage()
           1259                         ;{
           1260 getSupplyVoltage
           1261                         ;  #asm
           1262                         ;    DW 0x2000
38F4 2000  1263         DW    0x2000
           1264                         ;  #endasm
           1265                         ;  #pragma updateBank exit=UserBank_01
           1266                         ;  return W;
38F5 0008  1267         RETURN
           1268                         ;}
           1269                         ;
           1270                         ;#define getTemperature_address  0x38f7
           1271                         ;#pragma origin getTemperature_address
     0000  1272         ORG 0x38F7
           1273                         ;int8 getTemperature()
           1274                         ;{
           1275 getTemperature
           1276                         ;  #asm
           1277                         ;    DW 0x2000
38F7 2000  1278         DW    0x2000
           1279                         ;  #endasm
           1280                         ;  #pragma updateBank exit=UserBank_01
           1281                         ;  return W;
38F8 0008  1282         RETURN
           1283                         ;}
           1284                         ;
           1285                         ;#define clearBufferRF_address   0x38fa
           1286                         ;#pragma origin clearBufferRF_address
     0000  1287         ORG 0x38FA
           1288                         ;void clearBufferRF()
           1289                         ;{
           1290 clearBufferRF
           1291                         ;  #asm
           1292                         ;    DW 0x2000
38FA 2000  1293         DW    0x2000
           1294                         ;  #endasm
           1295                         ;  #pragma updateBank exit=UserBank_01
           1296                         ;}
38FB 0008  1297         RETURN
           1298                         ;
           1299                         ;#define isDiscoveredNode_address    0x3910
           1300                         ;#pragma origin isDiscoveredNode_address
     0000  1301         ORG 0x3910
           1302                         ;bit isDiscoveredNode(uns8 address @ W)
           1303                         ;{
           1304 isDiscoveredNode
           1305                         ;  #asm
           1306                         ;    DW 0x2000
3910 2000  1307         DW    0x2000
           1308                         ;  #endasm
           1309                         ;  #pragma updateBank exit=UserBank_01
           1310                         ;  return Carry;
3911 0008  1311         RETURN
           1312                         ;}
           1313                         ;
           1314                         ;#define enableRFPGM_address 0x3913
           1315                         ;#pragma origin enableRFPGM_address
     0000  1316         ORG 0x3913
           1317                         ;void enableRFPGM()
           1318                         ;{
           1319 enableRFPGM
           1320                         ;  #asm
           1321                         ;    DW 0x2000
3913 2000  1322         DW    0x2000
           1323                         ;  #endasm
           1324                         ;  #pragma updateBank exit=UserBank_01
           1325                         ;}
3914 0008  1326         RETURN
           1327                         ;
           1328                         ;#define disableRFPGM_address    0x3916
           1329                         ;#pragma origin disableRFPGM_address
     0000  1330         ORG 0x3916
           1331                         ;void disableRFPGM()
           1332                         ;{
           1333 disableRFPGM
           1334                         ;  #asm
           1335                         ;    DW 0x2000
3916 2000  1336         DW    0x2000
           1337                         ;  #endasm
           1338                         ;  #pragma updateBank exit=UserBank_01
           1339                         ;}
3917 0008  1340         RETURN
           1341                         ;
           1342                         ;#define setupRFPGM_address  0x3919
           1343                         ;#pragma origin setupRFPGM_address
     0000  1344         ORG 0x3919
           1345                         ;void setupRFPGM(uns8 x @ W)
           1346                         ;{
           1347 setupRFPGM
           1348                         ;  #asm
           1349                         ;    DW 0x2000
3919 2000  1350         DW    0x2000
           1351                         ;  #endasm
           1352                         ;  #pragma updateBank exit=UserBank_01
           1353                         ;}
391A 0008  1354         RETURN
           1355                         ;
           1356                         ;#define runRFPGM_address    0x391c
           1357                         ;#pragma origin runRFPGM_address
     0000  1358         ORG 0x391C
           1359                         ;void runRFPGM()
           1360                         ;{
           1361 runRFPGM
           1362                         ;  #asm
           1363                         ;    DW 0x2000
391C 2000  1364         DW    0x2000
           1365                         ;  #endasm
           1366                         ;  #pragma updateBank exit=UserBank_01
           1367                         ;}
391D 0008  1368         RETURN
           1369                         ;
           1370                         ;#define iqrfDeepSleep_address   0x391f
           1371                         ;#pragma origin iqrfDeepSleep_address
     0000  1372         ORG 0x391F
           1373                         ;void iqrfDeepSleep()
           1374                         ;{
           1375 iqrfDeepSleep
           1376                         ;  #asm
           1377                         ;    DW 0x2000
391F 2000  1378         DW    0x2000
           1379                         ;  #endasm
           1380                         ;  #pragma updateBank exit=UserBank_01
           1381                         ;}
3920 0008  1382         RETURN
           1383                         ;
           1384                         ;#define wasRFICrestarted_address    0x3922
           1385                         ;#pragma origin wasRFICrestarted_address
     0000  1386         ORG 0x3922
           1387                         ;#if !defined( TR7xD )
           1388                         ;    bit wasRFICrestarted()
           1389                         ;    {
           1390 wasRFICrestarted
           1391                         ;      #asm
           1392                         ;        DW 0x2000
3922 2000  1393         DW    0x2000
           1394                         ;      #endasm
           1395                         ;      #pragma updateBank exit=UserBank_01
           1396                         ;      return Carry;
3923 0008  1397         RETURN
           1398                         ;    }
           1399                         ;#else
           1400                         ;    uns8 wasRFICrestarted()
           1401                         ;    {
           1402                         ;      #asm
           1403                         ;        DW 0x2000
           1404                         ;      #endasm
           1405                         ;      #pragma updateBank exit=UserBank_01
           1406                         ;      return W;
           1407                         ;    }
           1408                         ;#endif
           1409                         ;
           1410                         ;#define eeeWriteData_address    0x3925
           1411                         ;#pragma origin eeeWriteData_address
     0000  1412         ORG 0x3925
           1413                         ;bit eeeWriteData(uns16 address @ param3)
           1414                         ;{
           1415 eeeWriteData
           1416                         ;  #asm
           1417                         ;    DW 0x2000
3925 2000  1418         DW    0x2000
           1419                         ;  #endasm
           1420                         ;  #pragma updateBank exit=UserBank_01
           1421                         ;  return Carry;
3926 0008  1422         RETURN
           1423                         ;}
           1424                         ;
           1425                         ;#define eeeReadData_address 0x3928
           1426                         ;#pragma origin eeeReadData_address
     0000  1427         ORG 0x3928
           1428                         ;bit eeeReadData(uns16 address @ param3)
           1429                         ;{
           1430 eeeReadData
           1431                         ;  #asm
           1432                         ;    DW 0x2000
3928 2000  1433         DW    0x2000
           1434                         ;  #endasm
           1435                         ;  #pragma updateBank exit=UserBank_01
           1436                         ;  return Carry;
3929 0008  1437         RETURN
           1438                         ;}
           1439                         ;
           1440                         ;#define setINDF0_address    0x3931
           1441                         ;#pragma origin setINDF0_address
     0000  1442         ORG 0x3931
           1443                         ;void setINDF0(uns8 value @ W)
           1444                         ;{
           1445 setINDF0
           1446                         ;  #asm
           1447                         ;    DW 0x2000
3931 2000  1448         DW    0x2000
           1449                         ;  #endasm
           1450                         ;  #pragma updateBank exit=UserBank_01
           1451                         ;}
3932 0008  1452         RETURN
           1453                         ;
           1454                         ;#define setINDF1_address    0x3934
           1455                         ;#pragma origin setINDF1_address
     0000  1456         ORG 0x3934
           1457                         ;void setINDF1(uns8 value @ W)
           1458                         ;{
           1459 setINDF1
           1460                         ;  #asm
           1461                         ;    DW 0x2000
3934 2000  1462         DW    0x2000
           1463                         ;  #endasm
           1464                         ;  #pragma updateBank exit=UserBank_01
           1465                         ;}
3935 0008  1466         RETURN
           1467                         ;
           1468                         ;#define getRSSI_address 0x3937
           1469                         ;#pragma origin getRSSI_address
     0000  1470         ORG 0x3937
           1471                         ;uns8 getRSSI()
           1472                         ;{
           1473 getRSSI
           1474                         ;  #asm
           1475                         ;    DW 0x2000
3937 2000  1476         DW    0x2000
           1477                         ;  #endasm
           1478                         ;  #pragma updateBank exit=UserBank_01
           1479                         ;  return W;
3938 0008  1480         RETURN
           1481                         ;}
           1482                         ;
           1483                         ;#define removeBondAddress_address   0x393a
           1484                         ;#pragma origin removeBondAddress_address
     0000  1485         ORG 0x393A
           1486                         ;void removeBondAddress()
           1487                         ;{
           1488 removeBondAddress
           1489                         ;  #asm
           1490                         ;    DW 0x2000
393A 2000  1491         DW    0x2000
           1492                         ;  #endasm
           1493                         ;  #pragma updateBank exit=UserBank_01
           1494                         ;}
393B 0008  1495         RETURN
           1496                         ;
           1497                         ;#define sendFRC_address 0x393d
           1498                         ;#pragma origin sendFRC_address
     0000  1499         ORG 0x393D
           1500                         ;uns8 sendFRC(uns8 command @ W)
           1501                         ;{
           1502 sendFRC
           1503                         ;  #asm
           1504                         ;    DW 0x2000
393D 2000  1505         DW    0x2000
           1506                         ;  #endasm
           1507                         ;  #pragma updateBank exit=UserBank_01
           1508                         ;  return W;
393E 0008  1509         RETURN
           1510                         ;}
           1511                         ;
           1512                         ;#define responseFRC_address 0x3940
           1513                         ;#pragma origin responseFRC_address
     0000  1514         ORG 0x3940
           1515                         ;void responseFRC()
           1516                         ;{
           1517 responseFRC
           1518                         ;  #asm
           1519                         ;    DW 0x2000
3940 2000  1520         DW    0x2000
           1521                         ;  #endasm
           1522                         ;  #pragma updateBank exit=UserBank_01
           1523                         ;}
3941 0008  1524         RETURN
           1525                         ;
           1526                         ;#define bondRequestAdvanced_address 0x3943
           1527                         ;#pragma origin bondRequestAdvanced_address
     0000  1528         ORG 0x3943
           1529                         ;bit bondRequestAdvanced()
           1530                         ;{
           1531 bondRequestAdvanced
           1532                         ;  #asm
           1533                         ;    DW 0x2000
3943 2000  1534         DW    0x2000
           1535                         ;  #endasm
           1536                         ;  #pragma updateBank exit=UserBank_01
           1537                         ;  return Carry;
3944 0008  1538         RETURN
           1539                         ;}
           1540                         ;
           1541                         ;#define prebondNodeAtNode_address   0x3946
           1542                         ;#pragma origin prebondNodeAtNode_address
     0000  1543         ORG 0x3946
           1544                         ;bit prebondNodeAtNode()
           1545                         ;{
           1546 prebondNodeAtNode
           1547                         ;  #asm
           1548                         ;    DW 0x2000
3946 2000  1549         DW    0x2000
           1550                         ;  #endasm
           1551                         ;  #pragma updateBank exit=UserBank_01
           1552                         ;  return Carry;
3947 0008  1553         RETURN
           1554                         ;}
           1555                         ;
           1556                         ;#define nodeAuthorization_address   0x3949
           1557                         ;#pragma origin nodeAuthorization_address
     0000  1558         ORG 0x3949
           1559                         ;bit nodeAuthorization(uns8 address @ W)
           1560                         ;{
           1561 nodeAuthorization
           1562                         ;  #asm
           1563                         ;    DW 0x2000
3949 2000  1564         DW    0x2000
           1565                         ;  #endasm
           1566                         ;  #pragma updateBank exit=UserBank_01
           1567                         ;  return Carry;
394A 0008  1568         RETURN
           1569                         ;}
           1570                         ;
           1571                         ;#define dummy01_address 0x394c
           1572                         ;#pragma origin dummy01_address
     0000  1573         ORG 0x394C
           1574                         ;void dummy01()
           1575                         ;{
           1576 dummy01
           1577                         ;  #asm
           1578                         ;  DW 0x2000
394C 2000  1579         DW    0x2000
           1580                         ;  #endasm
           1581                         ;  #pragma updateBank exit=UserBank_01
           1582                         ;}
394D 0008  1583         RETURN
           1584                         ;
           1585                         ;#define setAccessPassword_address   0x3958
           1586                         ;#pragma origin setAccessPassword_address
     0000  1587         ORG 0x3958
           1588                         ;void setAccessPassword()
           1589                         ;{
           1590 setAccessPassword
           1591                         ;  #asm
           1592                         ;    DW 0x2000
3958 2000  1593         DW    0x2000
           1594                         ;  #endasm
           1595                         ;  #pragma updateBank exit=UserBank_01
           1596                         ;}
3959 0008  1597         RETURN
           1598                         ;
           1599                         ;#define setUserKey_address  0x395b
           1600                         ;#pragma origin setUserKey_address
     0000  1601         ORG 0x395B
           1602                         ;void setUserKey()
           1603                         ;{
           1604 setUserKey
           1605                         ;  #asm
           1606                         ;    DW 0x2000
395B 2000  1607         DW    0x2000
           1608                         ;  #endasm
           1609                         ;  #pragma updateBank exit=UserBank_01
           1610                         ;}
395C 0008  1611         RETURN
           1612                         ;
           1613                         ;#define amIRecipientOfFRC_address   0x3961
           1614                         ;#pragma origin amIRecipientOfFRC_address
     0000  1615         ORG 0x3961
           1616                         ;bit amIRecipientOfFRC()
           1617                         ;{
           1618 amIRecipientOfFRC
           1619                         ;  #asm
           1620                         ;    DW 0x2000
3961 2000  1621         DW    0x2000
           1622                         ;  #endasm
           1623                         ;  #pragma updateBank exit=UserBank_01
           1624                         ;  return Carry;
3962 0008  1625         RETURN
           1626                         ;}
           1627                         ;
           1628                         ;#define setLEDR_address 0x3964
           1629                         ;#pragma origin setLEDR_address
     0000  1630         ORG 0x3964
           1631                         ;void setLEDR()
           1632                         ;{
           1633 setLEDR
           1634                         ;  #asm
           1635                         ;    DW 0x2000
3964 2000  1636         DW    0x2000
           1637                         ;  #endasm
           1638                         ;  #pragma updateBank exit=UserBank_01
           1639                         ;}
3965 0008  1640         RETURN
           1641                         ;
           1642                         ;#define encryptBufferRF_address 0x3967
           1643                         ;#pragma origin encryptBufferRF_address
     0000  1644         ORG 0x3967
           1645                         ;void encryptBufferRF(uns8 blocks @ W)
           1646                         ;{
           1647 encryptBufferRF
           1648                         ;  #asm
           1649                         ;    DW 0x2000
3967 2000  1650         DW    0x2000
           1651                         ;  #endasm
           1652                         ;  #pragma updateBank exit=UserBank_01
           1653                         ;}
3968 0008  1654         RETURN
           1655                         ;
           1656                         ;#define decryptBufferRF_address 0x396a
           1657                         ;#pragma origin decryptBufferRF_address
     0000  1658         ORG 0x396A
           1659                         ;void decryptBufferRF(uns8 blocks @ W)
           1660                         ;{
           1661 decryptBufferRF
           1662                         ;  #asm
           1663                         ;    DW 0x2000
396A 2000  1664         DW    0x2000
           1665                         ;  #endasm
           1666                         ;  #pragma updateBank exit=UserBank_01
           1667                         ;}
396B 0008  1668         RETURN
           1669                         ;
           1670                         ;#define prebondNodeAtCoordinator_address    0x396d
           1671                         ;#pragma origin prebondNodeAtCoordinator_address
     0000  1672         ORG 0x396D
           1673                         ;bit prebondNodeAtCoordinator(uns8 address @ W)
           1674                         ;{
           1675 prebondNodeAtCoordinator
           1676                         ;  #asm
           1677                         ;    DW 0x2000
396D 2000  1678         DW    0x2000
           1679                         ;  #endasm
           1680                         ;  #pragma updateBank exit=UserBank_01
           1681                         ;  return Carry;
396E 0008  1682         RETURN
           1683                         ;}
           1684                         ;
           1685                         ;#define setFSRs_address 0x3970
           1686                         ;#pragma origin setFSRs_address
     0000  1687         ORG 0x3970
           1688                         ;uns8 setFSRs(uns8 fsrs @ W)
           1689                         ;{
           1690 setFSRs
           1691                         ;  #asm
           1692                         ;    DW 0x2000
3970 2000  1693         DW    0x2000
           1694                         ;  #endasm
           1695                         ;  #pragma updateBank exit=UserBank_01
           1696                         ;  return W;
3971 0008  1697         RETURN
           1698                         ;}
           1699                         ;
           1700                         ;// For internal usage only
           1701                         ;#define updateCRC16_address 0x3973
           1702                         ;#pragma origin updateCRC16_address
     0000  1703         ORG 0x3973
           1704                         ;void updateCRC16(uns8 value @ W)
           1705                         ;{
           1706 updateCRC16
           1707                         ;  #asm
           1708                         ;    DW 0x2000
3973 2000  1709         DW    0x2000
           1710                         ;  #endasm
           1711                         ;  #pragma updateBank exit=UserBank_01
           1712                         ;}
3974 0008  1713         RETURN
           1714                         ;
           1715                         ;#define smartConnect_address    0x3976
           1716                         ;#pragma origin smartConnect_address
     0000  1717         ORG 0x3976
           1718                         ;bit smartConnect(uns8 address @ W)
           1719                         ;{
           1720 smartConnect
           1721                         ;  #asm
           1722                         ;    DW 0x2000
3976 2000  1723         DW    0x2000
           1724                         ;  #endasm
           1725                         ;  #pragma updateBank exit=UserBank_01
           1726                         ;  return Carry;
3977 0008  1727         RETURN
           1728                         ;}
           1729                         ;
           1730                         ;#define addressBitmap_address   0x3979
           1731                         ;#pragma origin addressBitmap_address
     0000  1732         ORG 0x3979
           1733                         ;uns8 addressBitmap(uns8 bitIndex @ W)
           1734                         ;{
           1735 addressBitmap
           1736                         ;  #asm
           1737                         ;    DW 0x2000
3979 2000  1738         DW    0x2000
           1739                         ;  #endasm
           1740                         ;  #pragma updateBank exit=UserBank_01
           1741                         ;  return W;
397A 0008  1742         RETURN
           1743                         ;}
           1744                         ;
           1745                         ;#define setServiceChannel_address   0x397c
           1746                         ;#pragma origin setServiceChannel_address
     0000  1747         ORG 0x397C
           1748                         ;bit setServiceChannel(uns8 channelNumber @ W)
           1749                         ;{
           1750 setServiceChannel
           1751                         ;  #asm
           1752                         ;    DW 0x2000
397C 2000  1753         DW    0x2000
           1754                         ;  #endasm
           1755                         ;  #pragma updateBank exit=UserBank_01
           1756                         ;  return Carry;
397D 0008  1757         RETURN
           1758                         ;}
           1759                         ;
           1760                         ;#pragma optimize 1
           1761                         ;#pragma update_RP 1
           1762                         ;#pragma update_PAGE 1
           1763                         ;#pragma origin __APPLICATION_ADDRESS
     0000  1764         ORG 0x3A00
           1765 
           1766   ; FILE C:\makieta-miasta-iqrf\DPA.h
           1767                         ;// *********************************************************************
           1768                         ;//   General public DPA header file                                    *
           1769                         ;// *********************************************************************
           1770                         ;// Copyright (c) MICRORISC s.r.o.
           1771                         ;//
           1772                         ;// File:    $RCSfile: DPA.h,v $
           1773                         ;// Version: $Revision: 1.329 $
           1774                         ;// Date:    $Date: 2024/12/05 09:28:57 $
           1775                         ;//
           1776                         ;// Revision history:
           1777                         ;//   2024/11/05  Release for DPA 4.32
           1778                         ;//   2024/04/17  Release for DPA 4.31
           1779                         ;//   2023/03/07  Release for DPA 4.30
           1780                         ;//   2022/10/05  Release for DPA 4.18
           1781                         ;//   2022/02/24  Release for DPA 4.17
           1782                         ;//   2021/08/20  Release for DPA 4.16
           1783                         ;//   2020/09/03  Release for DPA 4.15
           1784                         ;//   2020/04/03  Release for DPA 4.14
           1785                         ;//   2020/02/27  Release for DPA 4.13
           1786                         ;//   2020/01/09  Release for DPA 4.12
           1787                         ;//   2019/12/11  Release for DPA 4.11
           1788                         ;//   2019/10/09  Release for DPA 4.10
           1789                         ;//   2019/06/12  Release for DPA 4.03
           1790                         ;//   2019/06/03  Release for DPA 4.02
           1791                         ;//   2019/03/07  Release for DPA 4.01
           1792                         ;//   2019/01/10  Release for DPA 4.00
           1793                         ;//   2018/10/25  Release for DPA 3.03
           1794                         ;//   2017/11/16  Release for DPA 3.02
           1795                         ;//   2017/08/14  Release for DPA 3.01
           1796                         ;//   2017/03/13  Release for DPA 3.00
           1797                         ;//   2016/09/12  Release for DPA 2.28
           1798                         ;//   2016/04/14  Release for DPA 2.27
           1799                         ;//   2016/03/03  Release for DPA 2.26
           1800                         ;//   2016/01/21  Release for DPA 2.25
           1801                         ;//   2015/12/01  Release for DPA 2.24
           1802                         ;//   2015/10/23  Release for DPA 2.23
           1803                         ;//   2015/09/25  Release for DPA 2.22
           1804                         ;//   2015/09/03  Release for DPA 2.21
           1805                         ;//   2015/08/05  Release for DPA 2.20
           1806                         ;//   2014/10/31  Release for DPA 2.10
           1807                         ;//   2014/04/30  Release for DPA 2.00
           1808                         ;//   2013/10/03  Release for DPA 1.00
           1809                         ;//
           1810                         ;// *********************************************************************
           1811                         ;
           1812                         ;// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
           1813                         ;// IQRF Standards documentation https://doc.iqrf.org/
           1814                         ;
           1815                         ;#ifndef _DPA_HEADER_
           1816                         ;#define _DPA_HEADER_
           1817                         ;
           1818                         ;//############################################################################################
           1819                         ;
           1820                         ;// DPA version
           1821                         ;#define DPA_VERSION_MASTER          0x0432
           1822                         ;
           1823                         ;#if defined( __CC5X__ ) && !defined( CC5XnotDPA )
           1824                         ;// Compiled only at CC5X
           1825                         ;#if __CC5X__ < 3800
           1826                         ;#error Insufficient CC5X compiler version, V3.8 is minimum
           1827                         ;#endif
           1828                         ;
           1829                         ;#if IQRFOS < 406
           1830                         ;#error IQRF OS 4.06+ is required
           1831                         ;#endif
           1832                         ;
           1833                         ;// Bank for custom variables
           1834                         ;#pragma rambank = UserBank_01
           1835                         ;
           1836                         ;// Main DPA API entry address (also start of the licensed FLASH)
           1837                         ;#define DPA_API_ADDRESS             __LICENSED_FLASH
           1838                         ;
           1839                         ;// Main DPA entry address
           1840                         ;#define MAIN_DPA_ADDRESS            ( DPA_API_ADDRESS + 4 )
           1841                         ;
           1842                         ;// Main DPA API entry address stub
           1843                         ;#define DPA_API_ADDRESS_ENTRY       0x3A08
           1844                         ;
           1845                         ;// Address of the DPA Custom Handler
           1846                         ;#define CUSTOM_HANDLER_ADDRESS      0x3A20
           1847                         ;
           1848                         ;// Address of the DPA Custom Handler end + 1
           1849                         ;#if defined TR7xD
           1850                         ;#define CUSTOM_HANDLER_ADDRESS_END  0x3D80
           1851                         ;#else
           1852                         ;#define CUSTOM_HANDLER_ADDRESS_END  __USER_INTERRUPT
           1853                         ;#endif
           1854                         ;
           1855                         ;// DPA API entry function
           1856                         ;uns8  DpaApiEntry( uns8 par1, uns8 par2, uns8 apiIndex );
           1857                         ;
           1858                         ;// DPA API codes
           1859                         ;#define DPA_API_RFTX_DPAPACKET              0
           1860                         ;#define DPA_API_READ_CONFIG_BYTE            1
           1861                         ;#define DPA_API_SEND_TO_IFACEMASTER         2
           1862                         ;#define DPA_API_COORDINATOR_RFTX_DPAPACKET  3
           1863                         ;#define DPA_API_LOCAL_REQUEST               4
           1864                         ;#define DPA_API_SET_PERIPHERAL_ERROR        5
           1865                         ;#define DPA_API_SET_RF_DEFAULTS             6
           1866                         ;#define DPA_API_LOCAL_FRC                   7
           1867                         ;#define DPA_API_CRC8                        8
           1868                         ;#define DPA_API_AGGREGATE_FRC               9
           1869                         ;#define DPA_API_SET_OTK                     10
           1870                         ;#define DPA_API_I2C_INIT                    11
           1871                         ;#define DPA_API_I2C_START                   12
           1872                         ;#define DPA_API_I2C_WRITE                   13
           1873                         ;#define DPA_API_I2C_READ                    14
           1874                         ;#define DPA_API_I2C_STOP                    15
           1875                         ;#define DPA_API_I2C_WAIT_FOR_ACK            16
           1876                         ;#define DPA_API_I2C_SHUTDOWN                17
           1877                         ;#define DPA_API_I2C_WAIT_FOR_IDLE           18
           1878                         ;#define DPA_API_SLEEP                       19
           1879                         ;#define DPA_API_AFTER_SLEEP                 20
           1880                         ;#define DPA_API_RANDOM                      21
           1881                         ;#if !defined( TR7xD )
           1882                         ;#define DPA_API_MENU                        22
           1883                         ;#define DPA_API_MENU_INDICATE_RESULT        23
           1884                         ;#define DPA_API_MENU_EXECUTE                24
           1885                         ;#define DPA_API_DEEP_SLEEP                  25
           1886                         ;#endif
           1887                         ;
           1888                         ;// Used buffer size symbols
           1889                         ;#define sizeofBufferRF                      sizeof( bufferRF )
           1890                         ;#define sizeofBufferAUX                     sizeof( bufferAUX )
           1891                         ;#define sizeofBufferCOM                     sizeof( bufferCOM )
           1892                         ;#define sizeofBufferINFO                    sizeof( bufferINFO )
           1893                         ;
           1894                         ;// Converts conventional address to the linear one at PIC16LF1938
           1895                         ;// Note: This is workaround of CC5X preprocessor bug "No '#endif' detected"
           1896                         ;#define error_ #error Address cannot be linearized
           1897                         ;#define LINEARIZE_ADDRESS( a ) \
           1898                         ;#if ( ((uns16)(a)) - ( ((uns16)(a)) / 0x80 ) * 0x80 ) >= 0x20 && ( ((uns16)(a)) - ( ((uns16)(a)) / 0x80 ) * 0x80 ) <= 0x6F && ( ((uns16)(a)) / 0x80 ) <= 12 \
           1899                         ;( ( ( ((uns16)(a)) / 0x80 ) * 0x50 ) + ( ((uns16)(a)) - 0x20 - ( ((uns16)(a)) / 0x80 ) * 0x80 ) + 0x2000 ) \
           1900                         ;#else \
           1901                         ;error_ \
           1902                         ;#endif
           1903                         ;#undef error_
           1904                         ;
           1905                         ;#define STRUCTATTR
           1906                         ;
           1907                         ;#else //__CC5X__
           1908                         ;// Not compiled at CC5X
           1909                         ;
           1910                         ;#if !defined( CC5XnotDPA )
           1911                         ;// Define CC5X types
           1912                         ;typedef int8_t    int8;
           1913                         ;typedef int16_t   int16;
           1914                         ;typedef uint8_t   uns8;
           1915                         ;typedef uint16_t  uns16;
           1916                         ;// Disables alignment of members of structures
           1917                         ;#define STRUCTATTR  __attribute__((packed))
           1918                         ;#else
           1919                         ;#define STRUCTATTR
           1920                         ;#endif
           1921                         ;
           1922                         ;// Fake buffer sizes
           1923                         ;#define sizeofBufferRF    64
           1924                         ;#define sizeofBufferAUX   64
           1925                         ;#define sizeofBufferCOM   64
           1926                         ;#define sizeofBufferINFO  64
           1927                         ;
           1928                         ;#endif  // __CC5X__
           1929                         ;
           1930                         ;// Indexes of configuration bytes used by DpaApiReadConfigByte( index )
           1931                         ;// Checksum
           1932                         ;#define CFGIND_CHECKSUM         0x00
           1933                         ;// Embedded peripherals
           1934                         ;#define CFGIND_DPA_PERIPHERALS  0x01
           1935                         ;// DPA configuration flags #0
           1936                         ;#define CFGIND_DPA_FLAGS0       0x05
           1937                         ;// Main RF channel, used by the subordinate network
           1938                         ;#define CFGIND_CHANNEL_2ND_A    0x06
           1939                         ;// Second RF channel, used by the subordinate network
           1940                         ;#define CFGIND_CHANNEL_2ND_B    0x07
           1941                         ;// TX power
           1942                         ;#define CFGIND_TXPOWER          0x08
           1943                         ;// RX filter used by checkRF()
           1944                         ;#define CFGIND_RXFILTER         0x09
           1945                         ;// toutRF for LP mode
           1946                         ;#define CFGIND_DPA_LP_TOUTRF    0x0A
           1947                         ;// UART interface baud rate
           1948                         ;#define CFGIND_DPA_UART_IFACE_SPEED 0x0B
           1949                         ;// Alternate DSM channel
           1950                         ;#define CFGIND_ALTERNATE_DSM_CHANNEL 0x0C
           1951                         ;// DPA configuration flags #1
           1952                         ;#define CFGIND_DPA_FLAGS1       0x0D
           1953                         ;// Main RF channel
           1954                         ;#define CFGIND_CHANNEL_A        0x11
           1955                         ;// Second RF channel
           1956                         ;#define CFGIND_CHANNEL_B        0x12
           1957                         ;
           1958                         ;// 0: checks only mandatory precondition in order to prevent critical side-effects
           1959                         ;// 1: as above plus checks meaningful parameter conditions
           1960                         ;// 2: full implemented parameter checking (default)
           1961                         ;#ifndef PARAM_CHECK_LEVEL
           1962                         ;#define PARAM_CHECK_LEVEL 2
           1963                         ;#endif
           1964                         ;
           1965                         ;// "foursome" at IFace structure
           1966                         ;typedef struct
           1967                         ;{
           1968                         ;  // Node address low byte
           1969                         ;  uns8  NADRlow;
           1970                         ;  // Node address high byte
           1971                         ;  uns8  NADRhigh;
           1972                         ;  // Peripheral number
           1973                         ;  uns8  PNUM;
           1974                         ;  // Peripheral command
           1975                         ;  uns8  PCMD;
           1976                         ;  // HWPID
           1977                         ;  uns16 HWPID;
           1978                         ;} STRUCTATTR TDpaIFaceHeader;
           1979                         ;
           1980                         ;// Maximum command PCMD value (except reserved 0x3F = CMD_GET_PER_INFO)
           1981                         ;#define PCMD_MAX                    0x7f
           1982                         ;// Bit mask at PCMD that indicates DPA Response message
           1983                         ;#define RESPONSE_FLAG               0x80
           1984                         ;
           1985                         ;// IQMESH coordinator address
           1986                         ;#define COORDINATOR_ADDRESS         0x00
           1987                         ;// IQMESH broadcast address
           1988                         ;#define BROADCAST_ADDRESS           0xff
           1989                         ;// IQMESH temporary address, assigned by pre-bonding before authorization is done
           1990                         ;#define TEMPORARY_ADDRESS           0xfe
           1991                         ;// Address of the local device addressed by IFace
           1992                         ;#define LOCAL_ADDRESS               0xfc
           1993                         ;// Maximum IQMESH network device address
           1994                         ;#define MAX_ADDRESS                 ( 240 - 1 )
           1995                         ;
           1996                         ;// Time slots lengths in 10 ms
           1997                         ;#define MIN_STD_TIMESLOT    4
           1998                         ;#define MAX_STD_TIMESLOT    6
           1999                         ;
           2000                         ;#define MIN_LP_TIMESLOT     8
           2001                         ;#define MAX_LP_TIMESLOT     10
           2002                         ;
           2003                         ;// Maximum number of DPA PData bytes ( minus 8 = 6B foursome + 8b error code + 8b DpaValue )
           2004                         ;#define DPA_MAX_DATA_LENGTH         ( sizeofBufferCOM - sizeof( TDpaIFaceHeader ) - 2 * sizeof( uns8 ) )
           2005                         ;
           2006                         ;// Maximum number of peripherals info that can fit in the message
           2007                         ;#define MAX_PERIPHERALS_PER_BLOCK_INFO  ( DPA_MAX_DATA_LENGTH / sizeof( TPeripheralInfoAnswer ) )
           2008                         ;
           2009                         ;// Embedded peripheral numbers
           2010                         ;#define PNUM_COORDINATOR    0x00
           2011                         ;#define PNUM_NODE           0x01
           2012                         ;#define PNUM_OS             0x02
           2013                         ;#define PNUM_EEPROM         0x03
           2014                         ;#define PNUM_EEEPROM        0x04
           2015                         ;#define PNUM_RAM            0x05
           2016                         ;#define PNUM_LEDR           0x06
           2017                         ;#define PNUM_LEDG           0x07
           2018                         ;#define PNUM_IO             0x09
           2019                         ;#define PNUM_THERMOMETER    0x0A
           2020                         ;#define PNUM_UART           0x0C
           2021                         ;#define PNUM_FRC            0x0D
           2022                         ;
           2023                         ;// Number of the 1st user peripheral
           2024                         ;#define PNUM_USER           0x20
           2025                         ;// Number of the last user peripheral
           2026                         ;#define PNUM_USER_MAX       0x3E
           2027                         ;// Maximum peripheral number
           2028                         ;#define PNUM_MAX            0x7F
           2029                         ;
           2030                         ;// Fake peripheral number used to flag DPA response with error sent by RF
           2031                         ;#define PNUM_ERROR_FLAG     0xFE
           2032                         ;// Special peripheral used for enumeration
           2033                         ;#define PNUM_ENUMERATION    0xFF
           2034                         ;
           2035                         ;// DPA Commands for embedded peripherals
           2036                         ;#define CMD_COORDINATOR_ADDR_INFO  0
           2037                         ;#define CMD_COORDINATOR_DISCOVERED_DEVICES 1
           2038                         ;#define CMD_COORDINATOR_BONDED_DEVICES 2
           2039                         ;#define CMD_COORDINATOR_CLEAR_ALL_BONDS 3
           2040                         ;#define CMD_COORDINATOR_BOND_NODE 4
           2041                         ;#define CMD_COORDINATOR_REMOVE_BOND 5
           2042                         ;#define CMD_COORDINATOR_DISCOVERY 7
           2043                         ;#define CMD_COORDINATOR_SET_DPAPARAMS 8
           2044                         ;#define CMD_COORDINATOR_SET_HOPS 9
           2045                         ;#define CMD_COORDINATOR_BACKUP 11
           2046                         ;#define CMD_COORDINATOR_RESTORE 12
           2047                         ;#define CMD_COORDINATOR_AUTHORIZE_BOND 13
           2048                         ;#define CMD_COORDINATOR_BRIDGE 14
           2049                         ;#define CMD_COORDINATOR_SMART_CONNECT 18
           2050                         ;#define CMD_COORDINATOR_SET_MID 19
           2051                         ;
           2052                         ;#define CMD_NODE_READ 0
           2053                         ;#define CMD_NODE_REMOVE_BOND 1
           2054                         ;#define CMD_NODE_BACKUP 6
           2055                         ;#define CMD_NODE_RESTORE 7
           2056                         ;#define CMD_NODE_VALIDATE_BONDS 8
           2057                         ;
           2058                         ;#define CMD_OS_READ 0
           2059                         ;#define CMD_OS_RESET 1
           2060                         ;#define CMD_OS_READ_CFG 2
           2061                         ;#define CMD_OS_RFPGM 3
           2062                         ;#define CMD_OS_SLEEP 4
           2063                         ;#define CMD_OS_BATCH 5
           2064                         ;#define CMD_OS_SET_SECURITY 6
           2065                         ;#define CMD_OS_INDICATE 7
           2066                         ;#define CMD_OS_RESTART 8
           2067                         ;#define CMD_OS_WRITE_CFG_BYTE 9
           2068                         ;#define CMD_OS_LOAD_CODE 10
           2069                         ;#define CMD_OS_SELECTIVE_BATCH 11
           2070                         ;#define CMD_OS_TEST_RF_SIGNAL 12
           2071                         ;#define CMD_OS_FACTORY_SETTINGS 13
           2072                         ;#define CMD_OS_WRITE_CFG 15
           2073                         ;
           2074                         ;#define CMD_RAM_READ 0
           2075                         ;#define CMD_RAM_WRITE 1
           2076                         ;#define CMD_RAM_READ_ANY    15
           2077                         ;
           2078                         ;#define CMD_EEPROM_READ CMD_RAM_READ
           2079                         ;#define CMD_EEPROM_WRITE CMD_RAM_WRITE
           2080                         ;
           2081                         ;#define CMD_EEEPROM_XREAD ( CMD_RAM_READ + 2 )
           2082                         ;#define CMD_EEEPROM_XWRITE ( CMD_RAM_WRITE + 2 )
           2083                         ;
           2084                         ;#define CMD_LED_SET_OFF 0
           2085                         ;#define CMD_LED_SET_ON 1
           2086                         ;#define CMD_LED_PULSE 3
           2087                         ;#define CMD_LED_FLASHING 4
           2088                         ;
           2089                         ;#define CMD_IO_DIRECTION  0
           2090                         ;#define CMD_IO_SET  1
           2091                         ;#define CMD_IO_GET  2
           2092                         ;
           2093                         ;#define CMD_THERMOMETER_READ 0
           2094                         ;
           2095                         ;#define CMD_UART_OPEN 0
           2096                         ;#define CMD_UART_CLOSE 1
           2097                         ;#define CMD_UART_WRITE_READ 2
           2098                         ;#define CMD_UART_CLEAR_WRITE_READ 3
           2099                         ;
           2100                         ;#define CMD_FRC_SEND 0
           2101                         ;#define CMD_FRC_EXTRARESULT 1
           2102                         ;#define CMD_FRC_SEND_SELECTIVE 2
           2103                         ;#define CMD_FRC_SET_PARAMS 3
           2104                         ;
           2105                         ;#define CMD_GET_PER_INFO  0x3f
           2106                         ;
           2107                         ;// DPA peripheral type
           2108                         ;typedef enum
           2109                         ;{
           2110                         ;  PERIPHERAL_TYPE_DUMMY = 0x00,
           2111                         ;  PERIPHERAL_TYPE_COORDINATOR = 0x01,
           2112                         ;  PERIPHERAL_TYPE_NODE = 0x02,
           2113                         ;  PERIPHERAL_TYPE_OS = 0x03,
           2114                         ;  PERIPHERAL_TYPE_EEPROM = 0x04,
           2115                         ;  PERIPHERAL_TYPE_BLOCK_EEPROM = 0x05,
           2116                         ;  PERIPHERAL_TYPE_RAM = 0x06,
           2117                         ;  PERIPHERAL_TYPE_LED = 0x07,
           2118                         ;  PERIPHERAL_TYPE_SPI = 0x08,
           2119                         ;  PERIPHERAL_TYPE_IO = 0x09,
           2120                         ;  PERIPHERAL_TYPE_UART = 0x0a,
           2121                         ;  PERIPHERAL_TYPE_THERMOMETER = 0x0b,
           2122                         ;  PERIPHERAL_TYPE_ADC = 0x0c,
           2123                         ;  PERIPHERAL_TYPE_PWM = 0x0d,
           2124                         ;  PERIPHERAL_TYPE_FRC = 0x0e,
           2125                         ;  // Starts peripheral type number interval for user peripherals
           2126                         ;  PERIPHERAL_TYPE_USER_AREA = 0x80
           2127                         ;} TDpaPeripheralType;
           2128                         ;
           2129                         ;// Peripheral extended information
           2130                         ;typedef enum
           2131                         ;{
           2132                         ;  PERIPHERAL_TYPE_EXTENDED_DEFAULT = 0x00,
           2133                         ;  PERIPHERAL_TYPE_EXTENDED_READ = 0x01,
           2134                         ;  PERIPHERAL_TYPE_EXTENDED_WRITE = 0x02,
           2135                         ;  PERIPHERAL_TYPE_EXTENDED_READ_WRITE = PERIPHERAL_TYPE_EXTENDED_READ | PERIPHERAL_TYPE_EXTENDED_WRITE
           2136                         ;} TDpaPeripheralTypeExtended;
           2137                         ;
           2138                         ;// Response packet error codes
           2139                         ;typedef enum
           2140                         ;{
           2141                         ;  // No error
           2142                         ;  STATUS_NO_ERROR = 0,
           2143                         ;
           2144                         ;  // General fail
           2145                         ;  ERROR_FAIL = 1,
           2146                         ;  // Incorrect PCMD
           2147                         ;  ERROR_PCMD = 2,
           2148                         ;  // Incorrect PNUM or PCMD
           2149                         ;  ERROR_PNUM = 3,
           2150                         ;  // Incorrect Address value when addressing memory type peripherals
           2151                         ;  ERROR_ADDR = 4,
           2152                         ;  // Incorrect Data length
           2153                         ;  ERROR_DATA_LEN = 5,
           2154                         ;  // Incorrect Data
           2155                         ;  ERROR_DATA = 6,
           2156                         ;  // Incorrect HWPID used
           2157                         ;  ERROR_HWPID = 7,
           2158                         ;  // Incorrect NADR
           2159                         ;  ERROR_NADR = 8,
           2160                         ;  // IFACE data consumed by Custom DPA Handler
           2161                         ;  ERROR_IFACE_CUSTOM_HANDLER = 9,
           2162                         ;  // Custom DPA Handler is missing
           2163                         ;  ERROR_MISSING_CUSTOM_DPA_HANDLER = 10,
           2164                         ;
           2165                         ;  // Beginning of the user code error interval
           2166                         ;  ERROR_USER_FROM = 0x20,
           2167                         ;  // End of the user code error interval
           2168                         ;  ERROR_USER_TO = 0x3f,
           2169                         ;
           2170                         ;  // Bit/flag reserved for a future use
           2171                         ;  STATUS_RESERVED_FLAG = 0x40,
           2172                         ;  // Bit to flag asynchronous DPA Response from [N]
           2173                         ;  STATUS_ASYNC_RESPONSE = 0x80,
           2174                         ;  // Error code used to mark DPA Confirmation
           2175                         ;  STATUS_CONFIRMATION = 0xff
           2176                         ;} TErrorCodes;
           2177                         ;
           2178                         ;// Embedded FRC commands
           2179                         ;typedef enum
           2180                         ;{
           2181                         ;  // 2 bits
           2182                         ;  FRC_Ping = 0x00,
           2183                         ;  FRC_AcknowledgedBroadcastBits = 0x02,
           2184                         ;  FRC_PrebondedAlive = 0x03,
           2185                         ;  FRC_SupplyVoltage = 0x04,
           2186                         ;  FRC_PrebondedMemoryCompare2B = 0x05,
           2187                         ;  // 1 byte
           2188                         ;  FRC_Temperature = 0x80,
           2189                         ;  FRC_AcknowledgedBroadcastBytes = 0x81,
           2190                         ;  FRC_MemoryRead = 0x82,
           2191                         ;  FRC_MemoryReadPlus1 = 0x83,
           2192                         ;  FRC_FrcResponseTime = 0x84,
           2193                         ;  FRC_TestRFsignal = 0x85,
           2194                         ;  // 4 bytes
           2195                         ;  FRC_PrebondedMemoryRead4BPlus1 = 0xF8,
           2196                         ;  FRC_MemoryRead4B = 0xFA
           2197                         ;} TFRCommands;
           2198                         ;
           2199                         ;// Intervals of user FRC codes
           2200                         ;#define FRC_USER_BIT_FROM     0x40
           2201                         ;#define FRC_USER_BIT_TO       0x7F
           2202                         ;#define FRC_USER_BYTE_FROM    0xC0
           2203                         ;#define FRC_USER_BYTE_TO      0xDF
           2204                         ;#define FRC_USER_2BYTE_FROM   0xF0
           2205                         ;#define FRC_USER_2BYTE_TO     0xF7
           2206                         ;#define FRC_USER_4BYTE_FROM   0xFC
           2207                         ;#define FRC_USER_4BYTE_TO     0xFF
           2208                         ;
           2209                         ;// No HWPID specified
           2210                         ;#define HWPID_Default         0x0000
           2211                         ;// Use this type to override HWPID check
           2212                         ;#define HWPID_DoNotCheck      0xFfFf
           2213                         ;
           2214                         ;// RAM peripheral block definitions
           2215                         ;#ifdef TR7xD
           2216                         ;#define PERIPHERAL_RAM_LENGTH 48
           2217                         ;#else
           2218                         ;#define PERIPHERAL_RAM_LENGTH 80
           2219                         ;#endif
           2220                         ;
           2221                         ;// Start address of EEPROM peripheral in the real EEPROM
           2222                         ;#ifndef COORDINATOR_CUSTOM_HANDLER // Node
           2223                         ;#define PERIPHERAL_EEPROM_START     ( (uns8)0x00 )
           2224                         ;#else // Coordinator
           2225                         ;#define PERIPHERAL_EEPROM_START     ( (uns8)0x80 )
           2226                         ;#endif
           2227                         ;
           2228                         ;// Length of the internal EEPROM peripheral array
           2229                         ;#define PERIPHERAL_EEPROM_LENGTH            ( (uns8)( 0xC0 - PERIPHERAL_EEPROM_START ) )
           2230                         ;
           2231                         ;// Length of the readable area of serial EEEPROM from the EEEPROM DPA peripheral write point of view.
           2232                         ;#define EEEPROM_READ_LENGTH                 0x8000
           2233                         ;// Length of the writable area of serial EEEPROM from the EEEPROM DPA peripheral write point of view.
           2234                         ;#define EEEPROM_WRITE_LENGTH                0x4000
           2235                         ;
           2236                         ;// Starting address of the IO Setup DPA storage at external EEPROM
           2237                         ;#define IOSETUP_EEEPROM_ADDR                ( 0x0000 + sizeofBufferAUX )
           2238                         ;// Length of the IO setup memory block
           2239                         ;#define IOSETUP_LENGTH                      sizeofBufferAUX
           2240                         ;
           2241                         ;#if !defined( TR7xD )
           2242                         ;// Parameter at [_]DpaApi[Deep]Sleep() for not using Watchdog timer wakeup
           2243                         ;#define DpaApiSleep_WdtOff                  0b00000.0
           2244                         ;#endif
           2245                         ;
           2246                         ;// ---------------------------------------------------------
           2247                         ;
           2248                         ;// Enumerate peripherals structure
           2249                         ;typedef struct
           2250                         ;{
           2251                         ;  uns16 DpaVersion;
           2252                         ;  uns8  UserPerNr;
           2253                         ;  uns8  EmbeddedPers[PNUM_USER / 8];
           2254                         ;  uns16 HWPID;
           2255                         ;  uns16 HWPIDver;
           2256                         ;  uns8  Flags;
           2257                         ;  uns8  UserPer[( PNUM_MAX - PNUM_USER + 1 + 7 ) / 8];
           2258                         ;} STRUCTATTR TEnumPeripheralsAnswer;
           2259                         ;
           2260                         ;#define FlagUserPer(UserPersArray,UserPerNumber)    UserPersArray[((UserPerNumber)-PNUM_USER) / 8] |= (uns8)0x01 << (((UserPerNumber)-PNUM_USER) % 8);
           2261                         ;
           2262                         ;// Get peripheral info structure (CMD_GET_PER_INFO)
           2263                         ;typedef struct
           2264                         ;{
           2265                         ;  uns8  PerTE;
           2266                         ;  uns8  PerT;
           2267                         ;  uns8  Par1;
           2268                         ;  uns8  Par2;
           2269                         ;} STRUCTATTR TPeripheralInfoAnswer;
           2270                         ;
           2271                         ;// Error DPA response (PNUM_ERROR_FLAG)
           2272                         ;typedef struct
           2273                         ;{
           2274                         ;  uns8  ErrN;
           2275                         ;  uns8  PNUMoriginal;
           2276                         ;} STRUCTATTR TErrorAnswer;
           2277                         ;
           2278                         ;// Structure returned by CMD_COORDINATOR_ADDR_INFO
           2279                         ;typedef struct
           2280                         ;{
           2281                         ;  uns8  DevNr;
           2282                         ;  uns8  DID;
           2283                         ;} STRUCTATTR TPerCoordinatorAddrInfo_Response;
           2284                         ;
           2285                         ;// Structure for CMD_COORDINATOR_BOND_NODE
           2286                         ;typedef struct
           2287                         ;{
           2288                         ;  uns8  ReqAddr;
           2289                         ;  uns8  BondingTestRetries;
           2290                         ;} STRUCTATTR TPerCoordinatorBondNode_Request;
           2291                         ;
           2292                         ;// Structure returned by CMD_COORDINATOR_BOND_NODE or CMD_COORDINATOR_SMART_CONNECT
           2293                         ;typedef struct
           2294                         ;{
           2295                         ;  uns8  BondAddr;
           2296                         ;  uns8  DevNr;
           2297                         ;} STRUCTATTR TPerCoordinatorBondNodeSmartConnect_Response;
           2298                         ;
           2299                         ;// Structure for CMD_COORDINATOR_REMOVE_BOND
           2300                         ;typedef struct
           2301                         ;{
           2302                         ;  uns8  BondAddr;
           2303                         ;} STRUCTATTR TPerCoordinatorRemoveBond_Request;
           2304                         ;
           2305                         ;// Structure returned by CMD_COORDINATOR_REMOVE_BOND
           2306                         ;typedef struct
           2307                         ;{
           2308                         ;  uns8  DevNr;
           2309                         ;} STRUCTATTR TPerCoordinatorRemoveBond_Response;
           2310                         ;
           2311                         ;// Structure for CMD_COORDINATOR_DISCOVERY
           2312                         ;typedef struct
           2313                         ;{
           2314                         ;  uns8  TxPower;
           2315                         ;  uns8  MaxAddr;
           2316                         ;} STRUCTATTR TPerCoordinatorDiscovery_Request;
           2317                         ;
           2318                         ;// Structure returned by CMD_COORDINATOR_DISCOVERY
           2319                         ;typedef struct
           2320                         ;{
           2321                         ;  uns8  DiscNr;
           2322                         ;} STRUCTATTR TPerCoordinatorDiscovery_Response;
           2323                         ;
           2324                         ;// Structure for and also returned by CMD_COORDINATOR_SET_DPAPARAMS
           2325                         ;typedef struct
           2326                         ;{
           2327                         ;  uns8  DpaParam;
           2328                         ;} STRUCTATTR TPerCoordinatorSetDpaParams_Request_Response;
           2329                         ;
           2330                         ;// Structure for and also returned by CMD_COORDINATOR_SET_HOPS
           2331                         ;typedef struct
           2332                         ;{
           2333                         ;  uns8  RequestHops;
           2334                         ;  uns8  ResponseHops;
           2335                         ;} STRUCTATTR TPerCoordinatorSetHops_Request_Response;
           2336                         ;
           2337                         ;// Structure for CMD_COORDINATOR_BACKUP and CMD_NODE_BACKUP
           2338                         ;typedef struct
           2339                         ;{
           2340                         ;  uns8  Index;
           2341                         ;} STRUCTATTR TPerCoordinatorNodeBackup_Request;
           2342                         ;
           2343                         ;// Structure returned by CMD_COORDINATOR_BACKUP and CMD_NODE_BACKUP
           2344                         ;typedef struct
           2345                         ;{
           2346                         ;  uns8  NetworkData[49];
           2347                         ;} STRUCTATTR TPerCoordinatorNodeBackup_Response;
           2348                         ;
           2349                         ;// Structure for CMD_COORDINATOR_RESTORE and CMD_NODE_RESTORE
           2350                         ;typedef struct
           2351                         ;{
           2352                         ;  uns8  NetworkData[49];
           2353                         ;} STRUCTATTR TPerCoordinatorNodeRestore_Request;
           2354                         ;
           2355                         ;// Structure for CMD_COORDINATOR_AUTHORIZE_BOND
           2356                         ;typedef struct
           2357                         ;{
           2358                         ;  uns8  ReqAddr;
           2359                         ;  uns8  MID[4];
           2360                         ;} STRUCTATTR TPerCoordinatorAuthorizeBond_Request;
           2361                         ;
           2362                         ;// Structure returned by CMD_COORDINATOR_AUTHORIZE_BOND
           2363                         ;typedef struct
           2364                         ;{
           2365                         ;  uns8  BondAddr;
           2366                         ;  uns8  DevNr;
           2367                         ;} STRUCTATTR TPerCoordinatorAuthorizeBond_Response;
           2368                         ;
           2369                         ;// Structure for CMD_COORDINATOR_BRIDGE
           2370                         ;typedef struct
           2371                         ;{
           2372                         ;  TDpaIFaceHeader subHeader;
           2373                         ;  uns8  subPData[DPA_MAX_DATA_LENGTH - sizeof( TDpaIFaceHeader )];
           2374                         ;} STRUCTATTR TPerCoordinatorBridge_Request;
           2375                         ;
           2376                         ;// Structure returned by CMD_COORDINATOR_BRIDGE
           2377                         ;typedef struct
           2378                         ;{
           2379                         ;  TDpaIFaceHeader subHeader;
           2380                         ;  uns8  subRespCode;
           2381                         ;  uns8  subDpaValue;
           2382                         ;  uns8  subPData[DPA_MAX_DATA_LENGTH - sizeof( TDpaIFaceHeader ) - 2 * sizeof( uns8 )];
           2383                         ;} STRUCTATTR TPerCoordinatorBridge_Response;
           2384                         ;
           2385                         ;// Structure for CMD_COORDINATOR_SMART_CONNECT
           2386                         ;typedef struct
           2387                         ;{
           2388                         ;  uns8  ReqAddr;
           2389                         ;  uns8  BondingTestRetries;
           2390                         ;  uns8  IBK[16];
           2391                         ;  uns8  MID[4];
           2392                         ;  uns8  reserved0;
           2393                         ;  uns8  VirtualDeviceAddress;
           2394                         ;  uns8  UserData[4];
           2395                         ;  uns8  reserved1[10];
           2396                         ;} STRUCTATTR TPerCoordinatorSmartConnect_Request;
           2397                         ;
           2398                         ;// Structure for CMD_COORDINATOR_SET_MID
           2399                         ;typedef struct
           2400                         ;{
           2401                         ;  uns8  MID[4];
           2402                         ;  uns8  BondAddr;
           2403                         ;} STRUCTATTR TPerCoordinatorSetMID_Request;
           2404                         ;
           2405                         ;// Structure returned by CMD_NODE_READ
           2406                         ;typedef struct
           2407                         ;{
           2408                         ;  uns8  ntwADDR;
           2409                         ;  uns8  ntwVRN;
           2410                         ;  uns8  ntwZIN;
           2411                         ;  uns8  ntwDID;
           2412                         ;  uns8  ntwPVRN;
           2413                         ;  uns16 ntwUSERADDRESS;
           2414                         ;  uns16 ntwID;
           2415                         ;  uns8  ntwVRNFNZ;
           2416                         ;  uns8  ntwCFG;
           2417                         ;  uns8  Flags;
           2418                         ;} STRUCTATTR TPerNodeRead_Response;
           2419                         ;
           2420                         ;// Structures for CMD_NODE_VALIDATE_BONDS
           2421                         ;typedef struct
           2422                         ;{
           2423                         ;  uns8  Address;
           2424                         ;  uns8  MID[4];
           2425                         ;} STRUCTATTR TPerNodeValidateBondsItem;
           2426                         ;
           2427                         ;// Structure for CMD_NODE_VALIDATE_BONDS
           2428                         ;typedef struct
           2429                         ;{
           2430                         ;  TPerNodeValidateBondsItem Bonds[DPA_MAX_DATA_LENGTH / sizeof( TPerNodeValidateBondsItem )];
           2431                         ;} STRUCTATTR TPerNodeValidateBonds_Request;
           2432                         ;
           2433                         ;// Structure returned by CMD_OS_READ
           2434                         ;typedef struct
           2435                         ;{
           2436                         ;  uns8  MID[4];
           2437                         ;  uns8  OsVersion;
           2438                         ;  uns8  TrType;
           2439                         ;  uns16 OsBuild;
           2440                         ;  uns8  Rssi;
           2441                         ;  uns8  SupplyVoltage;
           2442                         ;  uns8  Flags;
           2443                         ;  uns8  SlotLimits;
           2444                         ;  uns8  IBK[16];
           2445                         ;  // Enumerate peripherals part, variable length because of UserPer field
           2446                         ;  uns16 DpaVersion;
           2447                         ;  uns8  UserPerNr;
           2448                         ;  uns8  EmbeddedPers[PNUM_USER / 8];
           2449                         ;  uns16 HWPID;
           2450                         ;  uns16 HWPIDver;
           2451                         ;  uns8  FlagsEnum;
           2452                         ;  uns8  UserPer[( PNUM_MAX - PNUM_USER + 1 + 7 ) / 8];
           2453                         ;} STRUCTATTR TPerOSRead_Response;
           2454                         ;
           2455                         ;// Structure returned by CMD_OS_READ_CFG
           2456                         ;typedef struct
           2457                         ;{
           2458                         ;  uns8  Checksum;
           2459                         ;  uns8  Configuration[31];
           2460                         ;  uns8  RFPGM;
           2461                         ;  uns8  Undocumented[1];
           2462                         ;} STRUCTATTR TPerOSReadCfg_Response;
           2463                         ;
           2464                         ;// Structure for CMD_OS_WRITE_CFG
           2465                         ;typedef struct
           2466                         ;{
           2467                         ;  uns8  Undefined;
           2468                         ;  uns8  Configuration[31];
           2469                         ;  uns8  RFPGM;
           2470                         ;} STRUCTATTR TPerOSWriteCfg_Request;
           2471                         ;
           2472                         ;// Structures for CMD_OS_WRITE_CFG_BYTE
           2473                         ;typedef struct
           2474                         ;{
           2475                         ;  uns8  Address;
           2476                         ;  uns8  Value;
           2477                         ;  uns8  Mask;
           2478                         ;} STRUCTATTR TPerOSWriteCfgByteTriplet;
           2479                         ;
           2480                         ;// Structure for CMD_OS_WRITE_CFG_BYTE
           2481                         ;typedef struct
           2482                         ;{
           2483                         ;  TPerOSWriteCfgByteTriplet Triplets[DPA_MAX_DATA_LENGTH / sizeof( TPerOSWriteCfgByteTriplet )];
           2484                         ;} STRUCTATTR TPerOSWriteCfgByte_Request;
           2485                         ;
           2486                         ;// Structure for CMD_OS_SET_SECURITY
           2487                         ;typedef struct
           2488                         ;{
           2489                         ;  uns8  Type;
           2490                         ;  uns8  Data[16];
           2491                         ;} STRUCTATTR TPerOSSetSecurity_Request;
           2492                         ;
           2493                         ;// Structure for CMD_OS_LOAD_CODE
           2494                         ;typedef struct
           2495                         ;{
           2496                         ;  uns8  Flags;
           2497                         ;  uns16 Address;
           2498                         ;  uns16 Length;
           2499                         ;  uns16 CheckSum;
           2500                         ;} STRUCTATTR TPerOSLoadCode_Request;
           2501                         ;
           2502                         ;// Structure for CMD_OS_SLEEP
           2503                         ;typedef struct
           2504                         ;{
           2505                         ;  uns16 Time;
           2506                         ;  uns8  Control;
           2507                         ;} STRUCTATTR TPerOSSleep_Request;
           2508                         ;
           2509                         ;// Structure for CMD_OS_SELECTIVE_BATCH
           2510                         ;typedef struct
           2511                         ;{
           2512                         ;  uns8  SelectedNodes[30];
           2513                         ;  uns8  Requests[DPA_MAX_DATA_LENGTH - 30];
           2514                         ;} STRUCTATTR TPerOSSelectiveBatch_Request;
           2515                         ;
           2516                         ;// Structure for CMD_OS_TEST_RF_SIGNAL request
           2517                         ;typedef struct
           2518                         ;{
           2519                         ;  uns8  Channel;
           2520                         ;  uns8  RXfilter;
           2521                         ;  uns16 Time;
           2522                         ;} STRUCTATTR TPerOSTestRfSignal_Request;
           2523                         ;
           2524                         ;// Structure for CMD_OS_TEST_RF_SIGNAL response
           2525                         ;typedef struct
           2526                         ;{
           2527                         ;  uns8  Counter;
           2528                         ;} STRUCTATTR TPerOSTestRfSignal_Response;
           2529                         ;
           2530                         ;// Structure for CMD_OS_INDICATE request
           2531                         ;typedef struct
           2532                         ;{
           2533                         ;  uns8  Control;
           2534                         ;} STRUCTATTR TPerOSIndicate_Request;
           2535                         ;
           2536                         ;// Structure for general memory request
           2537                         ;typedef struct
           2538                         ;{
           2539                         ;  // Address of data to write or read
           2540                         ;  uns8  Address;
           2541                         ;
           2542                         ;  union
           2543                         ;  {
           2544                         ;    // Memory read request
           2545                         ;    struct
           2546                         ;    {
           2547                         ;      // Length of data to read
           2548                         ;      uns8  Length;
           2549                         ;    } Read;
           2550                         ;
           2551                         ;    // Size of Address field
           2552                         ;#define MEMORY_WRITE_REQUEST_OVERHEAD   ( sizeof( uns8 ) )
           2553                         ;
           2554                         ;    // Memory write request
           2555                         ;    struct
           2556                         ;    {
           2557                         ;      uns8  PData[DPA_MAX_DATA_LENGTH - MEMORY_WRITE_REQUEST_OVERHEAD];
           2558                         ;    } Write;
           2559                         ;
           2560                         ;  } ReadWrite;
           2561                         ;} STRUCTATTR TPerMemoryRequest;
           2562                         ;
           2563                         ;// Structure for general extended memory request
           2564                         ;typedef struct
           2565                         ;{
           2566                         ;  // Address of data to write or read
           2567                         ;  uns16 Address;
           2568                         ;
           2569                         ;  union
           2570                         ;  {
           2571                         ;    // Memory read request
           2572                         ;    struct
           2573                         ;    {
           2574                         ;      // Length of data to read
           2575                         ;      uns8  Length;
           2576                         ;    } Read;
           2577                         ;
           2578                         ;    // Size of Address field
           2579                         ;#define XMEMORY_WRITE_REQUEST_OVERHEAD  ( sizeof( uns16 ) )
           2580                         ;
           2581                         ;    // Memory write request
           2582                         ;    struct
           2583                         ;    {
           2584                         ;      uns8  PData[DPA_MAX_DATA_LENGTH - XMEMORY_WRITE_REQUEST_OVERHEAD];
           2585                         ;    } Write;
           2586                         ;
           2587                         ;  } ReadWrite;
           2588                         ;} STRUCTATTR TPerXMemoryRequest;
           2589                         ;
           2590                         ;// Structure for CMD_IO requests
           2591                         ;typedef struct
           2592                         ;{
           2593                         ;  uns8  Port;
           2594                         ;  uns8  Mask;
           2595                         ;  uns8  Value;
           2596                         ;} STRUCTATTR TPerIOTriplet;
           2597                         ;
           2598                         ;typedef struct
           2599                         ;{
           2600                         ;  uns8  Header; // == PNUM_IO_DELAY
           2601                         ;  uns16 Delay;
           2602                         ;} STRUCTATTR TPerIODelay;
           2603                         ;
           2604                         ;// Union for CMD_IO_SET and CMD_IO_DIRECTION requests
           2605                         ;typedef union
           2606                         ;{
           2607                         ;  TPerIOTriplet Triplets[DPA_MAX_DATA_LENGTH / sizeof( TPerIOTriplet )];
           2608                         ;  TPerIODelay   Delays[DPA_MAX_DATA_LENGTH / sizeof( TPerIODelay )];
           2609                         ;} STRUCTATTR TPerIoDirectionAndSet_Request;
           2610                         ;
           2611                         ;// Structure returned by CMD_THERMOMETER_READ
           2612                         ;typedef struct
           2613                         ;{
           2614                         ;  int8  IntegerValue;
           2615                         ;  int16 SixteenthValue;
           2616                         ;} STRUCTATTR TPerThermometerRead_Response;
           2617                         ;
           2618                         ;// Structure for CMD_UART_OPEN
           2619                         ;typedef struct
           2620                         ;{
           2621                         ;  uns8  BaudRate;
           2622                         ;} STRUCTATTR TPerUartOpen_Request;
           2623                         ;
           2624                         ;// Structure for CMD_UART_[CLEAR_]WRITE_READ
           2625                         ;typedef struct
           2626                         ;{
           2627                         ;  uns8  ReadTimeout;
           2628                         ;  uns8  WrittenData[DPA_MAX_DATA_LENGTH - sizeof( uns8 )];
           2629                         ;} STRUCTATTR TPerUartWriteRead_Request;
           2630                         ;
           2631                         ;// Structure for CMD_FRC_SEND
           2632                         ;typedef struct
           2633                         ;{
           2634                         ;  uns8  FrcCommand;
           2635                         ;  uns8  UserData[30];
           2636                         ;} STRUCTATTR TPerFrcSend_Request;
           2637                         ;
           2638                         ;// Structure for CMD_FRC_SEND_SELECTIVE
           2639                         ;typedef struct
           2640                         ;{
           2641                         ;  uns8  FrcCommand;
           2642                         ;  uns8  SelectedNodes[30];
           2643                         ;  uns8  UserData[25];
           2644                         ;} STRUCTATTR TPerFrcSendSelective_Request;
           2645                         ;
           2646                         ;// Structure returned by CMD_FRC_SEND and CMD_FRC_SEND_SELECTIVE
           2647                         ;typedef struct
           2648                         ;{
           2649                         ;  uns8  Status;
           2650                         ;  uns8  FrcData[DPA_MAX_DATA_LENGTH - sizeof( uns8 )];
           2651                         ;} STRUCTATTR TPerFrcSend_Response;
           2652                         ;
           2653                         ;// Structure for request and response of CMD_FRC_SET_PARAMS
           2654                         ;typedef struct
           2655                         ;{
           2656                         ;  uns8  FrcParams;
           2657                         ;} STRUCTATTR TPerFrcSetParams_RequestResponse;
           2658                         ;
           2659                         ;// Interface and CMD_COORDINATOR_BRIDGE confirmation structure
           2660                         ;typedef struct
           2661                         ;{
           2662                         ;  // Number of hops
           2663                         ;  uns8  Hops;
           2664                         ;  // Time slot length in 10ms
           2665                         ;  uns8  TimeSlotLength;
           2666                         ;  // Number of hops for response
           2667                         ;  uns8  HopsResponse;
           2668                         ;} STRUCTATTR TIFaceConfirmation;
           2669                         ;
           2670                         ;// ---------------------------------------------------------
           2671                         ;
           2672                         ;// DPA Message data structure (packet w/o NADR, PNUM, PCMD, HWPID)
           2673                         ;typedef union
           2674                         ;{
           2675                         ;  // General DPA request
           2676                         ;  struct
           2677                         ;  {
           2678                         ;    uns8    PData[DPA_MAX_DATA_LENGTH];
           2679                         ;  } Request;
           2680                         ;
           2681                         ;  // General DPA response
           2682                         ;  struct
           2683                         ;  {
           2684                         ;    uns8    PData[DPA_MAX_DATA_LENGTH];
           2685                         ;  } Response;
           2686                         ;
           2687                         ;  // Enumerate peripherals structure
           2688                         ;  TEnumPeripheralsAnswer EnumPeripheralsAnswer;
           2689                         ;
           2690                         ;  // Get peripheral info structure (CMD_GET_PER_INFO)
           2691                         ;  TPeripheralInfoAnswer PeripheralInfoAnswer;
           2692                         ;
           2693                         ;  // Get peripheral info structure (CMD_GET_PER_INFO) for more peripherals
           2694                         ;  TPeripheralInfoAnswer PeripheralInfoAnswers[MAX_PERIPHERALS_PER_BLOCK_INFO];
           2695                         ;
           2696                         ;  // Error DPA response (PNUM_ERROR_FLAG)
           2697                         ;  TErrorAnswer ErrorAnswer;
           2698                         ;
           2699                         ;  // Structure returned by CMD_COORDINATOR_ADDR_INFO
           2700                         ;  TPerCoordinatorAddrInfo_Response PerCoordinatorAddrInfo_Response;
           2701                         ;
           2702                         ;  // Structure for CMD_COORDINATOR_BOND_NODE
           2703                         ;  TPerCoordinatorBondNode_Request PerCoordinatorBondNode_Request;
           2704                         ;
           2705                         ;  // Structure returned by CMD_COORDINATOR_BOND_NODE or CMD_COORDINATOR_SMART_CONNECT
           2706                         ;  TPerCoordinatorBondNodeSmartConnect_Response PerCoordinatorBondNodeSmartConnect_Response;
           2707                         ;
           2708                         ;  // Structure for CMD_COORDINATOR_REMOVE_BOND
           2709                         ;  TPerCoordinatorRemoveBond_Request PerCoordinatorRemoveBond_Request;
           2710                         ;
           2711                         ;  // Structure returned by CMD_COORDINATOR_REMOVE_BOND
           2712                         ;  TPerCoordinatorRemoveBond_Response PerCoordinatorRemoveBond_Response;
           2713                         ;
           2714                         ;  // Structure for CMD_COORDINATOR_DISCOVERY
           2715                         ;  TPerCoordinatorDiscovery_Request PerCoordinatorDiscovery_Request;
           2716                         ;
           2717                         ;  // Structure returned by CMD_COORDINATOR_DISCOVERY
           2718                         ;  TPerCoordinatorDiscovery_Response PerCoordinatorDiscovery_Response;
           2719                         ;
           2720                         ;  // Structure for and also returned by CMD_COORDINATOR_SET_DPAPARAMS
           2721                         ;  TPerCoordinatorSetDpaParams_Request_Response PerCoordinatorSetDpaParams_Request_Response;
           2722                         ;
           2723                         ;  // Structure for and also returned by CMD_COORDINATOR_SET_HOPS
           2724                         ;  TPerCoordinatorSetHops_Request_Response PerCoordinatorSetHops_Request_Response;
           2725                         ;
           2726                         ;  // Structure for CMD_COORDINATOR_BACKUP and CMD_NODE_BACKUP
           2727                         ;  TPerCoordinatorNodeBackup_Request PerCoordinatorNodeBackup_Request;
           2728                         ;
           2729                         ;  // Structure returned by CMD_COORDINATOR_BACKUP and CMD_NODE_BACKUP
           2730                         ;  TPerCoordinatorNodeBackup_Response PerCoordinatorNodeBackup_Response;
           2731                         ;
           2732                         ;  // Structure for CMD_COORDINATOR_RESTORE and CMD_NODE_RESTORE
           2733                         ;  TPerCoordinatorNodeRestore_Request PerCoordinatorNodeRestore_Request;
           2734                         ;
           2735                         ;  // Structure for CMD_COORDINATOR_AUTHORIZE_BOND
           2736                         ;  TPerCoordinatorAuthorizeBond_Request PerCoordinatorAuthorizeBond_Request;
           2737                         ;
           2738                         ;  // Structure returned by CMD_COORDINATOR_AUTHORIZE_BOND
           2739                         ;  TPerCoordinatorAuthorizeBond_Response PerCoordinatorAuthorizeBond_Response;
           2740                         ;
           2741                         ;  // Structure for CMD_COORDINATOR_BRIDGE
           2742                         ;  TPerCoordinatorBridge_Request PerCoordinatorBridge_Request;
           2743                         ;
           2744                         ;  // Structure returned by CMD_COORDINATOR_BRIDGE
           2745                         ;  TPerCoordinatorBridge_Response PerCoordinatorBridge_Response;
           2746                         ;
           2747                         ;  // Structure for CMD_COORDINATOR_SMART_CONNECT
           2748                         ;  TPerCoordinatorSmartConnect_Request PerCoordinatorSmartConnect_Request;
           2749                         ;
           2750                         ;  // Structure for CMD_COORDINATOR_SET_MID
           2751                         ;  TPerCoordinatorSetMID_Request PerCoordinatorSetMID_Request;
           2752                         ;
           2753                         ;  // Structure returned by CMD_NODE_READ
           2754                         ;  TPerNodeRead_Response PerNodeRead_Response;
           2755                         ;
           2756                         ;  // Structure for CMD_NODE_VALIDATE_BONDS
           2757                         ;  TPerNodeValidateBonds_Request PerNodeValidateBonds_Request;
           2758                         ;
           2759                         ;  // Structure returned by CMD_OS_READ
           2760                         ;  TPerOSRead_Response PerOSRead_Response;
           2761                         ;
           2762                         ;  // Structure returned by CMD_OS_READ_CFG
           2763                         ;  TPerOSReadCfg_Response PerOSReadCfg_Response;
           2764                         ;
           2765                         ;  // Structure for CMD_OS_WRITE_CFG
           2766                         ;  TPerOSWriteCfg_Request PerOSWriteCfg_Request;
           2767                         ;
           2768                         ;  // Structure for CMD_OS_WRITE_CFG_BYTE
           2769                         ;  TPerOSWriteCfgByte_Request PerOSWriteCfgByte_Request;
           2770                         ;
           2771                         ;  // Structure for CMD_OS_SET_SECURITY
           2772                         ;  TPerOSSetSecurity_Request PerOSSetSecurity_Request;
           2773                         ;
           2774                         ;  // Structure for CMD_OS_LOAD_CODE
           2775                         ;  TPerOSLoadCode_Request PerOSLoadCode_Request;
           2776                         ;
           2777                         ;  // Structure for CMD_OS_SLEEP
           2778                         ;  TPerOSSleep_Request PerOSSleep_Request;
           2779                         ;
           2780                         ;  // Structure for CMD_OS_SELECTIVE_BATCH
           2781                         ;  TPerOSSelectiveBatch_Request PerOSSelectiveBatch_Request;
           2782                         ;
           2783                         ;  // Structure for CMD_OS_TEST_RF_SIGNAL request
           2784                         ;  TPerOSTestRfSignal_Request PerOSTestRfSignal_Request;
           2785                         ;
           2786                         ;  // Structure for CMD_OS_INDICATE request
           2787                         ;  TPerOSIndicate_Request PerOSIndicate_Request;
           2788                         ;
           2789                         ;  // Structure for CMD_OS_TEST_RF_SIGNAL response
           2790                         ;  TPerOSTestRfSignal_Response PerOSTestRfSignal_Response;
           2791                         ;
           2792                         ;  // Structure for general memory request
           2793                         ;  TPerMemoryRequest MemoryRequest;
           2794                         ;
           2795                         ;  // Structure for general extended memory request
           2796                         ;  TPerXMemoryRequest XMemoryRequest;
           2797                         ;
           2798                         ;  // Structure for CMD_IO requests
           2799                         ;  TPerIoDirectionAndSet_Request PerIoDirectionAndSet_Request;
           2800                         ;
           2801                         ;  // Structure returned by CMD_THERMOMETER_READ
           2802                         ;  TPerThermometerRead_Response PerThermometerRead_Response;
           2803                         ;
           2804                         ;  // Structure for CMD_UART_OPEN
           2805                         ;  TPerUartOpen_Request PerUartOpen_Request;
           2806                         ;
           2807                         ;  // Structure for CMD_UART_[CLEAR_]WRITE_READ
           2808                         ;  TPerUartWriteRead_Request PerUartWriteRead_Request;
           2809                         ;
           2810                         ;  // Structure for CMD_FRC_SEND
           2811                         ;  TPerFrcSend_Request PerFrcSend_Request;
           2812                         ;
           2813                         ;  // Structure returned by CMD_FRC_SEND and CMD_FRC_SEND_SELECTIVE
           2814                         ;  TPerFrcSend_Response PerFrcSend_Response;
           2815                         ;
           2816                         ;  // Structure for CMD_FRC_SEND_SELECTIVE
           2817                         ;  TPerFrcSendSelective_Request PerFrcSendSelective_Request;
           2818                         ;
           2819                         ;  // Structure for request and response of CMD_FRC_SET_PARAMS
           2820                         ;  TPerFrcSetParams_RequestResponse PerFrcSetParams_RequestResponse;
           2821                         ;
           2822                         ;  // Interface and CMD_COORDINATOR_BRIDGE confirmation structure
           2823                         ;  TIFaceConfirmation IFaceConfirmation;
           2824                         ;} TDpaMessage;
           2825                         ;
           2826                         ;// Custom DPA Handler events
           2827                         ;#define DpaEvent_DpaRequest               0
           2828                         ;#define DpaEvent_Interrupt                1
           2829                         ;#define DpaEvent_Idle                     2
           2830                         ;#define DpaEvent_Init                     3
           2831                         ;#define DpaEvent_Notification             4
           2832                         ;#define DpaEvent_AfterRouting             5
           2833                         ;#define DpaEvent_BeforeSleep              6
           2834                         ;#define DpaEvent_AfterSleep               7
           2835                         ;#define DpaEvent_Reset                    8
           2836                         ;#define DpaEvent_DisableInterrupts        9
           2837                         ;#define DpaEvent_FrcValue                 10
           2838                         ;#define DpaEvent_ReceiveDpaResponse       11
           2839                         ;#define DpaEvent_IFaceReceive             12
           2840                         ;#define DpaEvent_ReceiveDpaRequest        13
           2841                         ;#define DpaEvent_BeforeSendingDpaResponse 14
           2842                         ;#define DpaEvent_PeerToPeer               15
           2843                         ;#define DpaEvent_UserDpaValue             17
           2844                         ;#define DpaEvent_FrcResponseTime          18
           2845                         ;#if defined( TR7xD )
           2846                         ;#define DpaEvent_BondingButton            19
           2847                         ;#endif
           2848                         ;#define DpaEvent_Indicate                 20
           2849                         ;#define DpaEvent_VerifyLocalFrc           21
           2850                         ;#if !defined( TR7xD )
           2851                         ;#define DpaEvent_MenuActivated            22
           2852                         ;#define DpaEvent_MenuItemSelected         23
           2853                         ;#define DpaEvent_MenuItemFinalize         24
           2854                         ;#define DpaEvent_InStandby                25
           2855                         ;#endif
           2856                         ;
           2857                         ;#if defined( TR7xD )
           2858                         ;#define DpaEvent_LAST                     DpaEvent_VerifyLocalFrc
           2859                         ;#else
           2860                         ;#define DpaEvent_LAST                     DpaEvent_InStandby
           2861                         ;#endif
           2862                         ;
           2863                         ;// Types of the diagnostic DPA Value that is returned inside DPA response
           2864                         ;typedef enum
           2865                         ;{
           2866                         ;  DpaValueType_RSSI = 0,
           2867                         ;  DpaValueType_SupplyVoltage = 1,
           2868                         ;  DpaValueType_System = 2,
           2869                         ;  DpaValueType_User = 3
           2870                         ;} TDpaValueType;
           2871                         ;
           2872                         ;// Type (color) of LED peripheral
           2873                         ;typedef enum
           2874                         ;{
           2875                         ;  LED_COLOR_RED = 0,
           2876                         ;  LED_COLOR_GREEN = 1,
           2877                         ;  LED_COLOR_BLUE = 2,
           2878                         ;  LED_COLOR_YELLOW = 3,
           2879                         ;  LED_COLOR_WHITE = 4,
           2880                         ;  LED_COLOR_UNKNOWN = 0xff
           2881                         ;} TLedColor;
           2882                         ;
           2883                         ;// Baud rates
           2884                         ;typedef enum
           2885                         ;{
           2886                         ;  DpaBaud_1200 = 0x00,
           2887                         ;  DpaBaud_2400 = 0x01,
           2888                         ;  DpaBaud_4800 = 0x02,
           2889                         ;  DpaBaud_9600 = 0x03,
           2890                         ;  DpaBaud_19200 = 0x04,
           2891                         ;  DpaBaud_38400 = 0x05,
           2892                         ;  DpaBaud_57600 = 0x06,
           2893                         ;  DpaBaud_115200 = 0x07,
           2894                         ;  DpaBaud_230400 = 0x08
           2895                         ;} TBaudRates;
           2896                         ;
           2897                         ;// Useful PNUM_IO definitions
           2898                         ;typedef enum
           2899                         ;{
           2900                         ;  PNUM_IO_PORTA = 0x00,
           2901                         ;  PNUM_IO_TRISA = 0x00,
           2902                         ;
           2903                         ;  PNUM_IO_PORTB = 0x01,
           2904                         ;  PNUM_IO_TRISB = 0x01,
           2905                         ;
           2906                         ;  PNUM_IO_PORTC = 0x02,
           2907                         ;  PNUM_IO_TRISC = 0x02,
           2908                         ;
           2909                         ;  PNUM_IO_PORTE = 0x04,
           2910                         ;  PNUM_IO_TRISE = 0x04,
           2911                         ;
           2912                         ;  PNUM_IO_WPUB = 0x11,
           2913                         ;#if !defined( TR7xD )
           2914                         ;  PNUM_IO_WPUA = 0x10,
           2915                         ;  PNUM_IO_WPUC = 0x12,
           2916                         ;  PNUM_IO_WPUE = 0x14,
           2917                         ;#endif
           2918                         ;  PNUM_IO_DELAY = 0xff,
           2919                         ;} PNUM_IO_Definitions;
           2920                         ;
           2921                         ;// To test for enumeration peripherals request
           2922                         ;#define IsDpaEnumPeripheralsRequestNoSize() ( _PNUM == PNUM_ENUMERATION && _PCMD == CMD_GET_PER_INFO )
           2923                         ;
           2924                         ;#if PARAM_CHECK_LEVEL >= 2
           2925                         ;#define IsDpaEnumPeripheralsRequest() ( IsDpaEnumPeripheralsRequestNoSize() && _DpaDataLength == 0 )
           2926                         ;#else
           2927                         ;#define IsDpaEnumPeripheralsRequest() IsDpaEnumPeripheralsRequestNoSize()
           2928                         ;#endif
           2929                         ;
           2930                         ;// To test for peripherals information request
           2931                         ;#define IsDpaPeripheralInfoRequestNoSize()  ( _PNUM != PNUM_ENUMERATION && _PCMD == CMD_GET_PER_INFO )
           2932                         ;
           2933                         ;#if PARAM_CHECK_LEVEL >= 2
           2934                         ;#define IsDpaPeripheralInfoRequest()  ( IsDpaPeripheralInfoRequestNoSize() && _DpaDataLength == 0 )
           2935                         ;#else
           2936                         ;#define IsDpaPeripheralInfoRequest()  IsDpaPeripheralInfoRequestNoSize()
           2937                         ;#endif
           2938                         ;
           2939                         ;// Optimized macro for both testing enumeration peripherals ELSE peripherals information. See examples
           2940                         ;#define IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequestNoSize() if ( _PCMD == CMD_GET_PER_INFO ) if ( _PNUM == PNUM_ENUMERATION )
           2941                         ;
           2942                         ;#if PARAM_CHECK_LEVEL >= 2
           2943                         ;#define IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequest() if ( _DpaDataLength == 0 && _PCMD == CMD_GET_PER_INFO ) if ( _PNUM == PNUM_ENUMERATION )
           2944                         ;#else
           2945                         ;#define IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequest() IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequestNoSize()
           2946                         ;#endif
           2947                         ;
           2948                         ;#if defined( __CC5X__ ) && !defined( CC5XnotDPA )
           2949                         ;
           2950                         ;// DPA message at bufferRF
           2951                         ;TDpaMessage DpaRfMessage @bufferRF;
           2952                         ;
           2953                         ;// Note: Works only, because _DpaMessage.Request.PData is at the same location as bufferRF!
           2954                         ;#define _FSR_DPA    _FSR_RF
           2955                         ;
           2956                         ;// Actual allocation of the RAM Peripheral memory block @ UserBank_02
           2957                         ;bank12 uns8  PeripheralRam[PERIPHERAL_RAM_LENGTH] @ 0x620;
           2958                         ;
           2959                         ;// Actual DPA message parameters at memory
           2960                         ;#define _NADR           RX
           2961                         ;#define _NADRhigh       RTAUX
           2962                         ;#define _PNUM           PNUM
           2963                         ;#define _PCMD           PCMD
           2964                         ;#define _DpaDataLength  DLEN
           2965                         ;#define _DpaMessage     DpaRfMessage
           2966                         ;
           2967                         ;// Return actual DPA user routine event
           2968                         ;#define GetDpaEvent()   userReg0
           2969                         ;
           2970                         ;// Stores DPA Params inside DPA request/response
           2971                         ;#define _DpaParams      PPAR
           2972                         ;// Get DPA Value type out of the DPA Params
           2973                         ;#define DpaValueType()  ( _DpaParams & 0b11 )
           2974                         ;
           2975                         ;// When TRUE then encryptBufferRF/decryptBufferRF is done by AccessPassord
           2976                         ;bit encryptByAccessPassword @ usedBank0[0x23].7;
           2977                         ;
           2978                         ;// DP2P response time-slot time in 10 ms
           2979                         ;#define DP2P_TIMESLOT   11
           2980                         ;
           2981                         ;// DP2P request packet. Fills out the whole bufferRF.
           2982                         ;typedef struct
           2983                         ;{
           2984                         ;  uns8  Header[3];  // 0x000000
           2985                         ;  uns8  SelectedNodes[30];
           2986                         ;  uns8  SlotLength;
           2987                         ;  uns8  ResponseTxPower;
           2988                         ;  uns8  Reserved;
           2989                         ;  uns16 HWPID;
           2990                         ;  uns8  PDATA[sizeofBufferRF - ( 3 + 30 + 1 + 1 + 1 ) * sizeof( uns8 ) - ( 1 ) * sizeof( uns16 )]; // size is 26 bytes
           2991                         ;} STRUCTATTR TDP2Prequest;
           2992                         ;
           2993                         ;// DP2P invite packet.
           2994                         ;typedef struct
           2995                         ;{
           2996                         ;  uns8  Header[3];  // 0x000001
           2997                         ;  uns8  NADR;
           2998                         ;  uns8  Rand[12];
           2999                         ;} STRUCTATTR TDP2Invite;
           3000                         ;
           3001                         ;// DP2P confirm packet.
           3002                         ;typedef struct
           3003                         ;{
           3004                         ;  uns8  Header[3];  // 0x000003
           3005                         ;  uns8  NADR;
           3006                         ;  uns8  Rand[12];
           3007                         ;} STRUCTATTR TDP2Confirm;
           3008                         ;
           3009                         ;// DP2P response packet.
           3010                         ;typedef struct
           3011                         ;{
           3012                         ;  uns8  Header[3];  // 0xFfFfFf
           3013                         ;  uns8  NADR;
           3014                         ;  uns8  PDATA[DPA_MAX_DATA_LENGTH];
           3015                         ;} STRUCTATTR TDP2Presponse;
           3016                         ;
           3017                         ;#ifndef TR7xD
           3018                         ;
           3019                         ;// Menus
           3020                         ;#define DMENU_Online                                  0x0
           3021                         ;#define DMENU_ReadyToBond                             0x1
           3022                         ;#define DMENU_Beaming                                 0x2
           3023                         ;#define DMENU_Standby                                 0x3
           3024                         ;
           3025                         ;// Menu items
           3026                         ;#define DMENU_Item_None                               0x0
           3027                         ;#define DMENU_Item_Beaming                            ( DMENU_Online + 1 )
           3028                         ;#define DMENU_Item_BondRequest                        ( DMENU_ReadyToBond + 1 )
           3029                         ;#define DMENU_Item_ConnectivityCheck                  ( DMENU_Beaming + 1 )
           3030                         ;#define DMENU_Item_ExitStandby                        ( DMENU_Standby + 1 )
           3031                         ;#define DMENU_Item_StateIndication                    ( DMENU_Item_ExitStandby + 1 )
           3032                         ;#define DMENU_Item_User1                              ( DMENU_Item_StateIndication + 1 )
           3033                         ;#define DMENU_Item_User2                              ( DMENU_Item_User1 + 1 )
           3034                         ;#define DMENU_Item_Standby                            ( DMENU_Item_User2 + 1 )
           3035                         ;#define DMENU_Item_Reset                              ( DMENU_Item_Standby + 1 )
           3036                         ;#define DMENU_Item_UnbondAndRestart                   ( DMENU_Item_Reset + 2 )
           3037                         ;#define DMENU_Item_UnbondFactorySettingsAndRestart    ( DMENU_Item_UnbondAndRestart + 1 )
           3038                         ;
           3039                         ;// Flags for enabling/disabling menu items at event DpaEvent_MenuActivated (when TRUE is returned) and at DpaApiMenu call
           3040                         ;#define DMENU_Item_Implemented_Beaming                            0b0000.0001
           3041                         ;#define DMENU_Item_Implemented_User1                              0b0000.0100
           3042                         ;#define DMENU_Item_Implemented_User1Confirmed                     ( DMENU_Item_Implemented_User1 | DMENU_Item_Confirm_User1 )
           3043                         ;#define DMENU_Item_Implemented_User2                              0b0000.1000
           3044                         ;#define DMENU_Item_Implemented_User2Confirmed                     ( DMENU_Item_Implemented_User2 | DMENU_Item_Confirm_User2 )
           3045                         ;
           3046                         ;#define DMENU_Item_Unimplemented_Standby                          0b0001.0000
           3047                         ;#define DMENU_Item_Unimplemented_UnbondAndRestart                 0b0100.0000
           3048                         ;#define DMENU_Item_Unimplemented_UnbondFactorySettingsAndRestart  0b1000.0000
           3049                         ;
           3050                         ;#define DMENU_Item_Confirm_User1                                  0b0000.0010
           3051                         ;#define DMENU_Item_Confirm_User2                                  0b0010.0000
           3052                         ;
           3053                         ;// Flags for DpaEvent_MenuActivated when FALSE is returned
           3054                         ;#define DMENU_MenuActivated_DoNotOpen                             0b1000.0000
           3055                         ;
           3056                         ;// Macro to construct value containing both menu and item values
           3057                         ;#define MakeDMenuAndItem( menu, menuItem )            ( ((menu) << 4 ) | (menuItem) )
           3058                         ;// Macro to get menu from menu&item value
           3059                         ;#define GetDMenu( menuAndItem )                       ( (menuAndItem) >> 4 )
           3060                         ;// Macro to get menu item from menu&item value
           3061                         ;#define GetDMenuItem( menuAndItem )                   ( (menuAndItem) & 0x0F )
           3062                         ;
           3063                         ;#endif
           3064                         ;// Include assembler definitions
           3065                         ;#include "HexCodes.h"
           3066                         ;// CC5X fix
           3067                         ;#if __CC5X__ <= 3800 && _16LF18877 == 1
           3068                         ;#undef  __MOVLB
           3069                         ;#define __MOVLB(k)    (0x0140+((k)&0x3F))
           3070                         ;#endif
           3071                         ;
           3072                         ;// Next code must start at the IQRF APPLICATION routine entry point
           3073                         ;#pragma origin __APPLICATION_ADDRESS
     0000  3074         ORG 0x3A00
           3075 
           3076   ; FILE C:\makieta-miasta-iqrf\DPAcustomHandler.h
           3077                         ;// *********************************************************************
           3078                         ;//   Main Custom DPA Handler header                                    *
           3079                         ;// *********************************************************************
           3080                         ;// Copyright (c) MICRORISC s.r.o.
           3081                         ;//
           3082                         ;// File:    $RCSfile: DPAcustomHandler.h,v $
           3083                         ;// Version: $Revision: 1.167 $
           3084                         ;// Date:    $Date: 2024/12/05 09:28:58 $
           3085                         ;//
           3086                         ;// Revision history:
           3087                         ;//   2024/11/05  Release for DPA 4.32
           3088                         ;//   2024/04/17  Release for DPA 4.31
           3089                         ;//   2023/03/07  Release for DPA 4.30
           3090                         ;//   2022/10/05  Release for DPA 4.18
           3091                         ;//   2022/02/24  Release for DPA 4.17
           3092                         ;//   2021/08/20  Release for DPA 4.16
           3093                         ;//   2020/09/03  Release for DPA 4.15
           3094                         ;//   2020/04/03  Release for DPA 4.14
           3095                         ;//   2020/02/27  Release for DPA 4.13
           3096                         ;//   2020/01/09  Release for DPA 4.12
           3097                         ;//   2019/12/11  Release for DPA 4.11
           3098                         ;//   2019/10/09  Release for DPA 4.10
           3099                         ;//   2019/06/12  Release for DPA 4.03
           3100                         ;//   2019/06/03  Release for DPA 4.02
           3101                         ;//   2019/03/07  Release for DPA 4.01
           3102                         ;//   2019/01/10  Release for DPA 4.00
           3103                         ;//   2018/10/25  Release for DPA 3.03
           3104                         ;//   2017/11/16  Release for DPA 3.02
           3105                         ;//   2017/08/14  Release for DPA 3.01
           3106                         ;//   2017/03/13  Release for DPA 3.00
           3107                         ;//   2016/09/12  Release for DPA 2.28
           3108                         ;//   2016/04/14  Release for DPA 2.27
           3109                         ;//   2016/03/03  Release for DPA 2.26
           3110                         ;//   2016/01/21  Release for DPA 2.25
           3111                         ;//   2015/12/01  Release for DPA 2.24
           3112                         ;//   2015/10/23  Release for DPA 2.23
           3113                         ;//   2015/09/25  Release for DPA 2.22
           3114                         ;//   2015/09/03  Release for DPA 2.21
           3115                         ;//   2015/08/05  Release for DPA 2.20
           3116                         ;//   2014/10/31  Release for DPA 2.10
           3117                         ;//   2014/04/30  Release for DPA 2.00
           3118                         ;//   2013/10/03  Release for DPA 1.00
           3119                         ;//
           3120                         ;// *********************************************************************
           3121                         ;
           3122                         ;// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
           3123                         ;// IQRF Standards documentation https://doc.iqrf.org/
           3124                         ;
           3125                         ;#ifndef _CUSTOM_DPA_HANDLER_
           3126                         ;#define _CUSTOM_DPA_HANDLER_
           3127                         ;
           3128                         ;//############################################################################################
           3129                         ;// 1st include
           3130                         ;
           3131                         ;// Custom DPA Handler routine declaration
           3132                         ;bit CustomDpaHandler();
           3133                         ;
           3134                         ;// Various DPA flags shared between DPA and Custom DPA Handler
           3135                         ;uns8 DpaFlags @ usedBank4[0];
           3136                         ;
           3137                         ;// [C][N] TRUE if I2C timeout occurred at the last DpaApiI2C?() call
           3138                         ;bit I2CwasTimeout @ DpaFlags.0;
           3139                         ;// [N] Flag for the 1st DpaApiSleep
           3140                         ;bit FirstDpaApiSleep @ DpaFlags.1;
           3141                         ;
           3142                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           3143                         ;// [C] TRUE if interface master is not connected (detected)
           3144                         ;bit IFaceMasterNotConnected @ DpaFlags.2;
           3145                         ;#endif
           3146                         ;// [N] DPA by interface notification is sent also when there was a "reading" like DPA request
           3147                         ;bit EnableIFaceNotificationOnRead @ DpaFlags.3;
           3148                         ;// [N] TRUE when node was just bonded using default bonding procedure
           3149                         ;bit NodeWasBonded @ DpaFlags.4;
           3150                         ;// [N] When TRUE, then next call of DpaApiRfTxDpaPacket sends non-routed packet
           3151                         ;bit NonroutedRfTxDpaPacket @ DpaFlags.7;
           3152                         ;
           3153                         ;// [C] Ticks (decrementing) counter usable for timing in the coordinator's Customer DPA Handler
           3154                         ;uns16 DpaTicks @ usedBank4[1];
           3155                         ;// [N] toutRF for LP mode, read from configuration memory after reset
           3156                         ;uns8 LPtoutRF @ usedBank4[3];
           3157                         ;// DPA Request/Response HWPID
           3158                         ;uns16 _HWPID @ usedBank4[4];
           3159                         ;// Identifies type of reset (stored at UserReg0 upon module reset). See Reset chapter at IQRF User's Guide for more information
           3160                         ;uns8 ResetType @ usedBank4[6];
           3161                         ;// User DPA Values to return
           3162                         ;uns8 UserDpaValue @ usedBank4[7];
           3163                         ;// Network depth of the DPA request/response, increases on bridging, decreases on back-bridging
           3164                         ;uns8 NetDepth @ usedBank4[8];
           3165                         ;// TRUE when node was at DPA Service Mode after last boot
           3166                         ;bit DSMactivated @ usedBank4[9].0;
           3167                         ;// If set to TRUE, then LP RX mode in the main loop can be terminated by pin, see _RLPMAT
           3168                         ;bit LpRxPinTerminate @ usedBank4[9].1;
           3169                         ;// If set to TRUE, then [C] executes asynchronous DPA requests received from [N]
           3170                         ;bit AsyncReqAtCoordinator @ usedBank4[9].2;
           3171                         ;// RX filter used at the DPA main loop checkRF call
           3172                         ;uns8 RxFilter @ usedBank4[11];
           3173                         ;// Countdown variable for button bonding before going to deep sleep
           3174                         ;uns16 BondingSleepCountdown @ usedBank4[12];
           3175                         ;#define BONDING_SLEEP_COUNTDOWN_UNIT  290
           3176                         ;// Non-zero pseudo-random value, read-only, updated on every Reset and Idle event, at [N] only.
           3177                         ;uns16 Random @ usedBank4[14];
           3178                         ;// DPA value from the received packet or just to be sent to the interface.
           3179                         ;uns8 DpaValue @ usedBank4[16];
           3180                         ;// If non-zero then timeout value for DpaApiI2C?() calls
           3181                         ;uns8 I2Ctimeout @ usedBank4[17];
           3182                         ;
           3183                         ;// Macro to return an error from the peripheral handler. If the code size is not an issue this macro is the right choice.
           3184                         ;#define DpaApiReturnPeripheralError(error) do { \
           3185                         ;    DpaApiSetPeripheralError( error ); \
           3186                         ;    return Carry; \
           3187                         ;  } while( 0 )
           3188                         ;
           3189                         ;// DPA API functions, see documentation for details
           3190                         ;#define DpaApiRfTxDpaPacket( dpaValue, netDepthAndFlags ) DpaApiEntry( dpaValue, netDepthAndFlags, DPA_API_RFTX_DPAPACKET )
           3191                         ;#define DpaApiReadConfigByte( index )                     DpaApiEntry( index, param3.low8, DPA_API_READ_CONFIG_BYTE )
           3192                         ;#define DpaApiLocalRequest()                              DpaApiEntry( param2, param3.low8, DPA_API_LOCAL_REQUEST )
           3193                         ;#define DpaApiSetPeripheralError( error )                 DpaApiEntry( error, param3.low8, DPA_API_SET_PERIPHERAL_ERROR )
           3194                         ;#define DpaApiSendToIFaceMaster( dpaValue, flags )        DpaApiEntry( dpaValue, flags, DPA_API_SEND_TO_IFACEMASTER )
           3195                         ;#define DpaApiSetRfDefaults()                             DpaApiEntry( param2, param3.low8, DPA_API_SET_RF_DEFAULTS )
           3196                         ;#define DpaApiLocalFrc( frcCommand, replyTxPower )        DpaApiEntry( frcCommand, replyTxPower, DPA_API_LOCAL_FRC )
           3197                         ;#define DpaApiCrc8( crc8, data )                          DpaApiEntry( crc8, data, DPA_API_CRC8 )
           3198                         ;#define DpaApiAggregateFrc()                              DpaApiEntry( param2, param3.low8, DPA_API_AGGREGATE_FRC )
           3199                         ;#define DpaApiSetOTK()                                    DpaApiEntry( param2, param3.low8, DPA_API_SET_OTK )
           3200                         ;#define DpaApiI2Cinit( frequency )                        DpaApiEntry( frequency, param3.low8, DPA_API_I2C_INIT )
           3201                         ;#define DpaApiI2Cstart( address )                         DpaApiEntry( address, param3.low8, DPA_API_I2C_START )
           3202                         ;#define DpaApiI2Cwrite( data )                            DpaApiEntry( data, param3.low8, DPA_API_I2C_WRITE )
           3203                         ;#define DpaApiI2Cread( ack )                              DpaApiEntry( ack, param3.low8, DPA_API_I2C_READ )
           3204                         ;#define DpaApiI2Cstop()                                   DpaApiEntry( param2, param3.low8, DPA_API_I2C_STOP )
           3205                         ;#define DpaApiI2CwaitForACK( address )                    DpaApiEntry( address, param3.low8, DPA_API_I2C_WAIT_FOR_ACK )
           3206                         ;#define DpaApiI2Cshutdown()                               DpaApiEntry( param2, param3.low8, DPA_API_I2C_SHUTDOWN )
           3207                         ;#define DpaApiI2CwaitForIdle()                            DpaApiEntry( param2, param3.low8, DPA_API_I2C_WAIT_FOR_IDLE )
           3208                         ;#define DpaApiSleep( wdtcon )                             DpaApiEntry( wdtcon, param3.low8, DPA_API_SLEEP )
           3209                         ;#define DpaApiAfterSleep()                                DpaApiEntry( param2, param3.low8, DPA_API_AFTER_SLEEP )
           3210                         ;#define DpaApiRandom()                                    DpaApiEntry( param2, param3.low8, DPA_API_RANDOM )
           3211                         ;
           3212                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           3213                         ;#define DpaApiRfTxDpaPacketCoordinator()                  DpaApiEntry( param2, param3.low8, DPA_API_COORDINATOR_RFTX_DPAPACKET )
           3214                         ;#endif
           3215                         ;
           3216                         ;#if !defined( TR7xD )
           3217                         ;#define DpaApiMenu( menu, flags )                         DpaApiEntry( menu, flags, DPA_API_MENU )
           3218                         ;#define DpaApiMenuIndicateResult( ok )                    DpaApiEntry( ok, param3.low8, DPA_API_MENU_INDICATE_RESULT )
           3219                         ;#define DpaApiMenuExecute( menuAndItem )                  DpaApiEntry( menuAndItem, param3.low8, DPA_API_MENU_EXECUTE )
           3220                         ;#define DpaApiDeepSleep( wdtcon )                         DpaApiEntry( wdtcon, param3.low8, DPA_API_DEEP_SLEEP )
           3221                         ;#endif
           3222                         ;
           3223                         ;#define DpaApiLocalFrc_StackSaver( frcCommand, replyTxPower ) \
           3224                         ;  param2 = frcCommand; \
           3225                         ;  param3.low8 = replyTxPower; \
           3226                         ;  W = DPA_API_LOCAL_FRC; \
           3227                         ;  #asm \
           3228                         ;    DW  __MOVLP( DPA_API_ADDRESS >> 8 ); \
           3229                         ;    DW  __CALL( DPA_API_ADDRESS ); \
           3230                         ;    DW  __MOVLP( CUSTOM_HANDLER_ADDRESS >> 8 ); \
           3231                         ;  #endasm \
           3232                         ;
           3233                         ;#define I2CcomputeFrequency( I2Cfrequency)                ( ( ( F_OSC ) / ( ( I2Cfrequency ) * 4 ) ) - 1 )
           3234                         ;
           3235                         ;// Wrapper routines to be called instead of DpaApi??? macros to decrease code size if more than ~2 calls are needed
           3236                         ;void _DpaApiI2Cinit( uns8 frequency );
           3237                         ;void _DpaApiI2Cstart( uns8 address );
           3238                         ;void _DpaApiI2Cwrite( uns8 data );
           3239                         ;uns8 _DpaApiI2Cread( uns8 ack );
           3240                         ;void _DpaApiI2Cstop();
           3241                         ;void _DpaApiI2CwaitForACK( uns8 address );
           3242                         ;void _DpaApiI2Cshutdown();
           3243                         ;void _DpaApiI2CwaitForIdle();
           3244                         ;void _DpaApiSleep( uns8 wdtcon );
           3245                         ;#if !defined( TR7xD )
           3246                         ;void _DpaApiDeepSleep( uns8 wdtcon );
           3247                         ;#endif
           3248                         ;void _DpaApiSleepFirst( uns8 wdtcon );
           3249                         ;void _DpaApiAfterSleep();
           3250                         ;uns8 _DpaApiRandom();
           3251                         ;void _DpaApiSetRfDefaults();
           3252                         ;
           3253                         ;// Helper "multi" function to decrease code size if used more times
           3254                         ;void _DpaApiI2Cwrite0();
           3255                         ;void _DpaApiI2CwriteAndStop( uns8 data );
           3256                         ;uns8 _DpaApiI2CreadACK();
           3257                         ;uns8 _DpaApiI2CreadNACK();
           3258                         ;uns8 _DpaApiI2CreadNACKandStop();
           3259                         ;
           3260                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           3261                         ;#undef  DpaEvent_Interrupt
           3262                         ;#undef  DpaEvent_BeforeSleep
           3263                         ;#undef  DpaEvent_AfterSleep
           3264                         ;#undef  DpaEvent_FrcValue
           3265                         ;#undef  DpaEvent_FrcResponseTime
           3266                         ;#else
           3267                         ;#undef  DpaEvent_ReceiveDpaResponse
           3268                         ;#undef  DpaEvent_IFaceReceive
           3269                         ;#endif
           3270                         ;
           3271                         ;// To detect overlapping code in case someone would put some code before this header by mistake
           3272                         ;#pragma origin __APPLICATION_ADDRESS
     0000  3273         ORG 0x3A00
           3274                         ;#pragma updateBank 0
           3275                         ;
           3276                         ;//############################################################################################
           3277                         ;// Main IQRF entry point jumps to the main DPA entry point
           3278                         ;void APPLICATION()
           3279                         ;//############################################################################################
           3280                         ;{
           3281 APPLICATION
           3282                         ;  #asm
           3283                         ;    DW  __MOVLP( MAIN_DPA_ADDRESS >> 8 );
3A00 31AC  3284         DW    0x31AC
           3285                         ;  DW  __GOTO( MAIN_DPA_ADDRESS );
3A01 2C04  3286         DW    0x2C04
           3287                         ;  #endasm
           3288                         ;
           3289                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           3290                         ;    // Fake call to force CustomDpaHandler() compilation
           3291                         ;    CustomDpaHandler();
3A02 2220  3292         CALL  CustomDpaHandler
           3293                         ;#endif
           3294                         ;
           3295                         ;  // Fake call to force DpaApiEntry() compilation
           3296                         ;  DpaApiEntry( param2, param3.low8, W );
3A03 2A08  3297         GOTO  DpaApiEntry
           3298                         ;}
           3299                         ;
           3300                         ;//############################################################################################
           3301                         ;// Entry stub to the real DPA API entry
           3302                         ;#pragma origin DPA_API_ADDRESS_ENTRY
     0000  3303         ORG 0x3A08
           3304                         ;uns8  DpaApiEntry( uns8 par1 @ param2, uns8 par2 @ param3.low8, uns8 apiIndex @ W )
           3305                         ;//############################################################################################
           3306                         ;{
           3307 DpaApiEntry
           3308                         ;  #asm
           3309                         ;    DW  __MOVLP( DPA_API_ADDRESS >> 8 );
3A08 31AC  3310         DW    0x31AC
           3311                         ;  DW  __CALL( DPA_API_ADDRESS );
3A09 2400  3312         DW    0x2400
           3313                         ;  DW  __MOVLP( DPA_API_ADDRESS_ENTRY >> 8 );
3A0A 31BA  3314         DW    0x31BA
           3315                         ;  #endasm
           3316                         ;
           3317                         ;    return W;
3A0B 0008  3318         RETURN
           3319                         ;}
           3320                         ;
           3321                         ;//############################################################################################
           3322                         ;#pragma origin DPA_API_ADDRESS_ENTRY + 0x08
     0000  3323         ORG 0x3A10
           3324                         ;
           3325                         ;//############################################################################################
           3326                         ;
           3327                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           3328                         ;// Next comes Custom DPA handler routine
           3329                         ;#pragma origin CUSTOM_HANDLER_ADDRESS
     0000  3330         ORG 0x3A20
           3331                         ;#endif
           3332                         ;
           3333                         ;#pragma updateBank 1
           3334 
           3335   ; FILE C:\makieta-miasta-iqrf\CustomDpaHandler-Node.c
           3336                         ;// *********************************************************************
           3337                         ;//   Custom DPA Handler code template                                  *
           3338                         ;// *********************************************************************
           3339                         ;// Copyright (c) MICRORISC s.r.o.
           3340                         ;//
           3341                         ;// File:    $RCSfile: CustomDpaHandler-Template-Node.c,v $
           3342                         ;// Version: $Revision: 1.23 $
           3343                         ;// Date:    $Date: 2024/01/22 14:51:08 $
           3344                         ;//
           3345                         ;// Revision history:
           3346                         ;//   2023/03/07  Release for DPA 4.30
           3347                         ;//   2022/10/05  Release for DPA 4.18
           3348                         ;//   2022/02/24  Release for DPA 4.17
           3349                         ;//   2021/08/20  Release for DPA 4.16
           3350                         ;//   2020/09/03  Release for DPA 4.15
           3351                         ;//   2020/02/27  Release for DPA 4.13
           3352                         ;//   2019/01/10  Release for DPA 4.00
           3353                         ;//   2017/08/14  Release for DPA 3.01
           3354                         ;//   2017/03/13  Release for DPA 3.00
           3355                         ;//   2015/08/05  Release for DPA 2.20
           3356                         ;//   2014/10/31  Release for DPA 2.10
           3357                         ;//   2014/04/30  Release for DPA 2.00
           3358                         ;//
           3359                         ;// *********************************************************************
           3360                         ;
           3361                         ;// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
           3362                         ;
           3363                         ;// Default IQRF include (modify the path according to your setup)
           3364                         ;#include "IQRF.h"
           3365                         ;
           3366                         ;// Default DPA header (modify the path according to your setup)
           3367                         ;#include "DPA.h"
           3368                         ;// Default Custom DPA Handler header (modify the path according to your setup)
           3369                         ;#include "DPAcustomHandler.h"
           3370                         ;
           3371                         ;// Uncomment the following includes if the respective component is needed
           3372                         ;// IQRF standards header (modify the path according to your setup)
           3373                         ;//#include "IQRFstandard.h"
           3374                         ;//#include "IQRF_HWPID.h"
           3375                         ;//#include "NFC.c"
           3376                         ;
           3377                         ;//############################################################################################
           3378                         ;
           3379                         ;// Place for global variables shared among CustomDpaHandler() and other function, otherwise local [static] variables are recommended
           3380                         ;// example: uns8 globalCounter;
           3381                         ;
           3382                         ;// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
           3383                         ;//############################################################################################
           3384                         ;// https://doc.iqrf.org/DpaTechGuide/pages/custom-dpa-handler.html
           3385                         ;#define PIN1 2
           3386                         ;#define PIN2 3
           3387                         ;#define PIN3 5
           3388                         ;
           3389                         ;bit CustomDpaHandler()
           3390                         ;//############################################################################################
           3391                         ;{
           3392 CustomDpaHandler
           3393                         ;  // Handler presence mark
           3394                         ;  clrwdt();
3A20 0064  3395         CLRWDT
           3396                         ;
           3397                         ;  // Place for local static variables used only within CustomDpaHandler() among more events
           3398                         ;  // example: static bit interruptOccured;
           3399                         ;
           3400                         ;  // Detect DPA event to handle (unused event handlers can be commented out or even deleted)
           3401                         ;  switch ( GetDpaEvent() )
3A21 0870  3402         MOVF  userReg0,W
3A22 3A01  3403         XORLW 0x01
3A23 1903  3404         BTFSC 0x03,Zero_
3A24 3240  3405         BRA   m001
3A25 3A03  3406         XORLW 0x03
3A26 1903  3407         BTFSC 0x03,Zero_
3A27 2C54  3408         GOTO  m051
3A28 3A0A  3409         XORLW 0x0A
3A29 1903  3410         BTFSC 0x03,Zero_
3A2A 2C54  3411         GOTO  m051
3A2B 3A1C  3412         XORLW 0x1C
3A2C 1903  3413         BTFSC 0x03,Zero_
3A2D 2C54  3414         GOTO  m051
3A2E 3A17  3415         XORLW 0x17
3A2F 1903  3416         BTFSC 0x03,Zero_
3A30 3235  3417         BRA   m002
3A31 3A0E  3418         XORLW 0x0E
3A32 1903  3419         BTFSC 0x03,Zero_
3A33 2C54  3420         GOTO  m051
3A34 3A03  3421         XORLW 0x03
3A35 1903  3422         BTFSC 0x03,Zero_
3A36 2C54  3423         GOTO  m051
3A37 3A0A  3424         XORLW 0x0A
3A38 1903  3425         BTFSC 0x03,Zero_
3A39 3234  3426         BRA   m003
3A3A 3A01  3427         XORLW 0x01
3A3B 1903  3428         BTFSC 0x03,Zero_
3A3C 2C54  3429         GOTO  m051
3A3D 3A0F  3430         XORLW 0x0F
3A3E 1903  3431         BTFSC 0x03,Zero_
3A3F 2C54  3432         GOTO  m051
3A40 3A18  3433         XORLW 0x18
3A41 1903  3434         BTFSC 0x03,Zero_
3A42 2C54  3435         GOTO  m051
3A43 3A14  3436         XORLW 0x14
3A44 1903  3437         BTFSC 0x03,Zero_
3A45 2C54  3438         GOTO  m051
3A46 3A01  3439         XORLW 0x01
3A47 1903  3440         BTFSC 0x03,Zero_
3A48 2C54  3441         GOTO  m051
3A49 3A0E  3442         XORLW 0x0E
3A4A 1903  3443         BTFSC 0x03,Zero_
3A4B 2C54  3444         GOTO  m051
3A4C 3A06  3445         XORLW 0x06
3A4D 1903  3446         BTFSC 0x03,Zero_
3A4E 2C54  3447         GOTO  m051
3A4F 3A1E  3448         XORLW 0x1E
3A50 1903  3449         BTFSC 0x03,Zero_
3A51 2C54  3450         GOTO  m051
3A52 3A08  3451         XORLW 0x08
3A53 1903  3452         BTFSC 0x03,Zero_
3A54 2C54  3453         GOTO  m051
3A55 3A0C  3454         XORLW 0x0C
3A56 1903  3455         BTFSC 0x03,Zero_
3A57 2C54  3456         GOTO  m051
3A58 3A03  3457         XORLW 0x03
3A59 1903  3458         BTFSC 0x03,Zero_
3A5A 2C54  3459         GOTO  m051
3A5B 3A01  3460         XORLW 0x01
3A5C 1903  3461         BTFSC 0x03,Zero_
3A5D 2C54  3462         GOTO  m051
3A5E 3A0F  3463         XORLW 0x0F
3A5F 1903  3464         BTFSC 0x03,Zero_
3A60 2C54  3465         GOTO  m051
3A61 3A18  3466         XORLW 0x18
3A62 1903  3467         BTFSC 0x03,Zero_
3A63 2C32  3468         GOTO  m047
3A64 2C54  3469         GOTO  m051
           3470                         ;  {
           3471                         ;    // -------------------------------------------------
           3472                         ;    case DpaEvent_Interrupt:
           3473                         ;      // Do an extra quick background interrupt work
           3474                         ;      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
           3475                         ;      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
           3476                         ;      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the �empty� return handler ensures the shortest possible interrupt routine response time.
           3477                         ;      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
           3478                         ;      // ! Make sure race condition does not occur when accessing those variables at other places.
           3479                         ;      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
           3480                         ;      // ! Do not call any OS functions except setINDFx().
           3481                         ;      // ! Do not use any OS variables especially for writing access.
           3482                         ;      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.
           3483                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/EventInterrupt.html
           3484                         ;      return Carry;
3A65 0008  3485 m001    RETURN
           3486                         ;
           3487                         ;      // -------------------------------------------------
           3488                         ;    case DpaEvent_Idle:
           3489                         ;      // Do a quick background work when RF packet is not received
           3490                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/idle.html
           3491                         ;      break;
           3492                         ;
           3493                         ;      // -------------------------------------------------
           3494                         ;    case DpaEvent_Reset:
           3495                         ;      // Called after module is reset
           3496                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/ResetEvent.html
           3497                         ;
           3498                         ;      //goto DpaHandleReturnTRUE; // return TRUE only if you handle node bonding/unbonding
           3499                         ;      break;
           3500                         ;
           3501                         ;      // -------------------------------------------------
           3502                         ;#if defined( DpaEvent_BondingButton )
           3503                         ;    case DpaEvent_BondingButton:
           3504                         ;      // Called to allow a bonding button customization
           3505                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/bondingbutton.html
           3506                         ;
           3507                         ;      //goto DpaHandleReturnTRUE; // return TRUE to handle bonding button
           3508                         ;      break;
           3509                         ;#endif
           3510                         ;
           3511                         ;      // -------------------------------------------------
           3512                         ;    case DpaEvent_Indicate:
           3513                         ;      // Called to allow a customization of the device indication
           3514                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/IndicateEvent.html
           3515                         ;
           3516                         ;      //goto DpaHandleReturnTRUE; // return TRUE to skip default indication
           3517                         ;      break;
           3518                         ;
           3519                         ;      // -------------------------------------------------
           3520                         ;    case DpaEvent_Init:
           3521                         ;      // Do a one time initialization before main loop starts
           3522                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/init.html
           3523                         ;        TRISC.PIN1 = 0;
3A66 0140  3524 m002    MOVLB 0x00
3A67 1113  3525         BCF   TRISC,2
           3526                         ;	    TRISC.PIN2 = 0;
3A68 1193  3527         BCF   TRISC,3
           3528                         ;        TRISC.PIN3 = 0;
3A69 1293  3529         BCF   TRISC,5
           3530                         ;	    LATC.PIN1 = 0;
3A6A 1118  3531         BCF   LATC,2
           3532                         ;	    LATC.PIN2 = 0;
3A6B 1198  3533         BCF   LATC,3
           3534                         ;	    LATC.PIN3 = 0;
3A6C 1298  3535         BCF   LATC,5
           3536                         ;      break;
3A6D 2C54  3537         GOTO  m051
           3538                         ;
           3539                         ;      // -------------------------------------------------
           3540                         ;    case DpaEvent_ReceiveDpaRequest:
           3541                         ;      // Called after DPA request was received
           3542                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/receivedparequest.html
           3543                         ;
           3544                         ;      //goto DpaHandleReturnTRUE; // return TRUE to skip default processing
           3545                         ;      break;
           3546                         ;
           3547                         ;      // -------------------------------------------------
           3548                         ;    case DpaEvent_BeforeSendingDpaResponse:
           3549                         ;      // Called before sending DPA response back to originator of DPA response
           3550                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/beforesendingdparesponse.html
           3551                         ;      break;
           3552                         ;
           3553                         ;      // -------------------------------------------------
           3554                         ;    case DpaEvent_Notification:
           3555                         ;        if ( _PNUM == PNUM_RAM && _PCMD == CMD_RAM_WRITE )
3A6E 0145  3556 m003    MOVLB 0x05
3A6F 082E  3557         MOVF  PNUM,W
3A70 3A05  3558         XORLW 0x05
3A71 1D03  3559         BTFSS 0x03,Zero_
3A72 2C54  3560         GOTO  m051
3A73 0B2F  3561         DECFSZ PCMD,W
3A74 2C54  3562         GOTO  m051
           3563                         ;        {
           3564                         ;            // w pamięci ram od bajtu 0 zapisana jest sekwencja
           3565                         ;            // kończy się na bajcie o wartości 0
           3566                         ;            // przy miganiu zakładany jest stan 0 na początku i końcu
           3567                         ;            // syntax w bajtach kolejno (max 55!:
           3568                         ;            // <kod> <czas czekania (ms)> <mnożnik opóźnienia> (<mnożnik świecenia przy miganiu>) (<ilość przy miganiu>) ... 0x00 / koniec
           3569                         ;            // kody:
           3570                         ;            // 0x00 - koniec
           3571                         ;            // 0x01 - wylacz pin 1
           3572                         ;            // 0x02 - wlacz pin 1
           3573                         ;            // 0x03 - migaj pin 1
           3574                         ;            // 0x04 - wylacz pin 2
           3575                         ;            // 0x05 - wlacz pin 2
           3576                         ;            // 0x06 - migaj pin 2
           3577                         ;            // 0x07 - wylacz pin 3
           3578                         ;            // 0x08 - wlacz pin 3
           3579                         ;            // 0x09 - migaj pin 3
           3580                         ;
           3581                         ;            // W przyszłości możnaby skompresować rozkazy w przypadku potrzeby
           3582                         ;
           3583                         ;            uns8 index = 0;
3A75 014B  3584         MOVLB 0x0B
3A76 01C0  3585         CLRF  index
           3586                         ;            while (PeripheralRam[index] != 0x00 && index < 52) {
3A77 3020  3587 m004    MOVLW 0x20
3A78 014B  3588         MOVLB 0x0B
3A79 0740  3589         ADDWF index,W
3A7A 0084  3590         MOVWF FSR0L
3A7B 3006  3591         MOVLW 0x06
3A7C 0085  3592         MOVWF FSR0H
3A7D 0800  3593         MOVF  INDF0,W
3A7E 1903  3594         BTFSC 0x03,Zero_
3A7F 2C54  3595         GOTO  m051
3A80 3034  3596         MOVLW 0x34
3A81 0240  3597         SUBWF index,W
3A82 1803  3598         BTFSC 0x03,Carry
3A83 2C54  3599         GOTO  m051
           3600                         ;                // miganie nie może być wtedy zakodowane
           3601                         ;                if (index >= 50 && (PeripheralRam[index] == 0x03 || PeripheralRam[index] == 0x06 || PeripheralRam[index] == 0x09)) {
3A84 3032  3602         MOVLW 0x32
3A85 0240  3603         SUBWF index,W
3A86 1C03  3604         BTFSS 0x03,Carry
3A87 321D  3605         BRA   m006
3A88 3020  3606         MOVLW 0x20
3A89 0740  3607         ADDWF index,W
3A8A 0084  3608         MOVWF FSR0L
3A8B 3006  3609         MOVLW 0x06
3A8C 0085  3610         MOVWF FSR0H
3A8D 0800  3611         MOVF  INDF0,W
3A8E 3A03  3612         XORLW 0x03
3A8F 1903  3613         BTFSC 0x03,Zero_
3A90 3212  3614         BRA   m005
3A91 3020  3615         MOVLW 0x20
3A92 0740  3616         ADDWF index,W
3A93 0084  3617         MOVWF FSR0L
3A94 3006  3618         MOVLW 0x06
3A95 0085  3619         MOVWF FSR0H
3A96 0800  3620         MOVF  INDF0,W
3A97 3A06  3621         XORLW 0x06
3A98 1903  3622         BTFSC 0x03,Zero_
3A99 3209  3623         BRA   m005
3A9A 3020  3624         MOVLW 0x20
3A9B 0740  3625         ADDWF index,W
3A9C 0084  3626         MOVWF FSR0L
3A9D 3006  3627         MOVLW 0x06
3A9E 0085  3628         MOVWF FSR0H
3A9F 0800  3629         MOVF  INDF0,W
3AA0 3A09  3630         XORLW 0x09
3AA1 1D03  3631         BTFSS 0x03,Zero_
3AA2 3202  3632         BRA   m006
           3633                         ;                    return 0;
3AA3 1003  3634 m005    BCF   0x03,Carry
3AA4 0008  3635         RETURN
           3636                         ;                }
           3637                         ;
           3638                         ;                switch (PeripheralRam[index]) {
3AA5 3020  3639 m006    MOVLW 0x20
3AA6 014B  3640         MOVLB 0x0B
3AA7 0740  3641         ADDWF index,W
3AA8 0084  3642         MOVWF FSR0L
3AA9 3006  3643         MOVLW 0x06
3AAA 0085  3644         MOVWF FSR0H
3AAB 0800  3645         MOVF  INDF0,W
3AAC 3A01  3646         XORLW 0x01
3AAD 1903  3647         BTFSC 0x03,Zero_
3AAE 3219  3648         BRA   m007
3AAF 3A03  3649         XORLW 0x03
3AB0 1903  3650         BTFSC 0x03,Zero_
3AB1 3231  3651         BRA   m010
3AB2 3A01  3652         XORLW 0x01
3AB3 1903  3653         BTFSC 0x03,Zero_
3AB4 3249  3654         BRA   m013
3AB5 3A07  3655         XORLW 0x07
3AB6 1903  3656         BTFSC 0x03,Zero_
3AB7 3288  3657         BRA   m020
3AB8 3A01  3658         XORLW 0x01
3AB9 1903  3659         BTFSC 0x03,Zero_
3ABA 32A0  3660         BRA   m023
3ABB 3A03  3661         XORLW 0x03
3ABC 1903  3662         BTFSC 0x03,Zero_
3ABD 32B8  3663         BRA   m026
3ABE 3A01  3664         XORLW 0x01
3ABF 1903  3665         BTFSC 0x03,Zero_
3AC0 32F7  3666         BRA   m033
3AC1 3A0F  3667         XORLW 0x0F
3AC2 1903  3668         BTFSC 0x03,Zero_
3AC3 2BD3  3669         GOTO  m036
3AC4 3A01  3670         XORLW 0x01
3AC5 1903  3671         BTFSC 0x03,Zero_
3AC6 2BEE  3672         GOTO  m039
3AC7 2C30  3673         GOTO  m046
           3674                         ;                    case 0x01:
           3675                         ;                    {
           3676                         ;                        uns8 counter = 0;
3AC8 014B  3677 m007    MOVLB 0x0B
3AC9 01C1  3678         CLRF  counter
           3679                         ;                        while (counter < PeripheralRam[index + 2]) {
3ACA 3022  3680 m008    MOVLW 0x22
3ACB 014B  3681         MOVLB 0x0B
3ACC 0740  3682         ADDWF index,W
3ACD 0084  3683         MOVWF FSR0L
3ACE 3006  3684         MOVLW 0x06
3ACF 0085  3685         MOVWF FSR0H
3AD0 0800  3686         MOVF  INDF0,W
3AD1 0241  3687         SUBWF counter,W
3AD2 1803  3688         BTFSC 0x03,Carry
3AD3 3209  3689         BRA   m009
           3690                         ;                            waitMS(PeripheralRam[index + 1]);
3AD4 3021  3691         MOVLW 0x21
3AD5 0740  3692         ADDWF index,W
3AD6 0084  3693         MOVWF FSR0L
3AD7 3006  3694         MOVLW 0x06
3AD8 0085  3695         MOVWF FSR0H
3AD9 0800  3696         MOVF  INDF0,W
3ADA 2076  3697         CALL  waitMS
           3698                         ;                            counter++;
3ADB 0AC1  3699         INCF  counter,1
           3700                         ;                        }
3ADC 33ED  3701         BRA   m008
           3702                         ;                        LATC.PIN1 = 0;
3ADD 0140  3703 m009    MOVLB 0x00
3ADE 1118  3704         BCF   LATC,2
           3705                         ;                        index += 3;
3ADF 3003  3706         MOVLW 0x03
3AE0 014B  3707         MOVLB 0x0B
3AE1 07C0  3708         ADDWF index,1
           3709                         ;                    }
           3710                         ;                        break;
3AE2 3394  3711         BRA   m004
           3712                         ;                    case 0x02:
           3713                         ;                    {
           3714                         ;                        uns8 counter = 0;
3AE3 014B  3715 m010    MOVLB 0x0B
3AE4 01C1  3716         CLRF  counter_2
           3717                         ;                        while (counter < PeripheralRam[index + 2]) {
3AE5 3022  3718 m011    MOVLW 0x22
3AE6 014B  3719         MOVLB 0x0B
3AE7 0740  3720         ADDWF index,W
3AE8 0084  3721         MOVWF FSR0L
3AE9 3006  3722         MOVLW 0x06
3AEA 0085  3723         MOVWF FSR0H
3AEB 0800  3724         MOVF  INDF0,W
3AEC 0241  3725         SUBWF counter_2,W
3AED 1803  3726         BTFSC 0x03,Carry
3AEE 3209  3727         BRA   m012
           3728                         ;                            waitMS(PeripheralRam[index + 1]);
3AEF 3021  3729         MOVLW 0x21
3AF0 0740  3730         ADDWF index,W
3AF1 0084  3731         MOVWF FSR0L
3AF2 3006  3732         MOVLW 0x06
3AF3 0085  3733         MOVWF FSR0H
3AF4 0800  3734         MOVF  INDF0,W
3AF5 2076  3735         CALL  waitMS
           3736                         ;                            counter++;
3AF6 0AC1  3737         INCF  counter_2,1
           3738                         ;                        }
3AF7 33ED  3739         BRA   m011
           3740                         ;                        LATC.PIN1 = 1;
3AF8 0140  3741 m012    MOVLB 0x00
3AF9 1518  3742         BSF   LATC,2
           3743                         ;                        index += 3;
3AFA 3003  3744         MOVLW 0x03
3AFB 014B  3745         MOVLB 0x0B
3AFC 07C0  3746         ADDWF index,1
           3747                         ;                    }
           3748                         ;                        break;
3AFD 3379  3749         BRA   m004
           3750                         ;                    case 0x03:
           3751                         ;                    {
           3752                         ;                        LATC.PIN1 = 0;
3AFE 0140  3753 m013    MOVLB 0x00
3AFF 1118  3754         BCF   LATC,2
           3755                         ;                        uns8 blinks = 0;
3B00 014B  3756         MOVLB 0x0B
3B01 01C1  3757         CLRF  blinks
           3758                         ;                        while (blinks < PeripheralRam[index + 4]) {
3B02 3024  3759 m014    MOVLW 0x24
3B03 014B  3760         MOVLB 0x0B
3B04 0740  3761         ADDWF index,W
3B05 0084  3762         MOVWF FSR0L
3B06 3006  3763         MOVLW 0x06
3B07 0085  3764         MOVWF FSR0H
3B08 0800  3765         MOVF  INDF0,W
3B09 0241  3766         SUBWF blinks,W
3B0A 1803  3767         BTFSC 0x03,Carry
3B0B 3230  3768         BRA   m019
           3769                         ;                            uns8 counter = 0;
3B0C 01C2  3770         CLRF  counter_3
           3771                         ;                            while (counter < PeripheralRam[index + 2]) {
3B0D 3022  3772 m015    MOVLW 0x22
3B0E 014B  3773         MOVLB 0x0B
3B0F 0740  3774         ADDWF index,W
3B10 0084  3775         MOVWF FSR0L
3B11 3006  3776         MOVLW 0x06
3B12 0085  3777         MOVWF FSR0H
3B13 0800  3778         MOVF  INDF0,W
3B14 0242  3779         SUBWF counter_3,W
3B15 1803  3780         BTFSC 0x03,Carry
3B16 3209  3781         BRA   m016
           3782                         ;                                waitMS(PeripheralRam[index + 1]);
3B17 3021  3783         MOVLW 0x21
3B18 0740  3784         ADDWF index,W
3B19 0084  3785         MOVWF FSR0L
3B1A 3006  3786         MOVLW 0x06
3B1B 0085  3787         MOVWF FSR0H
3B1C 0800  3788         MOVF  INDF0,W
3B1D 2076  3789         CALL  waitMS
           3790                         ;                                counter++;
3B1E 0AC2  3791         INCF  counter_3,1
           3792                         ;                            }
3B1F 33ED  3793         BRA   m015
           3794                         ;                            LATC.PIN1 = 1;
3B20 0140  3795 m016    MOVLB 0x00
3B21 1518  3796         BSF   LATC,2
           3797                         ;                            counter = 0;
3B22 014B  3798         MOVLB 0x0B
3B23 01C2  3799         CLRF  counter_3
           3800                         ;                            while (counter < PeripheralRam[index + 3]) {
3B24 3023  3801 m017    MOVLW 0x23
3B25 014B  3802         MOVLB 0x0B
3B26 0740  3803         ADDWF index,W
3B27 0084  3804         MOVWF FSR0L
3B28 3006  3805         MOVLW 0x06
3B29 0085  3806         MOVWF FSR0H
3B2A 0800  3807         MOVF  INDF0,W
3B2B 0242  3808         SUBWF counter_3,W
3B2C 1803  3809         BTFSC 0x03,Carry
3B2D 3209  3810         BRA   m018
           3811                         ;                                waitMS(PeripheralRam[index + 1]);
3B2E 3021  3812         MOVLW 0x21
3B2F 0740  3813         ADDWF index,W
3B30 0084  3814         MOVWF FSR0L
3B31 3006  3815         MOVLW 0x06
3B32 0085  3816         MOVWF FSR0H
3B33 0800  3817         MOVF  INDF0,W
3B34 2076  3818         CALL  waitMS
           3819                         ;                                counter++;
3B35 0AC2  3820         INCF  counter_3,1
           3821                         ;                            }
3B36 33ED  3822         BRA   m017
           3823                         ;                            LATC.PIN1 = 0;
3B37 0140  3824 m018    MOVLB 0x00
3B38 1118  3825         BCF   LATC,2
           3826                         ;                            blinks++;
3B39 014B  3827         MOVLB 0x0B
3B3A 0AC1  3828         INCF  blinks,1
           3829                         ;                        }
3B3B 33C6  3830         BRA   m014
           3831                         ;                        index += 5;
3B3C 3005  3832 m019    MOVLW 0x05
3B3D 014B  3833         MOVLB 0x0B
3B3E 07C0  3834         ADDWF index,1
           3835                         ;                    }
           3836                         ;                        break;
3B3F 3337  3837         BRA   m004
           3838                         ;                    case 0x04:
           3839                         ;                    {
           3840                         ;                        uns8 counter = 0;
3B40 014B  3841 m020    MOVLB 0x0B
3B41 01C1  3842         CLRF  counter_4
           3843                         ;                        while (counter < PeripheralRam[index + 2]) {
3B42 3022  3844 m021    MOVLW 0x22
3B43 014B  3845         MOVLB 0x0B
3B44 0740  3846         ADDWF index,W
3B45 0084  3847         MOVWF FSR0L
3B46 3006  3848         MOVLW 0x06
3B47 0085  3849         MOVWF FSR0H
3B48 0800  3850         MOVF  INDF0,W
3B49 0241  3851         SUBWF counter_4,W
3B4A 1803  3852         BTFSC 0x03,Carry
3B4B 3209  3853         BRA   m022
           3854                         ;                            waitMS(PeripheralRam[index + 1]);
3B4C 3021  3855         MOVLW 0x21
3B4D 0740  3856         ADDWF index,W
3B4E 0084  3857         MOVWF FSR0L
3B4F 3006  3858         MOVLW 0x06
3B50 0085  3859         MOVWF FSR0H
3B51 0800  3860         MOVF  INDF0,W
3B52 2076  3861         CALL  waitMS
           3862                         ;                            counter++;
3B53 0AC1  3863         INCF  counter_4,1
           3864                         ;                        }
3B54 33ED  3865         BRA   m021
           3866                         ;                        LATC.PIN2 = 0;
3B55 0140  3867 m022    MOVLB 0x00
3B56 1198  3868         BCF   LATC,3
           3869                         ;                        index += 3;
3B57 3003  3870         MOVLW 0x03
3B58 014B  3871         MOVLB 0x0B
3B59 07C0  3872         ADDWF index,1
           3873                         ;                    }
           3874                         ;                        break;
3B5A 331C  3875         BRA   m004
           3876                         ;                    case 0x05:
           3877                         ;                    {
           3878                         ;                        uns8 counter = 0;
3B5B 014B  3879 m023    MOVLB 0x0B
3B5C 01C1  3880         CLRF  counter_5
           3881                         ;                        while (counter < PeripheralRam[index + 2]) {
3B5D 3022  3882 m024    MOVLW 0x22
3B5E 014B  3883         MOVLB 0x0B
3B5F 0740  3884         ADDWF index,W
3B60 0084  3885         MOVWF FSR0L
3B61 3006  3886         MOVLW 0x06
3B62 0085  3887         MOVWF FSR0H
3B63 0800  3888         MOVF  INDF0,W
3B64 0241  3889         SUBWF counter_5,W
3B65 1803  3890         BTFSC 0x03,Carry
3B66 3209  3891         BRA   m025
           3892                         ;                            waitMS(PeripheralRam[index + 1]);
3B67 3021  3893         MOVLW 0x21
3B68 0740  3894         ADDWF index,W
3B69 0084  3895         MOVWF FSR0L
3B6A 3006  3896         MOVLW 0x06
3B6B 0085  3897         MOVWF FSR0H
3B6C 0800  3898         MOVF  INDF0,W
3B6D 2076  3899         CALL  waitMS
           3900                         ;                            counter++;
3B6E 0AC1  3901         INCF  counter_5,1
           3902                         ;                        }
3B6F 33ED  3903         BRA   m024
           3904                         ;                        LATC.PIN2 = 1;
3B70 0140  3905 m025    MOVLB 0x00
3B71 1598  3906         BSF   LATC,3
           3907                         ;                        index += 3;
3B72 3003  3908         MOVLW 0x03
3B73 014B  3909         MOVLB 0x0B
3B74 07C0  3910         ADDWF index,1
           3911                         ;                    }
           3912                         ;                        break;
3B75 3301  3913         BRA   m004
           3914                         ;                    case 0x06:
           3915                         ;                    {
           3916                         ;                        LATC.PIN2 = 0;
3B76 0140  3917 m026    MOVLB 0x00
3B77 1198  3918         BCF   LATC,3
           3919                         ;                        uns8 blinks = 0;
3B78 014B  3920         MOVLB 0x0B
3B79 01C1  3921         CLRF  blinks_2
           3922                         ;                        while (blinks < PeripheralRam[index + 4]) {
3B7A 3024  3923 m027    MOVLW 0x24
3B7B 014B  3924         MOVLB 0x0B
3B7C 0740  3925         ADDWF index,W
3B7D 0084  3926         MOVWF FSR0L
3B7E 3006  3927         MOVLW 0x06
3B7F 0085  3928         MOVWF FSR0H
3B80 0800  3929         MOVF  INDF0,W
3B81 0241  3930         SUBWF blinks_2,W
3B82 1803  3931         BTFSC 0x03,Carry
3B83 3230  3932         BRA   m032
           3933                         ;                            uns8 counter = 0;
3B84 01C2  3934         CLRF  counter_6
           3935                         ;                            while (counter < PeripheralRam[index + 2]) {
3B85 3022  3936 m028    MOVLW 0x22
3B86 014B  3937         MOVLB 0x0B
3B87 0740  3938         ADDWF index,W
3B88 0084  3939         MOVWF FSR0L
3B89 3006  3940         MOVLW 0x06
3B8A 0085  3941         MOVWF FSR0H
3B8B 0800  3942         MOVF  INDF0,W
3B8C 0242  3943         SUBWF counter_6,W
3B8D 1803  3944         BTFSC 0x03,Carry
3B8E 3209  3945         BRA   m029
           3946                         ;                                waitMS(PeripheralRam[index + 1]);
3B8F 3021  3947         MOVLW 0x21
3B90 0740  3948         ADDWF index,W
3B91 0084  3949         MOVWF FSR0L
3B92 3006  3950         MOVLW 0x06
3B93 0085  3951         MOVWF FSR0H
3B94 0800  3952         MOVF  INDF0,W
3B95 2076  3953         CALL  waitMS
           3954                         ;                                counter++;
3B96 0AC2  3955         INCF  counter_6,1
           3956                         ;                            }
3B97 33ED  3957         BRA   m028
           3958                         ;                            LATC.PIN2 = 1;
3B98 0140  3959 m029    MOVLB 0x00
3B99 1598  3960         BSF   LATC,3
           3961                         ;                            counter = 0;
3B9A 014B  3962         MOVLB 0x0B
3B9B 01C2  3963         CLRF  counter_6
           3964                         ;                            while (counter < PeripheralRam[index + 3]) {
3B9C 3023  3965 m030    MOVLW 0x23
3B9D 014B  3966         MOVLB 0x0B
3B9E 0740  3967         ADDWF index,W
3B9F 0084  3968         MOVWF FSR0L
3BA0 3006  3969         MOVLW 0x06
3BA1 0085  3970         MOVWF FSR0H
3BA2 0800  3971         MOVF  INDF0,W
3BA3 0242  3972         SUBWF counter_6,W
3BA4 1803  3973         BTFSC 0x03,Carry
3BA5 3209  3974         BRA   m031
           3975                         ;                                waitMS(PeripheralRam[index + 1]);
3BA6 3021  3976         MOVLW 0x21
3BA7 0740  3977         ADDWF index,W
3BA8 0084  3978         MOVWF FSR0L
3BA9 3006  3979         MOVLW 0x06
3BAA 0085  3980         MOVWF FSR0H
3BAB 0800  3981         MOVF  INDF0,W
3BAC 2076  3982         CALL  waitMS
           3983                         ;                                counter++;
3BAD 0AC2  3984         INCF  counter_6,1
           3985                         ;                            }
3BAE 33ED  3986         BRA   m030
           3987                         ;                            LATC.PIN2 = 0;
3BAF 0140  3988 m031    MOVLB 0x00
3BB0 1198  3989         BCF   LATC,3
           3990                         ;                            blinks++;
3BB1 014B  3991         MOVLB 0x0B
3BB2 0AC1  3992         INCF  blinks_2,1
           3993                         ;                        }
3BB3 33C6  3994         BRA   m027
           3995                         ;                        index += 5;
3BB4 3005  3996 m032    MOVLW 0x05
3BB5 014B  3997         MOVLB 0x0B
3BB6 07C0  3998         ADDWF index,1
           3999                         ;                    }
           4000                         ;                        break;
3BB7 2A77  4001         GOTO  m004
           4002                         ;                    case 0x07:
           4003                         ;                    {
           4004                         ;                        uns8 counter = 0;
3BB8 014B  4005 m033    MOVLB 0x0B
3BB9 01C1  4006         CLRF  counter_7
           4007                         ;                        while (counter < PeripheralRam[index + 2]) {
3BBA 3022  4008 m034    MOVLW 0x22
3BBB 014B  4009         MOVLB 0x0B
3BBC 0740  4010         ADDWF index,W
3BBD 0084  4011         MOVWF FSR0L
3BBE 3006  4012         MOVLW 0x06
3BBF 0085  4013         MOVWF FSR0H
3BC0 0800  4014         MOVF  INDF0,W
3BC1 0241  4015         SUBWF counter_7,W
3BC2 1803  4016         BTFSC 0x03,Carry
3BC3 3209  4017         BRA   m035
           4018                         ;                            waitMS(PeripheralRam[index + 1]);
3BC4 3021  4019         MOVLW 0x21
3BC5 0740  4020         ADDWF index,W
3BC6 0084  4021         MOVWF FSR0L
3BC7 3006  4022         MOVLW 0x06
3BC8 0085  4023         MOVWF FSR0H
3BC9 0800  4024         MOVF  INDF0,W
3BCA 2076  4025         CALL  waitMS
           4026                         ;                            counter++;
3BCB 0AC1  4027         INCF  counter_7,1
           4028                         ;                        }
3BCC 33ED  4029         BRA   m034
           4030                         ;                        LATC.PIN3 = 0;
3BCD 0140  4031 m035    MOVLB 0x00
3BCE 1298  4032         BCF   LATC,5
           4033                         ;                        index += 3;
3BCF 3003  4034         MOVLW 0x03
3BD0 014B  4035         MOVLB 0x0B
3BD1 07C0  4036         ADDWF index,1
           4037                         ;                    }
           4038                         ;                        break;
3BD2 2A77  4039         GOTO  m004
           4040                         ;                    case 0x08:
           4041                         ;                    {
           4042                         ;                        uns8 counter = 0;
3BD3 014B  4043 m036    MOVLB 0x0B
3BD4 01C1  4044         CLRF  counter_8
           4045                         ;                        while (counter < PeripheralRam[index + 2]) {
3BD5 3022  4046 m037    MOVLW 0x22
3BD6 014B  4047         MOVLB 0x0B
3BD7 0740  4048         ADDWF index,W
3BD8 0084  4049         MOVWF FSR0L
3BD9 3006  4050         MOVLW 0x06
3BDA 0085  4051         MOVWF FSR0H
3BDB 0800  4052         MOVF  INDF0,W
3BDC 0241  4053         SUBWF counter_8,W
3BDD 1803  4054         BTFSC 0x03,Carry
3BDE 3209  4055         BRA   m038
           4056                         ;                            waitMS(PeripheralRam[index + 1]);
3BDF 3021  4057         MOVLW 0x21
3BE0 0740  4058         ADDWF index,W
3BE1 0084  4059         MOVWF FSR0L
3BE2 3006  4060         MOVLW 0x06
3BE3 0085  4061         MOVWF FSR0H
3BE4 0800  4062         MOVF  INDF0,W
3BE5 2076  4063         CALL  waitMS
           4064                         ;                            counter++;
3BE6 0AC1  4065         INCF  counter_8,1
           4066                         ;                        }
3BE7 33ED  4067         BRA   m037
           4068                         ;                        LATC.PIN3 = 1;
3BE8 0140  4069 m038    MOVLB 0x00
3BE9 1698  4070         BSF   LATC,5
           4071                         ;                        index += 3;
3BEA 3003  4072         MOVLW 0x03
3BEB 014B  4073         MOVLB 0x0B
3BEC 07C0  4074         ADDWF index,1
           4075                         ;                    }
           4076                         ;                        break;
3BED 2A77  4077         GOTO  m004
           4078                         ;                    case 0x09:
           4079                         ;                    {
           4080                         ;                        LATC.PIN3 = 0;
3BEE 0140  4081 m039    MOVLB 0x00
3BEF 1298  4082         BCF   LATC,5
           4083                         ;                        uns8 blinks = 0;
3BF0 014B  4084         MOVLB 0x0B
3BF1 01C1  4085         CLRF  blinks_3
           4086                         ;                        while (blinks < PeripheralRam[index + 4]) {
3BF2 3024  4087 m040    MOVLW 0x24
3BF3 014B  4088         MOVLB 0x0B
3BF4 0740  4089         ADDWF index,W
3BF5 0084  4090         MOVWF FSR0L
3BF6 3006  4091         MOVLW 0x06
3BF7 0085  4092         MOVWF FSR0H
3BF8 0800  4093         MOVF  INDF0,W
3BF9 0241  4094         SUBWF blinks_3,W
3BFA 1803  4095         BTFSC 0x03,Carry
3BFB 3230  4096         BRA   m045
           4097                         ;                            uns8 counter = 0;
3BFC 01C2  4098         CLRF  counter_9
           4099                         ;                            while (counter < PeripheralRam[index + 2]) {
3BFD 3022  4100 m041    MOVLW 0x22
3BFE 014B  4101         MOVLB 0x0B
3BFF 0740  4102         ADDWF index,W
3C00 0084  4103         MOVWF FSR0L
3C01 3006  4104         MOVLW 0x06
3C02 0085  4105         MOVWF FSR0H
3C03 0800  4106         MOVF  INDF0,W
3C04 0242  4107         SUBWF counter_9,W
3C05 1803  4108         BTFSC 0x03,Carry
3C06 3209  4109         BRA   m042
           4110                         ;                                waitMS(PeripheralRam[index + 1]);
3C07 3021  4111         MOVLW 0x21
3C08 0740  4112         ADDWF index,W
3C09 0084  4113         MOVWF FSR0L
3C0A 3006  4114         MOVLW 0x06
3C0B 0085  4115         MOVWF FSR0H
3C0C 0800  4116         MOVF  INDF0,W
3C0D 2076  4117         CALL  waitMS
           4118                         ;                                counter++;
3C0E 0AC2  4119         INCF  counter_9,1
           4120                         ;                            }
3C0F 33ED  4121         BRA   m041
           4122                         ;                            LATC.PIN3 = 1;
3C10 0140  4123 m042    MOVLB 0x00
3C11 1698  4124         BSF   LATC,5
           4125                         ;                            counter = 0;
3C12 014B  4126         MOVLB 0x0B
3C13 01C2  4127         CLRF  counter_9
           4128                         ;                            while (counter < PeripheralRam[index + 3]) {
3C14 3023  4129 m043    MOVLW 0x23
3C15 014B  4130         MOVLB 0x0B
3C16 0740  4131         ADDWF index,W
3C17 0084  4132         MOVWF FSR0L
3C18 3006  4133         MOVLW 0x06
3C19 0085  4134         MOVWF FSR0H
3C1A 0800  4135         MOVF  INDF0,W
3C1B 0242  4136         SUBWF counter_9,W
3C1C 1803  4137         BTFSC 0x03,Carry
3C1D 3209  4138         BRA   m044
           4139                         ;                                waitMS(PeripheralRam[index + 1]);
3C1E 3021  4140         MOVLW 0x21
3C1F 0740  4141         ADDWF index,W
3C20 0084  4142         MOVWF FSR0L
3C21 3006  4143         MOVLW 0x06
3C22 0085  4144         MOVWF FSR0H
3C23 0800  4145         MOVF  INDF0,W
3C24 2076  4146         CALL  waitMS
           4147                         ;                                counter++;
3C25 0AC2  4148         INCF  counter_9,1
           4149                         ;                            }
3C26 33ED  4150         BRA   m043
           4151                         ;                            LATC.PIN3 = 0;
3C27 0140  4152 m044    MOVLB 0x00
3C28 1298  4153         BCF   LATC,5
           4154                         ;                            blinks++;
3C29 014B  4155         MOVLB 0x0B
3C2A 0AC1  4156         INCF  blinks_3,1
           4157                         ;                        }
3C2B 33C6  4158         BRA   m040
           4159                         ;                        index += 5;
3C2C 3005  4160 m045    MOVLW 0x05
3C2D 014B  4161         MOVLB 0x0B
3C2E 07C0  4162         ADDWF index,1
           4163                         ;                    }
           4164                         ;                        break;
3C2F 2A77  4165         GOTO  m004
           4166                         ;                    default:
           4167                         ;                        return 0;
3C30 1003  4168 m046    BCF   0x03,Carry
3C31 0008  4169         RETURN
           4170                         ;                }
           4171                         ;            }
           4172                         ;        }
           4173                         ;      // Called after DPA request was processed and after DPA response was sent
           4174                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/notification.html
           4175                         ;      break;
           4176                         ;
           4177                         ;      // -------------------------------------------------
           4178                         ;    case DpaEvent_AfterRouting:
           4179                         ;      // Called after Notification and after routing of the DPA response was finished
           4180                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/afterrouting.html
           4181                         ;      break;
           4182                         ;
           4183                         ;      // -------------------------------------------------
           4184                         ;    case DpaEvent_FrcValue:
           4185                         ;      // Called to get FRC value
           4186                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/frcvalue.html
           4187                         ;      break;
           4188                         ;
           4189                         ;      // -------------------------------------------------
           4190                         ;    case DpaEvent_FrcResponseTime:
           4191                         ;      // Called to get FRC response time
           4192                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/frcresponsetime.html
           4193                         ;      break;
           4194                         ;
           4195                         ;      // -------------------------------------------------
           4196                         ;    case DpaEvent_BeforeSleep:
           4197                         ;      // Called before going to sleep
           4198                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/beforesleep.html
           4199                         ;      break;
           4200                         ;
           4201                         ;      // -------------------------------------------------
           4202                         ;    case DpaEvent_AfterSleep:
           4203                         ;      // Called after woken up after sleep
           4204                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/aftersleep.html
           4205                         ;      break;
           4206                         ;
           4207                         ;      // -------------------------------------------------
           4208                         ;    case DpaEvent_DisableInterrupts:
           4209                         ;      // Called when device needs all hardware interrupts to be disabled (before Reset, Restart, LoadCode, Remove bond and run RFPGM)
           4210                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/eventDisableInterrupts.html
           4211                         ;      break;
           4212                         ;
           4213                         ;      // -------------------------------------------------
           4214                         ;    case DpaEvent_PeerToPeer:
           4215                         ;      // Called when peer-to-peer (non-networking) packet is received
           4216                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/peertopeer.html
           4217                         ;      break;
           4218                         ;
           4219                         ;      // -------------------------------------------------
           4220                         ;    case DpaEvent_UserDpaValue:
           4221                         ;      // Called when DPA is required to return User defined DPA value in the response
           4222                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/userdpavalue.html
           4223                         ;      break;
           4224                         ;
           4225                         ;      // -------------------------------------------------
           4226                         ;#ifdef DpaEvent_InStandby
           4227                         ;    case DpaEvent_InStandby:
           4228                         ;      // Called to set WDT during Standby
           4229                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/instandby.html
           4230                         ;
           4231                         ;      //goto DpaHandleReturnTRUE; // return TRUE to indicate that userReg1 contains WDT settings
           4232                         ;      break;
           4233                         ;#endif
           4234                         ;
           4235                         ;      // -------------------------------------------------
           4236                         ;    case DpaEvent_VerifyLocalFrc:
           4237                         ;      // Called to verify local FRC command
           4238                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/verifylocalfrc.html
           4239                         ;
           4240                         ;      //goto DpaHandleReturnTRUE; // return TRUE allow FRC command
           4241                         ;      break;
           4242                         ;
           4243                         ;      // -------------------------------------------------
           4244                         ;#ifdef DpaEvent_MenuActivated
           4245                         ;    case DpaEvent_MenuActivated:
           4246                         ;      // Called to customize DPA menu
           4247                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/menuactivated.html
           4248                         ;
           4249                         ;      //goto DpaHandleReturnTRUE; // return TRUE to allow customizing menu specified by userReg1
           4250                         ;      break;
           4251                         ;#endif
           4252                         ;
           4253                         ;      // -------------------------------------------------
           4254                         ;#ifdef DpaEvent_MenuItemSelected
           4255                         ;    case DpaEvent_MenuItemSelected:
           4256                         ;      // Called to indicate "OK" or "Error" for selected menu item
           4257                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/menuitemselected.html
           4258                         ;
           4259                         ;      //goto DpaHandleReturnTRUE; // return TRUE to indicate "OK" for menu item specified by userReg1, otherwise to indicate Error
           4260                         ;      break;
           4261                         ;#endif
           4262                         ;
           4263                         ;      // -------------------------------------------------
           4264                         ;#ifdef DpaEvent_MenuItemFinalize
           4265                         ;    case DpaEvent_MenuItemFinalize:
           4266                         ;      // Called to finalize menu item execution
           4267                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/menuitemfinalize.html
           4268                         ;
           4269                         ;      break;
           4270                         ;#endif
           4271                         ;
           4272                         ;      // -------------------------------------------------
           4273                         ;    case DpaEvent_DpaRequest:
           4274                         ;      // Called to interpret DPA request for peripherals
           4275                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/EventDpaRequest.html
           4276                         ;      IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequest()
3C32 0145  4277 m047    MOVLB 0x05
3C33 08A1  4278         MOVF  DLEN,1
3C34 1D03  4279         BTFSS 0x03,Zero_
3C35 3216  4280         BRA   m050
3C36 082F  4281         MOVF  PCMD,W
3C37 3A3F  4282         XORLW 0x3F
3C38 1D03  4283         BTFSS 0x03,Zero_
3C39 3212  4284         BRA   m050
3C3A 0F2E  4285         INCFSZ PNUM,W
3C3B 3205  4286         BRA   m049
           4287                         ;      {
           4288                         ;        // -------------------------------------------------
           4289                         ;        // Peripheral enumeration
           4290                         ;        // https://doc.iqrf.org/DpaTechGuide/pages/enumerate-peripherals.html
           4291                         ;
           4292                         ;        _DpaMessage.EnumPeripheralsAnswer.UserPerNr |= 0; // ?
           4293                         ;        // FlagUserPer( _DpaMessage.EnumPeripheralsAnswer.UserPer, PNUM_USER + 0 ); // ?
           4294                         ;        _DpaMessage.EnumPeripheralsAnswer.HWPID |= 0x000F; // ????
3C3C 300F  4295         MOVLW 0x0F
3C3D 0149  4296         MOVLB 0x09
3C3E 04A7  4297         IORWF DpaRfMessage+7,1
           4298                         ;        _DpaMessage.EnumPeripheralsAnswer.HWPIDver |= 0; // ????
           4299                         ;
           4300                         ;DpaHandleReturnTRUE:
           4301                         ;        return TRUE;
3C3F 1403  4302 m048    BSF   0x03,Carry
3C40 0008  4303         RETURN
           4304                         ;      }
           4305                         ;      else
           4306                         ;      {
           4307                         ;      // -------------------------------------------------
           4308                         ;      // Get information about peripheral
           4309                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/get-peripheral-info.html
           4310                         ;
           4311                         ;      if ( _PNUM == PNUM_USER + 0 ) // ?
3C41 0145  4312 m049    MOVLB 0x05
3C42 082E  4313         MOVF  PNUM,W
3C43 3A20  4314         XORLW 0x20
3C44 1D03  4315         BTFSS 0x03,Zero_
3C45 320E  4316         BRA   m051
           4317                         ;      {
           4318                         ;        _DpaMessage.PeripheralInfoAnswer.PerT = 0; // PERIPHERAL_TYPE_?
3C46 0149  4319         MOVLB 0x09
3C47 01A1  4320         CLRF  DpaRfMessage+1
           4321                         ;        _DpaMessage.PeripheralInfoAnswer.PerTE = 0; // PERIPHERAL_TYPE_EXTENDED_?
3C48 01A0  4322         CLRF  DpaRfMessage
           4323                         ;        _DpaMessage.PeripheralInfoAnswer.Par1 = 0; // ?
3C49 01A2  4324         CLRF  DpaRfMessage+2
           4325                         ;        _DpaMessage.PeripheralInfoAnswer.Par2 = 0; // ?
3C4A 01A3  4326         CLRF  DpaRfMessage+3
           4327                         ;        goto DpaHandleReturnTRUE;
3C4B 33F3  4328         BRA   m048
           4329                         ;      }
           4330                         ;
           4331                         ;      break;
           4332                         ;      }
           4333                         ;
           4334                         ;      // -------------------------------------------------
           4335                         ;      // Handle peripheral command
           4336                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/handle-peripheral-request.html
           4337                         ;
           4338                         ;      if ( _PNUM == PNUM_USER + 0 ) // ?
3C4C 0145  4339 m050    MOVLB 0x05
3C4D 082E  4340         MOVF  PNUM,W
3C4E 3A20  4341         XORLW 0x20
3C4F 1D03  4342         BTFSS 0x03,Zero_
3C50 3203  4343         BRA   m051
           4344                         ;      {
           4345                         ;        if ( _PCMD == 0 ) // ????
3C51 08AF  4346         MOVF  PCMD,1
3C52 1903  4347         BTFSC 0x03,Zero_
           4348                         ;        {
           4349                         ;          goto DpaHandleReturnTRUE;
3C53 33EB  4350         BRA   m048
           4351                         ;        }
           4352                         ;      }
           4353                         ;
           4354                         ;      break;
           4355                         ;  }
           4356                         ;
           4357                         ;DpaHandleReturnFALSE:
           4358                         ;  return FALSE;
3C54 1003  4359 m051    BCF   0x03,Carry
3C55 0008  4360         RETURN
           4361 
           4362   ; FILE C:\makieta-miasta-iqrf\DPAcustomHandler.h
           4363                         ;// *********************************************************************
           4364                         ;//   Main Custom DPA Handler header                                    *
           4365                         ;// *********************************************************************
           4366                         ;// Copyright (c) MICRORISC s.r.o.
           4367                         ;//
           4368                         ;// File:    $RCSfile: DPAcustomHandler.h,v $
           4369                         ;// Version: $Revision: 1.167 $
           4370                         ;// Date:    $Date: 2024/12/05 09:28:58 $
           4371                         ;//
           4372                         ;// Revision history:
           4373                         ;//   2024/11/05  Release for DPA 4.32
           4374                         ;//   2024/04/17  Release for DPA 4.31
           4375                         ;//   2023/03/07  Release for DPA 4.30
           4376                         ;//   2022/10/05  Release for DPA 4.18
           4377                         ;//   2022/02/24  Release for DPA 4.17
           4378                         ;//   2021/08/20  Release for DPA 4.16
           4379                         ;//   2020/09/03  Release for DPA 4.15
           4380                         ;//   2020/04/03  Release for DPA 4.14
           4381                         ;//   2020/02/27  Release for DPA 4.13
           4382                         ;//   2020/01/09  Release for DPA 4.12
           4383                         ;//   2019/12/11  Release for DPA 4.11
           4384                         ;//   2019/10/09  Release for DPA 4.10
           4385                         ;//   2019/06/12  Release for DPA 4.03
           4386                         ;//   2019/06/03  Release for DPA 4.02
           4387                         ;//   2019/03/07  Release for DPA 4.01
           4388                         ;//   2019/01/10  Release for DPA 4.00
           4389                         ;//   2018/10/25  Release for DPA 3.03
           4390                         ;//   2017/11/16  Release for DPA 3.02
           4391                         ;//   2017/08/14  Release for DPA 3.01
           4392                         ;//   2017/03/13  Release for DPA 3.00
           4393                         ;//   2016/09/12  Release for DPA 2.28
           4394                         ;//   2016/04/14  Release for DPA 2.27
           4395                         ;//   2016/03/03  Release for DPA 2.26
           4396                         ;//   2016/01/21  Release for DPA 2.25
           4397                         ;//   2015/12/01  Release for DPA 2.24
           4398                         ;//   2015/10/23  Release for DPA 2.23
           4399                         ;//   2015/09/25  Release for DPA 2.22
           4400                         ;//   2015/09/03  Release for DPA 2.21
           4401                         ;//   2015/08/05  Release for DPA 2.20
           4402                         ;//   2014/10/31  Release for DPA 2.10
           4403                         ;//   2014/04/30  Release for DPA 2.00
           4404                         ;//   2013/10/03  Release for DPA 1.00
           4405                         ;//
           4406                         ;// *********************************************************************
           4407                         ;
           4408                         ;// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
           4409                         ;// IQRF Standards documentation https://doc.iqrf.org/
           4410                         ;
           4411                         ;#ifndef _CUSTOM_DPA_HANDLER_
           4412                         ;#define _CUSTOM_DPA_HANDLER_
           4413                         ;
           4414                         ;//############################################################################################
           4415                         ;// 1st include
           4416                         ;
           4417                         ;// Custom DPA Handler routine declaration
           4418                         ;bit CustomDpaHandler();
           4419                         ;
           4420                         ;// Various DPA flags shared between DPA and Custom DPA Handler
           4421                         ;uns8 DpaFlags @ usedBank4[0];
           4422                         ;
           4423                         ;// [C][N] TRUE if I2C timeout occurred at the last DpaApiI2C?() call
           4424                         ;bit I2CwasTimeout @ DpaFlags.0;
           4425                         ;// [N] Flag for the 1st DpaApiSleep
           4426                         ;bit FirstDpaApiSleep @ DpaFlags.1;
           4427                         ;
           4428                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           4429                         ;// [C] TRUE if interface master is not connected (detected)
           4430                         ;bit IFaceMasterNotConnected @ DpaFlags.2;
           4431                         ;#endif
           4432                         ;// [N] DPA by interface notification is sent also when there was a "reading" like DPA request
           4433                         ;bit EnableIFaceNotificationOnRead @ DpaFlags.3;
           4434                         ;// [N] TRUE when node was just bonded using default bonding procedure
           4435                         ;bit NodeWasBonded @ DpaFlags.4;
           4436                         ;// [N] When TRUE, then next call of DpaApiRfTxDpaPacket sends non-routed packet
           4437                         ;bit NonroutedRfTxDpaPacket @ DpaFlags.7;
           4438                         ;
           4439                         ;// [C] Ticks (decrementing) counter usable for timing in the coordinator's Customer DPA Handler
           4440                         ;uns16 DpaTicks @ usedBank4[1];
           4441                         ;// [N] toutRF for LP mode, read from configuration memory after reset
           4442                         ;uns8 LPtoutRF @ usedBank4[3];
           4443                         ;// DPA Request/Response HWPID
           4444                         ;uns16 _HWPID @ usedBank4[4];
           4445                         ;// Identifies type of reset (stored at UserReg0 upon module reset). See Reset chapter at IQRF User's Guide for more information
           4446                         ;uns8 ResetType @ usedBank4[6];
           4447                         ;// User DPA Values to return
           4448                         ;uns8 UserDpaValue @ usedBank4[7];
           4449                         ;// Network depth of the DPA request/response, increases on bridging, decreases on back-bridging
           4450                         ;uns8 NetDepth @ usedBank4[8];
           4451                         ;// TRUE when node was at DPA Service Mode after last boot
           4452                         ;bit DSMactivated @ usedBank4[9].0;
           4453                         ;// If set to TRUE, then LP RX mode in the main loop can be terminated by pin, see _RLPMAT
           4454                         ;bit LpRxPinTerminate @ usedBank4[9].1;
           4455                         ;// If set to TRUE, then [C] executes asynchronous DPA requests received from [N]
           4456                         ;bit AsyncReqAtCoordinator @ usedBank4[9].2;
           4457                         ;// RX filter used at the DPA main loop checkRF call
           4458                         ;uns8 RxFilter @ usedBank4[11];
           4459                         ;// Countdown variable for button bonding before going to deep sleep
           4460                         ;uns16 BondingSleepCountdown @ usedBank4[12];
           4461                         ;#define BONDING_SLEEP_COUNTDOWN_UNIT  290
           4462                         ;// Non-zero pseudo-random value, read-only, updated on every Reset and Idle event, at [N] only.
           4463                         ;uns16 Random @ usedBank4[14];
           4464                         ;// DPA value from the received packet or just to be sent to the interface.
           4465                         ;uns8 DpaValue @ usedBank4[16];
           4466                         ;// If non-zero then timeout value for DpaApiI2C?() calls
           4467                         ;uns8 I2Ctimeout @ usedBank4[17];
           4468                         ;
           4469                         ;// Macro to return an error from the peripheral handler. If the code size is not an issue this macro is the right choice.
           4470                         ;#define DpaApiReturnPeripheralError(error) do { \
           4471                         ;    DpaApiSetPeripheralError( error ); \
           4472                         ;    return Carry; \
           4473                         ;  } while( 0 )
           4474                         ;
           4475                         ;// DPA API functions, see documentation for details
           4476                         ;#define DpaApiRfTxDpaPacket( dpaValue, netDepthAndFlags ) DpaApiEntry( dpaValue, netDepthAndFlags, DPA_API_RFTX_DPAPACKET )
           4477                         ;#define DpaApiReadConfigByte( index )                     DpaApiEntry( index, param3.low8, DPA_API_READ_CONFIG_BYTE )
           4478                         ;#define DpaApiLocalRequest()                              DpaApiEntry( param2, param3.low8, DPA_API_LOCAL_REQUEST )
           4479                         ;#define DpaApiSetPeripheralError( error )                 DpaApiEntry( error, param3.low8, DPA_API_SET_PERIPHERAL_ERROR )
           4480                         ;#define DpaApiSendToIFaceMaster( dpaValue, flags )        DpaApiEntry( dpaValue, flags, DPA_API_SEND_TO_IFACEMASTER )
           4481                         ;#define DpaApiSetRfDefaults()                             DpaApiEntry( param2, param3.low8, DPA_API_SET_RF_DEFAULTS )
           4482                         ;#define DpaApiLocalFrc( frcCommand, replyTxPower )        DpaApiEntry( frcCommand, replyTxPower, DPA_API_LOCAL_FRC )
           4483                         ;#define DpaApiCrc8( crc8, data )                          DpaApiEntry( crc8, data, DPA_API_CRC8 )
           4484                         ;#define DpaApiAggregateFrc()                              DpaApiEntry( param2, param3.low8, DPA_API_AGGREGATE_FRC )
           4485                         ;#define DpaApiSetOTK()                                    DpaApiEntry( param2, param3.low8, DPA_API_SET_OTK )
           4486                         ;#define DpaApiI2Cinit( frequency )                        DpaApiEntry( frequency, param3.low8, DPA_API_I2C_INIT )
           4487                         ;#define DpaApiI2Cstart( address )                         DpaApiEntry( address, param3.low8, DPA_API_I2C_START )
           4488                         ;#define DpaApiI2Cwrite( data )                            DpaApiEntry( data, param3.low8, DPA_API_I2C_WRITE )
           4489                         ;#define DpaApiI2Cread( ack )                              DpaApiEntry( ack, param3.low8, DPA_API_I2C_READ )
           4490                         ;#define DpaApiI2Cstop()                                   DpaApiEntry( param2, param3.low8, DPA_API_I2C_STOP )
           4491                         ;#define DpaApiI2CwaitForACK( address )                    DpaApiEntry( address, param3.low8, DPA_API_I2C_WAIT_FOR_ACK )
           4492                         ;#define DpaApiI2Cshutdown()                               DpaApiEntry( param2, param3.low8, DPA_API_I2C_SHUTDOWN )
           4493                         ;#define DpaApiI2CwaitForIdle()                            DpaApiEntry( param2, param3.low8, DPA_API_I2C_WAIT_FOR_IDLE )
           4494                         ;#define DpaApiSleep( wdtcon )                             DpaApiEntry( wdtcon, param3.low8, DPA_API_SLEEP )
           4495                         ;#define DpaApiAfterSleep()                                DpaApiEntry( param2, param3.low8, DPA_API_AFTER_SLEEP )
           4496                         ;#define DpaApiRandom()                                    DpaApiEntry( param2, param3.low8, DPA_API_RANDOM )
           4497                         ;
           4498                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           4499                         ;#define DpaApiRfTxDpaPacketCoordinator()                  DpaApiEntry( param2, param3.low8, DPA_API_COORDINATOR_RFTX_DPAPACKET )
           4500                         ;#endif
           4501                         ;
           4502                         ;#if !defined( TR7xD )
           4503                         ;#define DpaApiMenu( menu, flags )                         DpaApiEntry( menu, flags, DPA_API_MENU )
           4504                         ;#define DpaApiMenuIndicateResult( ok )                    DpaApiEntry( ok, param3.low8, DPA_API_MENU_INDICATE_RESULT )
           4505                         ;#define DpaApiMenuExecute( menuAndItem )                  DpaApiEntry( menuAndItem, param3.low8, DPA_API_MENU_EXECUTE )
           4506                         ;#define DpaApiDeepSleep( wdtcon )                         DpaApiEntry( wdtcon, param3.low8, DPA_API_DEEP_SLEEP )
           4507                         ;#endif
           4508                         ;
           4509                         ;#define DpaApiLocalFrc_StackSaver( frcCommand, replyTxPower ) \
           4510                         ;  param2 = frcCommand; \
           4511                         ;  param3.low8 = replyTxPower; \
           4512                         ;  W = DPA_API_LOCAL_FRC; \
           4513                         ;  #asm \
           4514                         ;    DW  __MOVLP( DPA_API_ADDRESS >> 8 ); \
           4515                         ;    DW  __CALL( DPA_API_ADDRESS ); \
           4516                         ;    DW  __MOVLP( CUSTOM_HANDLER_ADDRESS >> 8 ); \
           4517                         ;  #endasm \
           4518                         ;
           4519                         ;#define I2CcomputeFrequency( I2Cfrequency)                ( ( ( F_OSC ) / ( ( I2Cfrequency ) * 4 ) ) - 1 )
           4520                         ;
           4521                         ;// Wrapper routines to be called instead of DpaApi??? macros to decrease code size if more than ~2 calls are needed
           4522                         ;void _DpaApiI2Cinit( uns8 frequency );
           4523                         ;void _DpaApiI2Cstart( uns8 address );
           4524                         ;void _DpaApiI2Cwrite( uns8 data );
           4525                         ;uns8 _DpaApiI2Cread( uns8 ack );
           4526                         ;void _DpaApiI2Cstop();
           4527                         ;void _DpaApiI2CwaitForACK( uns8 address );
           4528                         ;void _DpaApiI2Cshutdown();
           4529                         ;void _DpaApiI2CwaitForIdle();
           4530                         ;void _DpaApiSleep( uns8 wdtcon );
           4531                         ;#if !defined( TR7xD )
           4532                         ;void _DpaApiDeepSleep( uns8 wdtcon );
           4533                         ;#endif
           4534                         ;void _DpaApiSleepFirst( uns8 wdtcon );
           4535                         ;void _DpaApiAfterSleep();
           4536                         ;uns8 _DpaApiRandom();
           4537                         ;void _DpaApiSetRfDefaults();
           4538                         ;
           4539                         ;// Helper "multi" function to decrease code size if used more times
           4540                         ;void _DpaApiI2Cwrite0();
           4541                         ;void _DpaApiI2CwriteAndStop( uns8 data );
           4542                         ;uns8 _DpaApiI2CreadACK();
           4543                         ;uns8 _DpaApiI2CreadNACK();
           4544                         ;uns8 _DpaApiI2CreadNACKandStop();
           4545                         ;
           4546                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           4547                         ;#undef  DpaEvent_Interrupt
           4548                         ;#undef  DpaEvent_BeforeSleep
           4549                         ;#undef  DpaEvent_AfterSleep
           4550                         ;#undef  DpaEvent_FrcValue
           4551                         ;#undef  DpaEvent_FrcResponseTime
           4552                         ;#else
           4553                         ;#undef  DpaEvent_ReceiveDpaResponse
           4554                         ;#undef  DpaEvent_IFaceReceive
           4555                         ;#endif
           4556                         ;
           4557                         ;// To detect overlapping code in case someone would put some code before this header by mistake
           4558                         ;#pragma origin __APPLICATION_ADDRESS
           4559                         ;#pragma updateBank 0
           4560                         ;
           4561                         ;//############################################################################################
           4562                         ;// Main IQRF entry point jumps to the main DPA entry point
           4563                         ;void APPLICATION()
           4564                         ;//############################################################################################
           4565                         ;{
           4566                         ;  #asm
           4567                         ;    DW  __MOVLP( MAIN_DPA_ADDRESS >> 8 );
           4568                         ;  DW  __GOTO( MAIN_DPA_ADDRESS );
           4569                         ;  #endasm
           4570                         ;
           4571                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           4572                         ;    // Fake call to force CustomDpaHandler() compilation
           4573                         ;    CustomDpaHandler();
           4574                         ;#endif
           4575                         ;
           4576                         ;  // Fake call to force DpaApiEntry() compilation
           4577                         ;  DpaApiEntry( param2, param3.low8, W );
           4578                         ;}
           4579                         ;
           4580                         ;//############################################################################################
           4581                         ;// Entry stub to the real DPA API entry
           4582                         ;#pragma origin DPA_API_ADDRESS_ENTRY
           4583                         ;uns8  DpaApiEntry( uns8 par1 @ param2, uns8 par2 @ param3.low8, uns8 apiIndex @ W )
           4584                         ;//############################################################################################
           4585                         ;{
           4586                         ;  #asm
           4587                         ;    DW  __MOVLP( DPA_API_ADDRESS >> 8 );
           4588                         ;  DW  __CALL( DPA_API_ADDRESS );
           4589                         ;  DW  __MOVLP( DPA_API_ADDRESS_ENTRY >> 8 );
           4590                         ;  #endasm
           4591                         ;
           4592                         ;    return W;
           4593                         ;}
           4594                         ;
           4595                         ;//############################################################################################
           4596                         ;#pragma origin DPA_API_ADDRESS_ENTRY + 0x08
           4597                         ;
           4598                         ;//############################################################################################
           4599                         ;
           4600                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           4601                         ;// Next comes Custom DPA handler routine
           4602                         ;#pragma origin CUSTOM_HANDLER_ADDRESS
           4603                         ;#endif
           4604                         ;
           4605                         ;#pragma updateBank 1
           4606                         ;
           4607                         ;//############################################################################################
           4608                         ;#else // _CUSTOM_DPA_HANDLER_
           4609                         ;//############################################################################################
           4610                         ;// 2nd include
           4611                         ;
           4612                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           4613                         ;
           4614                         ;// Library wrappers and helpers to decrease code size
           4615                         ;//############################################################################################
           4616                         ;#pragma library 1
           4617                         ;//############################################################################################
           4618                         ;uns8 _DpaApiUserBank_01( uns8 apiIndex @ W )
           4619                         ;//############################################################################################
           4620                         ;{
           4621 _DpaApiUserBank_01
           4622                         ;#pragma updateBank exit = UserBank_01
           4623                         ;  return DpaApiEntry( param2, param3.low8, apiIndex );
           4624                         ;}
           4625                         ;//############################################################################################
           4626                         ;void _DpaApiI2Cinit( uns8 frequency @ W )
           4627                         ;//############################################################################################
           4628                         ;{
           4629 _DpaApiI2Cinit
           4630                         ;#pragma updateBank exit = UserBank_01
           4631                         ;  param2 = frequency;
           4632                         ;  _DpaApiUserBank_01( DPA_API_I2C_INIT );
           4633                         ;}
           4634                         ;//############################################################################################
           4635                         ;void _DpaApiI2Cstart( uns8 address @ W )
           4636                         ;//############################################################################################
           4637                         ;{
           4638 _DpaApiI2Cstart
           4639                         ;#pragma updateBank exit = UserBank_01
           4640                         ;  param2 = address;
           4641                         ;  _DpaApiUserBank_01( DPA_API_I2C_START );
           4642                         ;}
           4643                         ;//############################################################################################
           4644                         ;void _DpaApiI2Cwrite0()
           4645                         ;//############################################################################################
           4646                         ;{
           4647 _DpaApiI2Cwrite0
           4648                         ;#pragma updateBank exit = UserBank_01
           4649                         ;  _DpaApiI2Cwrite( 0 );
           4650                         ;}
           4651                         ;//############################################################################################
           4652                         ;void _DpaApiI2Cwrite( uns8 data @ W )
           4653                         ;//############################################################################################
           4654                         ;{
           4655 _DpaApiI2Cwrite
           4656                         ;#pragma updateBank exit = UserBank_01
           4657                         ;  param2 = data;
           4658                         ;  _DpaApiUserBank_01( DPA_API_I2C_WRITE );
           4659                         ;}
           4660                         ;//############################################################################################
           4661                         ;uns8 _DpaApiI2CreadNACKandStop()
           4662                         ;//############################################################################################
           4663                         ;{
           4664 _DpaApiI2CreadNACKandStop
           4665                         ;#pragma updateBank exit = UserBank_01
           4666                         ;  param2 = _DpaApiI2CreadNACK();
           4667                         ;  _DpaApiI2Cstop(); /* Must not use param2 */
           4668                         ;  return param2;
           4669                         ;}
           4670                         ;//############################################################################################
           4671                         ;uns8 _DpaApiI2CreadACK()
           4672                         ;//############################################################################################
           4673                         ;{
           4674 _DpaApiI2CreadACK
           4675                         ;#pragma updateBank exit = UserBank_01
           4676                         ;  return _DpaApiI2Cread( 1 );
           4677                         ;}
           4678                         ;//############################################################################################
           4679                         ;uns8 _DpaApiI2CreadNACK()
           4680                         ;//############################################################################################
           4681                         ;{
           4682 _DpaApiI2CreadNACK
           4683                         ;#pragma updateBank exit = UserBank_01
           4684                         ;  return _DpaApiI2Cread( 0 );
           4685                         ;}
           4686                         ;//############################################################################################
           4687                         ;uns8 _DpaApiI2Cread( uns8 ack @ W )
           4688                         ;//############################################################################################
           4689                         ;{
           4690 _DpaApiI2Cread
           4691                         ;#pragma updateBank exit = UserBank_01
           4692                         ;  param2 = ack;
           4693                         ;  return _DpaApiUserBank_01( DPA_API_I2C_READ );
           4694                         ;}
           4695                         ;//############################################################################################
           4696                         ;void _DpaApiI2CwriteAndStop( uns8 data @ W )
           4697                         ;//############################################################################################
           4698                         ;{
           4699 _DpaApiI2CwriteAndStop
           4700                         ;#pragma updateBank exit = UserBank_01
           4701                         ;  _DpaApiI2Cwrite( data );
           4702                         ;  _DpaApiI2Cstop();
           4703                         ;}
           4704                         ;//############################################################################################
           4705                         ;void _DpaApiI2Cstop()
           4706                         ;//############################################################################################
           4707                         ;{
           4708 _DpaApiI2Cstop
           4709                         ;#pragma updateBank exit = UserBank_01
           4710                         ;  _DpaApiUserBank_01( DPA_API_I2C_STOP );
           4711                         ;}
           4712                         ;//############################################################################################
           4713                         ;void _DpaApiI2CwaitForACK( uns8 address @ W )
           4714                         ;//############################################################################################
           4715                         ;{
           4716 _DpaApiI2CwaitForACK
           4717                         ;#pragma updateBank exit = UserBank_01
           4718                         ;  DpaApiI2CwaitForACK( address );
           4719                         ;}
           4720                         ;//############################################################################################
           4721                         ;void _DpaApiI2Cshutdown()
           4722                         ;//############################################################################################
           4723                         ;{
           4724 _DpaApiI2Cshutdown
           4725                         ;#pragma updateBank exit = UserBank_01
           4726                         ;  _DpaApiUserBank_01( DPA_API_I2C_SHUTDOWN );
           4727                         ;}
           4728                         ;//############################################################################################
           4729                         ;void _DpaApiI2CwaitForIdle()
           4730                         ;//############################################################################################
           4731                         ;{
           4732 _DpaApiI2CwaitForIdle
           4733                         ;#pragma updateBank exit = UserBank_01
           4734                         ;  _DpaApiUserBank_01( DPA_API_I2C_WAIT_FOR_IDLE );
           4735                         ;}
           4736                         ;//############################################################################################
           4737                         ;void _DpaApiSleep( uns8 wdtcon @ W )
           4738                         ;//############################################################################################
           4739                         ;{
           4740 _DpaApiSleep
           4741                         ;#pragma updateBank exit = UserBank_01
           4742                         ;  param2 = wdtcon;
           4743                         ;  _DpaApiUserBank_01( DPA_API_SLEEP );
           4744                         ;}
           4745                         ;#if !defined( TR7xD )
           4746                         ;//############################################################################################
           4747                         ;void _DpaApiDeepSleep( uns8 wdtcon @ W )
           4748                         ;//############################################################################################
           4749                         ;{
           4750 _DpaApiDeepSleep
           4751                         ;#pragma updateBank exit = UserBank_01
           4752                         ;  param2 = wdtcon;
           4753                         ;  _DpaApiUserBank_01( DPA_API_DEEP_SLEEP );
           4754                         ;}
           4755                         ;#endif
           4756                         ;//############################################################################################
           4757                         ;void _DpaApiSleepFirst( uns8 wdtcon @ W )
           4758                         ;//############################################################################################
           4759                         ;{
           4760 _DpaApiSleepFirst
           4761                         ;#pragma updateBank exit = UserBank_01
           4762                         ;  FirstDpaApiSleep = TRUE;
           4763                         ;  _DpaApiSleep( wdtcon );
           4764                         ;}
           4765                         ;//############################################################################################
           4766                         ;void _DpaApiAfterSleep()
           4767                         ;//############################################################################################
           4768                         ;{
           4769 _DpaApiAfterSleep
           4770                         ;#pragma updateBank exit = UserBank_01
           4771                         ;  _DpaApiUserBank_01( DPA_API_AFTER_SLEEP );
           4772                         ;}
           4773                         ;//############################################################################################
           4774                         ;uns8 _DpaApiRandom()
           4775                         ;//############################################################################################
           4776                         ;{
           4777 _DpaApiRandom
           4778                         ;#pragma updateBank exit = UserBank_01
           4779                         ;  return _DpaApiUserBank_01( DPA_API_RANDOM );
           4780                         ;}
           4781                         ;//############################################################################################
           4782                         ;void _DpaApiSetRfDefaults()
           4783                         ;//############################################################################################
           4784                         ;{
           4785 _DpaApiSetRfDefaults
           4786                         ;#pragma updateBank exit = UserBank_01
           4787                         ;  _DpaApiUserBank_01( DPA_API_SET_RF_DEFAULTS );
           4788                         ;}
           4789                         ;//############################################################################################
           4790                         ;
           4791                         ;// Code bumper to detect too long code of Custom DPA handler + other routines
           4792                         ;#pragma origin CUSTOM_HANDLER_ADDRESS_END
     0000  4793         ORG 0x4F00
           4794                         ;// To avoid adding some code after handler by mistake
           4795                         ;#pragma origin __MAX_FLASH_ADDRESS
     0000  4796         ORG 0x7FFF
           4797 
     0000  4798         ORG 0x3800
3800 0046  4799         DATA 0046H
3801 0005  4800         DATA 0005H
3802 0082  4801         DATA 0082H
           4802         END
           4803 
           4804 
           4805 ; *** KEY INFO ***
           4806 
           4807 ; 0x0100 P0    5 word(s)  0 % : main
           4808 
           4809 ; 0x3A00 P7    4 word(s)  0 % : APPLICATION
           4810 ; 0x3810 P7    2 word(s)  0 % : dummy
           4811 ; 0x3816 P7    2 word(s)  0 % : iqrfSleep
           4812 ; 0x3819 P7    2 word(s)  0 % : _debug
           4813 ; 0x381C P7    2 word(s)  0 % : moduleInfo
           4814 ; 0x3822 P7    2 word(s)  0 % : pulsingLEDR
           4815 ; 0x3825 P7    2 word(s)  0 % : pulseLEDR
           4816 ; 0x3828 P7    2 word(s)  0 % : stopLEDR
           4817 ; 0x382B P7    2 word(s)  0 % : pulsingLEDG
           4818 ; 0x382E P7    2 word(s)  0 % : pulseLEDG
           4819 ; 0x3831 P7    2 word(s)  0 % : stopLEDG
           4820 ; 0x3834 P7    2 word(s)  0 % : setOnPulsingLED
           4821 ; 0x3837 P7    2 word(s)  0 % : setOffPulsingLED
           4822 ; 0x383A P7    2 word(s)  0 % : eeReadByte
           4823 ; 0x383D P7    2 word(s)  0 % : eeReadData
           4824 ; 0x3840 P7    2 word(s)  0 % : eeWriteByte
           4825 ; 0x3843 P7    2 word(s)  0 % : eeWriteData
           4826 ; 0x3846 P7    2 word(s)  0 % : readFromRAM
           4827 ; 0x384C P7    2 word(s)  0 % : clearBufferINFO
           4828 ; 0x384F P7    2 word(s)  0 % : swapBufferINFO
           4829 ; 0x3852 P7    2 word(s)  0 % : compareBufferINFO2RF
           4830 ; 0x3855 P7    2 word(s)  0 % : copyBufferINFO2COM
           4831 ; 0x3858 P7    2 word(s)  0 % : copyBufferINFO2RF
           4832 ; 0x385B P7    2 word(s)  0 % : copyBufferRF2COM
           4833 ; 0x385E P7    2 word(s)  0 % : copyBufferRF2INFO
           4834 ; 0x3861 P7    2 word(s)  0 % : copyBufferCOM2RF
           4835 ; 0x3864 P7    2 word(s)  0 % : copyBufferCOM2INFO
           4836 ; 0x3867 P7    2 word(s)  0 % : copyMemoryBlock
           4837 ; 0x386A P7    2 word(s)  0 % : startDelay
           4838 ; 0x386D P7    2 word(s)  0 % : startLongDelay
           4839 ; 0x3870 P7    2 word(s)  0 % : isDelay
           4840 ; 0x3873 P7    2 word(s)  0 % : waitDelay
           4841 ; 0x3876 P7    2 word(s)  0 % : waitMS
           4842 ; 0x3879 P7    2 word(s)  0 % : startCapture
           4843 ; 0x387C P7    2 word(s)  0 % : captureTicks
           4844 ; 0x3882 P7    2 word(s)  0 % : waitNewTick
           4845 ; 0x3885 P7    2 word(s)  0 % : enableSPI
           4846 ; 0x3888 P7    2 word(s)  0 % : disableSPI
           4847 ; 0x388B P7    2 word(s)  0 % : startSPI
           4848 ; 0x388E P7    2 word(s)  0 % : stopSPI
           4849 ; 0x3891 P7    2 word(s)  0 % : restartSPI
           4850 ; 0x3894 P7    2 word(s)  0 % : getStatusSPI
           4851 ; 0x3897 P7    2 word(s)  0 % : setRFpower
           4852 ; 0x389A P7    2 word(s)  0 % : setLEDG
           4853 ; 0x389D P7    2 word(s)  0 % : setRFchannel
           4854 ; 0x38A0 P7    2 word(s)  0 % : setRFmode
           4855 ; 0x38A3 P7    2 word(s)  0 % : setRFspeed
           4856 ; 0x38A6 P7    2 word(s)  0 % : setRFsleep
           4857 ; 0x38A9 P7    2 word(s)  0 % : setRFready
           4858 ; 0x38AC P7    2 word(s)  0 % : RFTXpacket
           4859 ; 0x38AF P7    2 word(s)  0 % : RFRXpacket
           4860 ; 0x38B2 P7    2 word(s)  0 % : checkRF
           4861 ; 0x38B8 P7    2 word(s)  0 % : amIBonded
           4862 ; 0x38BB P7    2 word(s)  0 % : removeBond
           4863 ; 0x38BE P7    2 word(s)  0 % : bondNewNode
           4864 ; 0x38C1 P7    2 word(s)  0 % : isBondedNode
           4865 ; 0x38C4 P7    2 word(s)  0 % : removeBondedNode
           4866 ; 0x38C7 P7    2 word(s)  0 % : rebondNode
           4867 ; 0x38CA P7    2 word(s)  0 % : clearAllBonds
           4868 ; 0x38CD P7    2 word(s)  0 % : setNonetMode
           4869 ; 0x38D0 P7    2 word(s)  0 % : setCoordinatorMode
           4870 ; 0x38D3 P7    2 word(s)  0 % : setNodeMode
           4871 ; 0x38D6 P7    2 word(s)  0 % : setNetworkFilteringOn
           4872 ; 0x38D9 P7    2 word(s)  0 % : setNetworkFilteringOff
           4873 ; 0x38DC P7    2 word(s)  0 % : getNetworkParams
           4874 ; 0x38DF P7    2 word(s)  0 % : setRoutingOn
           4875 ; 0x38E2 P7    2 word(s)  0 % : setRoutingOff
           4876 ; 0x38E8 P7    2 word(s)  0 % : answerSystemPacket
           4877 ; 0x38EB P7    2 word(s)  0 % : discovery
           4878 ; 0x38EE P7    2 word(s)  0 % : wasRouted
           4879 ; 0x38F1 P7    2 word(s)  0 % : optimizeHops
           4880 ; 0x38F4 P7    2 word(s)  0 % : getSupplyVoltage
           4881 ; 0x38F7 P7    2 word(s)  0 % : getTemperature
           4882 ; 0x38FA P7    2 word(s)  0 % : clearBufferRF
           4883 ; 0x3910 P7    2 word(s)  0 % : isDiscoveredNode
           4884 ; 0x3913 P7    2 word(s)  0 % : enableRFPGM
           4885 ; 0x3916 P7    2 word(s)  0 % : disableRFPGM
           4886 ; 0x3919 P7    2 word(s)  0 % : setupRFPGM
           4887 ; 0x391C P7    2 word(s)  0 % : runRFPGM
           4888 ; 0x391F P7    2 word(s)  0 % : iqrfDeepSleep
           4889 ; 0x3922 P7    2 word(s)  0 % : wasRFICrestarted
           4890 ; 0x3925 P7    2 word(s)  0 % : eeeWriteData
           4891 ; 0x3928 P7    2 word(s)  0 % : eeeReadData
           4892 ; 0x3931 P7    2 word(s)  0 % : setINDF0
           4893 ; 0x3934 P7    2 word(s)  0 % : setINDF1
           4894 ; 0x3937 P7    2 word(s)  0 % : getRSSI
           4895 ; 0x393A P7    2 word(s)  0 % : removeBondAddress
           4896 ; 0x393D P7    2 word(s)  0 % : sendFRC
           4897 ; 0x3940 P7    2 word(s)  0 % : responseFRC
           4898 ; 0x3943 P7    2 word(s)  0 % : bondRequestAdvanced
           4899 ; 0x3946 P7    2 word(s)  0 % : prebondNodeAtNode
           4900 ; 0x3949 P7    2 word(s)  0 % : nodeAuthorization
           4901 ; 0x394C P7    2 word(s)  0 % : dummy01
           4902 ; 0x3958 P7    2 word(s)  0 % : setAccessPassword
           4903 ; 0x395B P7    2 word(s)  0 % : setUserKey
           4904 ; 0x3961 P7    2 word(s)  0 % : amIRecipientOfFRC
           4905 ; 0x3964 P7    2 word(s)  0 % : setLEDR
           4906 ; 0x3967 P7    2 word(s)  0 % : encryptBufferRF
           4907 ; 0x396A P7    2 word(s)  0 % : decryptBufferRF
           4908 ; 0x396D P7    2 word(s)  0 % : prebondNodeAtCoordinator
           4909 ; 0x3970 P7    2 word(s)  0 % : setFSRs
           4910 ; 0x3973 P7    2 word(s)  0 % : updateCRC16
           4911 ; 0x3976 P7    2 word(s)  0 % : smartConnect
           4912 ; 0x3979 P7    2 word(s)  0 % : addressBitmap
           4913 ; 0x397C P7    2 word(s)  0 % : setServiceChannel
           4914 ; 0x3A08 P7    4 word(s)  0 % : DpaApiEntry
           4915 ; 0x3A20 P7  566 word(s) 27 % : CustomDpaHandler
           4916 
           4917 ; RAM usage: 1091 bytes (3 local), 3005 bytes free
           4918 ; Maximum call level: 3
           4919 ;  Codepage 0 has    6 word(s) :   0 %
           4920 ;  Codepage 1 has    0 word(s) :   0 %
           4921 ;  Codepage 2 has    0 word(s) :   0 %
           4922 ;  Codepage 3 has    0 word(s) :   0 %
           4923 ;  Codepage 4 has    0 word(s) :   0 %
           4924 ;  Codepage 5 has    0 word(s) :   0 %
           4925 ;  Codepage 6 has    0 word(s) :   0 %
           4926 ;  Codepage 7 has  785 word(s) :  38 %
           4927 ;  Codepage 8 has    0 word(s) :   0 %
           4928 ;  Codepage 9 has    0 word(s) :   0 %
           4929 ;  Codepage 10 has    0 word(s) :   0 %
           4930 ;  Codepage 11 has    0 word(s) :   0 %
           4931 ;  Codepage 12 has    0 word(s) :   0 %
           4932 ;  Codepage 13 has    0 word(s) :   0 %
           4933 ;  Codepage 14 has    0 word(s) :   0 %
           4934 ;  Codepage 15 has    0 word(s) :   0 %
           4935 ; Total of 791 code words (2 %)
