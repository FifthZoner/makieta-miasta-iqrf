CC5X Version 3.8A,   File: C:\customdpa\CustomDpaHandle.c 15. Jan 2025  16:02   Page 1

ADDR CODE  LINE SOURCE

           0001 
           0002 ; CC5X Version 3.8A, Copyright (c) B Knudsen Data
           0003 ; C compiler for the PICmicro family
           0004 ; ************  15. Jan 2025  16:02  *************
           0005 
           0006         processor  16LF18877
           0007         radix  DEC
           0008 
     0000  0009 Carry       EQU   0
     0002  0010 Zero_       EQU   2
     0070  0011 userReg0    EQU   0x70
     02A1  0012 DLEN        EQU   0x2A1
     02AE  0013 PNUM        EQU   0x2AE
     02AF  0014 PCMD        EQU   0x2AF
     04A0  0015 DpaRfMessage EQU   0x4A0
           0016 
0000 2900  0017         GOTO main
           0018 
           0019   ; FILE C:\customdpa\IQRF.h
           0020                         ;// *********************************************************************
           0021                         ;//                     IQRF OS basic include file                      *
           0022                         ;// *********************************************************************
           0023                         ;//
           0024                         ;// Online IQRF OS Reference Guide: http://www.iqrf.org/IQRF-OS-Reference-guide/
           0025                         ;//
           0026                         ;// Copyright (c) MICRORISC s.r.o.
           0027                         ;//
           0028                         ;// Intended for:
           0029                         ;//   HW: TR-72D, TR-76D, TR-77D, TR-78D, TR-75D, TR-72G, TR-76G, TR-75G, TR-82G
           0030                         ;//   OS: 4.06D, 4.06G
           0031                         ;//
           0032                         ;// File:    IQRF.h
           0033                         ;// Version: v1.00                                   Revision: 03/06/2022
           0034                         ;//
           0035                         ;// Revision history:
           0036                         ;//   v1.00: 03/06/2022  First release for OS 4.06D and 4.06G.
           0037                         ;//
           0038                         ;// *********************************************************************
           0039                         ;
           0040                         ;#if IQRFOS != 406
           0041                         ;    #error Invalid IQRF OS version, v4.06D or v4.06G is expected. Make sure matching header files and project IQRF OS version setting are used.
           0042                         ;#endif
           0043                         ;
           0044                         ;#if __CC5X__ < 3701
           0045                         ;    #warning Insufficient CC5X compiler version, V3.7A or higher is recommended.
           0046                         ;#endif
           0047                         ;
           0048                         ;#define OS_VERSION 0x46
           0049                         ;
           0050                         ;#if defined TR72D
           0051                         ;    #message Compilation for TR-72D modules (PIC16LF1938) and IQRF OS 4.06D.
           0052                         ;    #define TR7xD
           0053                         ;#elif defined TR76D
           0054                         ;    #message Compilation for TR-76D modules (PIC16LF1938) and IQRF OS 4.06D.
           0055                         ;    #define TR7xD
           0056                         ;#elif defined TR77D
           0057                         ;    #message Compilation for TR-77D modules (PIC16LF1938) and IQRF OS 4.06D.
           0058                         ;    #define TR7xD
           0059                         ;#elif defined TR78D
           0060                         ;    #message Compilation for TR-78D modules (PIC16LF1938) and IQRF OS 4.06D.
           0061                         ;    #define TR7xD
           0062                         ;#elif defined TR75D
           0063                         ;    #message Compilation for TR-75D modules (PIC16LF1938) and IQRF OS 4.06D.
           0064                         ;    #define TR7xD
           0065                         ;#elif defined TR72G
           0066                         ;    #message Compilation for TR-72G modules (PIC16LF18877) and IQRF OS 4.06G.
           0067                         ;    #define TR7xG
           0068                         ;#elif defined TR76G
           0069                         ;    #message Compilation for TR-76G modules (PIC16LF18877) and IQRF OS 4.06G.
           0070                         ;    #define TR7xG
           0071                         ;#elif defined TR75G
           0072                         ;    #message Compilation for TR-75G modules (PIC16LF18877) and IQRF OS 4.06G.
           0073                         ;    #define TR7xG
           0074                         ;#elif defined TR82G
           0075                         ;    #message Compilation for TR-82G modules (PIC16LF18877) and IQRF OS 4.06G.
           0076                         ;    #define TR8xG
           0077                         ;#else
           0078                         ;    #error Unsupported TR module type.
           0079                         ;#endif
           0080                         ;
           0081                         ;// TR-7xD
           0082                         ;#if defined TR7xD
           0083                         ;    #if _16LF1938 != 1
           0084                         ;        #pragma chip      PIC16LF1938
           0085                         ;    #endif
           0086                         ;    
           0087                         ;    #define MCU_ID    4
           0088                         ;    #define TR_FAMILY 1 // TR-7xD
           0089                         ;
           0090                         ;    #define _ACKDT    ACKDT
           0091                         ;    #define _ACKEN    ACKEN
           0092                         ;    #define _ACKSTAT  ACKSTAT
           0093                         ;    #define _BAUDCON  BAUDCON
           0094                         ;    #define _BF       BF
           0095                         ;    #define _CKE      CKE
           0096                         ;    #define _DACCON0  DACCON0
           0097                         ;    #define _DACCON1  DACCON1
           0098                         ;    #define _EEADRH   EEADRH
           0099                         ;    #define _EEADRL   EEADRL
           0100                         ;    #define _EECON1   EECON1
           0101                         ;    #define _EECON2   EECON2
           0102                         ;    #define _EEDATH   EEDATH
           0103                         ;    #define _EEDATL   EEDATL
           0104                         ;    #define _GO       GO
           0105                         ;    #define _PEN      PEN
           0106                         ;    #define _PR6      PR6
           0107                         ;    #define _RCEN     RCEN
           0108                         ;    #define _RCREG    RCREG
           0109                         ;    #define _RCSTA    RCSTA
           0110                         ;    #define _RW_      RW_
           0111                         ;    #define _SEN      SEN
           0112                         ;    #define _SMP      SMP
           0113                         ;    #define _SPBRGH   SPBRGH
           0114                         ;    #define _SPBRGL   SPBRGL
           0115                         ;    #define _SSPADD   SSPADD
           0116                         ;    #define _SSPBUF   SSPBUF
           0117                         ;    #define _SSPCON1  SSPCON1
           0118                         ;    #define _SSPCON2  SSPCON2
           0119                         ;    #define _SSPIF    SSPIF
           0120                         ;    #define _SSPEN    SSPEN
           0121                         ;    #define _SSPSTAT  SSPSTAT
           0122                         ;    #define _SWDTEN   SWDTEN
           0123                         ;    #define _T1SYNC_  T1SYNC_
           0124                         ;    #define _TMR1ON   TMR1ON
           0125                         ;    #define _TMR6     TMR6
           0126                         ;    #define _TMR6ON   TMR6ON
           0127                         ;    #define _TXREG    TXREG
           0128                         ;    #define _TXSTA    TXSTA
           0129                         ;    #define _WDTCON   WDTCON
           0130                         ;
           0131                         ;// TR-7xG, TR-8xG
           0132                         ;#elif defined TR7xG || defined TR8xG
           0133                         ;    #if _16LF18877 != 1
           0134                         ;        #pragma chip      PIC16LF18877
           0135                         ;    #endif
           0136                         ;    
           0137                         ;    #define MCU_ID    5
           0138                         ;    
           0139                         ;    #if defined TR7xG
           0140                         ;        #define TR_FAMILY 2 // TR-7xG
           0141                         ;    #else
           0142                         ;        #define TR_FAMILY 3 // TR-8xG
           0143                         ;    #endif
           0144                         ;
           0145                         ;    #define _ACKDT    SSP1CON2.5
           0146                         ;    #define _ACKEN    SSP1CON2.4
           0147                         ;    #define _ACKSTAT  SSP1CON2.6
           0148                         ;    #define _BAUDCON  BAUD1CON
           0149                         ;    #define _BF       SSP1STAT.0
           0150                         ;    #define _CKE      SSP1STAT.6
           0151                         ;    #define _DACCON0  DAC1CON0
           0152                         ;    #define _DACCON1  DAC1CON1
           0153                         ;    #define _EEADRH   NVMADRH
           0154                         ;    #define _EEADRL   NVMADRL
           0155                         ;    #define _EECON1   NVMCON1
           0156                         ;    #define _EECON2   NVMCON2
           0157                         ;    #define _EEDATH   NVMDATH
           0158                         ;    #define _EEDATL   NVMDATL
           0159                         ;    #define _GO       ADGO
           0160                         ;    #define _PEN      SSP1CON2.2
           0161                         ;    #define _PR6      T6PR
           0162                         ;    #define _RCEN     SSP1CON2.3
           0163                         ;    #define _RCREG    RC1REG
           0164                         ;    #define _RCSTA    RC1STA
           0165                         ;    #define _RW_      SSP1STAT.2
           0166                         ;    #define _SEN      SSP1CON2.0
           0167                         ;    #define _SMP      SSP1STAT.7
           0168                         ;    #define _SPBRGH   SP1BRGH
           0169                         ;    #define _SPBRGL   SP1BRGL
           0170                         ;    #define _SSPADD   SSP1ADD
           0171                         ;    #define _SSPBUF   SSP1BUF
           0172                         ;    #define _SSPCON1  SSP1CON1
           0173                         ;    #define _SSPCON2  SSP1CON2
           0174                         ;    #define _SSPIF    SSP1IF
           0175                         ;    #define _SSPEN    SSP1CON1.5
           0176                         ;    #define _SSPSTAT  SSP1STAT
           0177                         ;    #define _SWDTEN   WDTCON0.0
           0178                         ;    #define _T1SYNC_  T1CON.2
           0179                         ;    #define _TMR1ON   T1CON.0
           0180                         ;    #define _TMR6     T6TMR
           0181                         ;    #define _TMR6ON   T6CON.7
           0182                         ;    #define _TXREG    TX1REG
           0183                         ;    #define _TXSTA    TX1STA
           0184                         ;    #define _WDTCON   WDTCON0
           0185                         ;#else
           0186                         ;    #error Unsupported TR module family.
           0187                         ;#endif
           0188                         ;
           0189                         ;#pragma origin 0x100
     0000  0190         ORG 0x0100
           0191                         ;#pragma update_RP 0
           0192                         ;
           0193                         ;void APPLICATION();
           0194                         ;
           0195                         ;void main()                                 // Skipped during Upload
           0196                         ;{
           0197 main
           0198                         ;    APPLICATION();
0100 31B8  0199         MOVLP 0x38
0101 2200  0200         CALL  APPLICATION
0102 3180  0201         MOVLP 0x00
           0202                         ;}
0103 0063  0203         SLEEP
0104 2900  0204         GOTO main
           0205 
           0206   ; FILE C:\customdpa\IQRF-functions.h
           0207                         ;// *********************************************************************
           0208                         ;//                         IQRF OS functions                           *
           0209                         ;// *********************************************************************
           0210                         ;//
           0211                         ;// Online IQRF OS Reference Guide: http://www.iqrf.org/IQRF-OS-Reference-guide/
           0212                         ;//
           0213                         ;// Copyright (c) MICRORISC s.r.o.
           0214                         ;//
           0215                         ;// Intended for:
           0216                         ;//   HW: TR-72D, TR-76D, TR-77D, TR-78D, TR-75D, TR-72G, TR-76G, TR-75G, TR-82G
           0217                         ;//   OS: 4.06D, 4.06G
           0218                         ;//
           0219                         ;// File:    IQRF-functions.h
           0220                         ;// Version: v1.01                                   Revision: 05/12/2024
           0221                         ;//
           0222                         ;// Revision history:
           0223                         ;//   v1.01: 05/12/2024  The return value of the wasRFICrestarted function is different for TR-7xD and TR-7xG module lines.
           0224                         ;//   v1.00: 03/06/2022  First release for OS 4.06D and 4.06G.
           0225                         ;//
           0226                         ;// *********************************************************************
           0227                         ;
           0228                         ;#pragma optimize 0
           0229                         ;#pragma update_PAGE 0
           0230                         ;#pragma update_RP 0
           0231                         ;
           0232                         ;// Identification header for internal use only
           0233                         ;#pragma cdata[0x3800] = OS_VERSION /* OS Version */, MCU_ID /* MCU ID */, TR_FAMILY | 0x80 /*TR Family*/
           0234                         ;
           0235                         ;#define dummy_address   0x3810
           0236                         ;#pragma origin dummy_address
     0000  0237         ORG 0x3810
           0238                         ;void dummy()
           0239                         ;{
           0240 dummy
           0241                         ;  #asm
           0242                         ;    DW 0x2000
3810 2000  0243         DW    0x2000
           0244                         ;  #endasm
           0245                         ;  #pragma updateBank exit=UserBank_01
           0246                         ;}
3811 0008  0247         RETURN
           0248                         ;
           0249                         ;#define iqrfSleep_address   0x3816
           0250                         ;#pragma origin iqrfSleep_address
     0000  0251         ORG 0x3816
           0252                         ;void iqrfSleep()
           0253                         ;{
           0254 iqrfSleep
           0255                         ;  #asm
           0256                         ;    DW 0x2000
3816 2000  0257         DW    0x2000
           0258                         ;  #endasm
           0259                         ;  #pragma updateBank exit=UserBank_01
           0260                         ;}
3817 0008  0261         RETURN
           0262                         ;
           0263                         ;#define _debug_address  0x3819
           0264                         ;#pragma origin _debug_address
     0000  0265         ORG 0x3819
           0266                         ;void _debug()
           0267                         ;{
           0268 _debug
           0269                         ;  #asm
           0270                         ;    DW 0x2000
3819 2000  0271         DW    0x2000
           0272                         ;  #endasm
           0273                         ;  #pragma updateBank exit=UserBank_01
           0274                         ;}
381A 0008  0275         RETURN
           0276                         ;
           0277                         ;#define debug()     \
           0278                         ;    do {            \
           0279                         ;        _debug();   \
           0280                         ;        nop();      \
           0281                         ;    } while (0)
           0282                         ;
           0283                         ;#define moduleInfo_address  0x381c
           0284                         ;#pragma origin moduleInfo_address
     0000  0285         ORG 0x381C
           0286                         ;void moduleInfo()
           0287                         ;{
           0288 moduleInfo
           0289                         ;  #asm
           0290                         ;    DW 0x2000
381C 2000  0291         DW    0x2000
           0292                         ;  #endasm
           0293                         ;  #pragma updateBank exit=UserBank_01
           0294                         ;}
381D 0008  0295         RETURN
           0296                         ;
           0297                         ;#define pulsingLEDR_address 0x3822
           0298                         ;#pragma origin pulsingLEDR_address
     0000  0299         ORG 0x3822
           0300                         ;void pulsingLEDR()
           0301                         ;{
           0302 pulsingLEDR
           0303                         ;  #asm
           0304                         ;    DW 0x2000
3822 2000  0305         DW    0x2000
           0306                         ;  #endasm
           0307                         ;  #pragma updateBank exit=UserBank_01
           0308                         ;}
3823 0008  0309         RETURN
           0310                         ;
           0311                         ;#define pulseLEDR_address   0x3825
           0312                         ;#pragma origin pulseLEDR_address
     0000  0313         ORG 0x3825
           0314                         ;void pulseLEDR()
           0315                         ;{
           0316 pulseLEDR
           0317                         ;  #asm
           0318                         ;    DW 0x2000
3825 2000  0319         DW    0x2000
           0320                         ;  #endasm
           0321                         ;  #pragma updateBank exit=UserBank_01
           0322                         ;}
3826 0008  0323         RETURN
           0324                         ;
           0325                         ;#define stopLEDR_address    0x3828
           0326                         ;#pragma origin stopLEDR_address
     0000  0327         ORG 0x3828
           0328                         ;void stopLEDR()
           0329                         ;{
           0330 stopLEDR
           0331                         ;  #asm
           0332                         ;    DW 0x2000
3828 2000  0333         DW    0x2000
           0334                         ;  #endasm
           0335                         ;  #pragma updateBank exit=UserBank_01
           0336                         ;}
3829 0008  0337         RETURN
           0338                         ;
           0339                         ;#define pulsingLEDG_address 0x382b
           0340                         ;#pragma origin pulsingLEDG_address
     0000  0341         ORG 0x382B
           0342                         ;void pulsingLEDG()
           0343                         ;{
           0344 pulsingLEDG
           0345                         ;  #asm
           0346                         ;    DW 0x2000
382B 2000  0347         DW    0x2000
           0348                         ;  #endasm
           0349                         ;  #pragma updateBank exit=UserBank_01
           0350                         ;}
382C 0008  0351         RETURN
           0352                         ;
           0353                         ;#define pulseLEDG_address   0x382e
           0354                         ;#pragma origin pulseLEDG_address
     0000  0355         ORG 0x382E
           0356                         ;void pulseLEDG()
           0357                         ;{
           0358 pulseLEDG
           0359                         ;  #asm
           0360                         ;    DW 0x2000
382E 2000  0361         DW    0x2000
           0362                         ;  #endasm
           0363                         ;  #pragma updateBank exit=UserBank_01
           0364                         ;}
382F 0008  0365         RETURN
           0366                         ;
           0367                         ;#define stopLEDG_address    0x3831
           0368                         ;#pragma origin stopLEDG_address
     0000  0369         ORG 0x3831
           0370                         ;void stopLEDG()
           0371                         ;{
           0372 stopLEDG
           0373                         ;  #asm
           0374                         ;    DW 0x2000
3831 2000  0375         DW    0x2000
           0376                         ;  #endasm
           0377                         ;  #pragma updateBank exit=UserBank_01
           0378                         ;}
3832 0008  0379         RETURN
           0380                         ;
           0381                         ;#define setOnPulsingLED_address 0x3834
           0382                         ;#pragma origin setOnPulsingLED_address
     0000  0383         ORG 0x3834
           0384                         ;void setOnPulsingLED(uns8 ticks @ W)
           0385                         ;{
           0386 setOnPulsingLED
           0387                         ;  #asm
           0388                         ;    DW 0x2000
3834 2000  0389         DW    0x2000
           0390                         ;  #endasm
           0391                         ;  #pragma updateBank exit=UserBank_01
           0392                         ;}
3835 0008  0393         RETURN
           0394                         ;
           0395                         ;#define setOffPulsingLED_address    0x3837
           0396                         ;#pragma origin setOffPulsingLED_address
     0000  0397         ORG 0x3837
           0398                         ;void setOffPulsingLED(uns8 ticks @ W)
           0399                         ;{
           0400 setOffPulsingLED
           0401                         ;  #asm
           0402                         ;    DW 0x2000
3837 2000  0403         DW    0x2000
           0404                         ;  #endasm
           0405                         ;  #pragma updateBank exit=UserBank_01
           0406                         ;}
3838 0008  0407         RETURN
           0408                         ;
           0409                         ;#define eeReadByte_address  0x383a
           0410                         ;#pragma origin eeReadByte_address
     0000  0411         ORG 0x383A
           0412                         ;uns8 eeReadByte(uns8 address @ W)
           0413                         ;{
           0414 eeReadByte
           0415                         ;  #asm
           0416                         ;    DW 0x2000
383A 2000  0417         DW    0x2000
           0418                         ;  #endasm
           0419                         ;  #pragma updateBank exit=UserBank_01
           0420                         ;  return W;
383B 0008  0421         RETURN
           0422                         ;}
           0423                         ;
           0424                         ;#define eeReadData_address  0x383d
           0425                         ;#pragma origin eeReadData_address
     0000  0426         ORG 0x383D
           0427                         ;bit eeReadData(uns8 address @ param2, uns8 length @ W)
           0428                         ;{
           0429 eeReadData
           0430                         ;  #asm
           0431                         ;    DW 0x2000
383D 2000  0432         DW    0x2000
           0433                         ;  #endasm
           0434                         ;  #pragma updateBank exit=UserBank_01
           0435                         ;  return Carry;
383E 0008  0436         RETURN
           0437                         ;}
           0438                         ;
           0439                         ;#define eeWriteByte_address 0x3840
           0440                         ;#pragma origin eeWriteByte_address
     0000  0441         ORG 0x3840
           0442                         ;void eeWriteByte(uns8 address @ param2, uns8 data @ W)
           0443                         ;{
           0444 eeWriteByte
           0445                         ;  #asm
           0446                         ;    DW 0x2000
3840 2000  0447         DW    0x2000
           0448                         ;  #endasm
           0449                         ;  #pragma updateBank exit=UserBank_01
           0450                         ;}
3841 0008  0451         RETURN
           0452                         ;
           0453                         ;#define eeWriteData_address 0x3843
           0454                         ;#pragma origin eeWriteData_address
     0000  0455         ORG 0x3843
           0456                         ;void eeWriteData(uns8 address @ param2, uns8 length @ W)
           0457                         ;{
           0458 eeWriteData
           0459                         ;  #asm
           0460                         ;    DW 0x2000
3843 2000  0461         DW    0x2000
           0462                         ;  #endasm
           0463                         ;  #pragma updateBank exit=UserBank_01
           0464                         ;}
3844 0008  0465         RETURN
           0466                         ;
           0467                         ;#define readFromRAM_address 0x3846
           0468                         ;#pragma origin readFromRAM_address
     0000  0469         ORG 0x3846
           0470                         ;uns8 readFromRAM(uns16 address @ FSR0)
           0471                         ;{
           0472 readFromRAM
           0473                         ;  #asm
           0474                         ;    DW 0x2000
3846 2000  0475         DW    0x2000
           0476                         ;  #endasm
           0477                         ;  #pragma updateBank exit=UserBank_01
           0478                         ;  return W;
3847 0008  0479         RETURN
           0480                         ;}
           0481                         ;
           0482                         ;#define clearBufferINFO_address 0x384c
           0483                         ;#pragma origin clearBufferINFO_address
     0000  0484         ORG 0x384C
           0485                         ;void clearBufferINFO()
           0486                         ;{
           0487 clearBufferINFO
           0488                         ;  #asm
           0489                         ;    DW 0x2000
384C 2000  0490         DW    0x2000
           0491                         ;  #endasm
           0492                         ;  #pragma updateBank exit=UserBank_01
           0493                         ;}
384D 0008  0494         RETURN
           0495                         ;
           0496                         ;#define swapBufferINFO_address  0x384f
           0497                         ;#pragma origin swapBufferINFO_address
     0000  0498         ORG 0x384F
           0499                         ;void swapBufferINFO()
           0500                         ;{
           0501 swapBufferINFO
           0502                         ;  #asm
           0503                         ;    DW 0x2000
384F 2000  0504         DW    0x2000
           0505                         ;  #endasm
           0506                         ;  #pragma updateBank exit=UserBank_01
           0507                         ;}
3850 0008  0508         RETURN
           0509                         ;
           0510                         ;#define compareBufferINFO2RF_address    0x3852
           0511                         ;#pragma origin compareBufferINFO2RF_address
     0000  0512         ORG 0x3852
           0513                         ;bit compareBufferINFO2RF(uns8 length @ W)
           0514                         ;{
           0515 compareBufferINFO2RF
           0516                         ;  #asm
           0517                         ;    DW 0x2000
3852 2000  0518         DW    0x2000
           0519                         ;  #endasm
           0520                         ;  #pragma updateBank exit=UserBank_01
           0521                         ;  return Carry;
3853 0008  0522         RETURN
           0523                         ;}
           0524                         ;
           0525                         ;#define copyBufferINFO2COM_address  0x3855
           0526                         ;#pragma origin copyBufferINFO2COM_address
     0000  0527         ORG 0x3855
           0528                         ;void copyBufferINFO2COM()
           0529                         ;{
           0530 copyBufferINFO2COM
           0531                         ;  #asm
           0532                         ;    DW 0x2000
3855 2000  0533         DW    0x2000
           0534                         ;  #endasm
           0535                         ;  #pragma updateBank exit=UserBank_01
           0536                         ;}
3856 0008  0537         RETURN
           0538                         ;
           0539                         ;#define copyBufferINFO2RF_address   0x3858
           0540                         ;#pragma origin copyBufferINFO2RF_address
     0000  0541         ORG 0x3858
           0542                         ;void copyBufferINFO2RF()
           0543                         ;{
           0544 copyBufferINFO2RF
           0545                         ;  #asm
           0546                         ;    DW 0x2000
3858 2000  0547         DW    0x2000
           0548                         ;  #endasm
           0549                         ;  #pragma updateBank exit=UserBank_01
           0550                         ;}
3859 0008  0551         RETURN
           0552                         ;
           0553                         ;#define copyBufferRF2COM_address    0x385b
           0554                         ;#pragma origin copyBufferRF2COM_address
     0000  0555         ORG 0x385B
           0556                         ;void copyBufferRF2COM()
           0557                         ;{
           0558 copyBufferRF2COM
           0559                         ;  #asm
           0560                         ;    DW 0x2000
385B 2000  0561         DW    0x2000
           0562                         ;  #endasm
           0563                         ;  #pragma updateBank exit=UserBank_01
           0564                         ;}
385C 0008  0565         RETURN
           0566                         ;
           0567                         ;#define copyBufferRF2INFO_address   0x385e
           0568                         ;#pragma origin copyBufferRF2INFO_address
     0000  0569         ORG 0x385E
           0570                         ;void copyBufferRF2INFO()
           0571                         ;{
           0572 copyBufferRF2INFO
           0573                         ;  #asm
           0574                         ;    DW 0x2000
385E 2000  0575         DW    0x2000
           0576                         ;  #endasm
           0577                         ;  #pragma updateBank exit=UserBank_01
           0578                         ;}
385F 0008  0579         RETURN
           0580                         ;
           0581                         ;#define copyBufferCOM2RF_address    0x3861
           0582                         ;#pragma origin copyBufferCOM2RF_address
     0000  0583         ORG 0x3861
           0584                         ;void copyBufferCOM2RF()
           0585                         ;{
           0586 copyBufferCOM2RF
           0587                         ;  #asm
           0588                         ;    DW 0x2000
3861 2000  0589         DW    0x2000
           0590                         ;  #endasm
           0591                         ;  #pragma updateBank exit=UserBank_01
           0592                         ;}
3862 0008  0593         RETURN
           0594                         ;
           0595                         ;#define copyBufferCOM2INFO_address  0x3864
           0596                         ;#pragma origin copyBufferCOM2INFO_address
     0000  0597         ORG 0x3864
           0598                         ;void copyBufferCOM2INFO()
           0599                         ;{
           0600 copyBufferCOM2INFO
           0601                         ;  #asm
           0602                         ;    DW 0x2000
3864 2000  0603         DW    0x2000
           0604                         ;  #endasm
           0605                         ;  #pragma updateBank exit=UserBank_01
           0606                         ;}
3865 0008  0607         RETURN
           0608                         ;
           0609                         ;#define copyMemoryBlock_address 0x3867
           0610                         ;#pragma origin copyMemoryBlock_address
     0000  0611         ORG 0x3867
           0612                         ;void copyMemoryBlock(uns16 from @ FSR0, uns16 to @ FSR1, uns8 length @ W)
           0613                         ;{
           0614 copyMemoryBlock
           0615                         ;  #asm
           0616                         ;    DW 0x2000
3867 2000  0617         DW    0x2000
           0618                         ;  #endasm
           0619                         ; #pragma updateBank exit=UserBank_01
           0620                         ;}
3868 0008  0621         RETURN
           0622                         ;
           0623                         ;#define startDelay_address  0x386a
           0624                         ;#pragma origin startDelay_address
     0000  0625         ORG 0x386A
           0626                         ;void startDelay(uns8 ticks @ W)
           0627                         ;{
           0628 startDelay
           0629                         ;  #asm
           0630                         ;    DW 0x2000
386A 2000  0631         DW    0x2000
           0632                         ;  #endasm
           0633                         ;  #pragma updateBank exit=UserBank_01
           0634                         ;}
386B 0008  0635         RETURN
           0636                         ;
           0637                         ;#define startLongDelay_address  0x386d
           0638                         ;#pragma origin startLongDelay_address
     0000  0639         ORG 0x386D
           0640                         ;void startLongDelay(uns16 ticks @ param3)
           0641                         ;{
           0642 startLongDelay
           0643                         ;  #asm
           0644                         ;    DW 0x2000
386D 2000  0645         DW    0x2000
           0646                         ;  #endasm
           0647                         ;  #pragma updateBank exit=UserBank_01
           0648                         ;}
386E 0008  0649         RETURN
           0650                         ;
           0651                         ;#define isDelay_address 0x3870
           0652                         ;#pragma origin isDelay_address
     0000  0653         ORG 0x3870
           0654                         ;bit isDelay()
           0655                         ;{
           0656 isDelay
           0657                         ;  #asm
           0658                         ;    DW 0x2000
3870 2000  0659         DW    0x2000
           0660                         ;  #endasm
           0661                         ;  #pragma updateBank exit=UserBank_01
           0662                         ;  return Carry;
3871 0008  0663         RETURN
           0664                         ;}
           0665                         ;
           0666                         ;#define waitDelay_address   0x3873
           0667                         ;#pragma origin waitDelay_address
     0000  0668         ORG 0x3873
           0669                         ;void waitDelay(uns8 ticks @ W)
           0670                         ;{
           0671 waitDelay
           0672                         ;  #asm
           0673                         ;    DW 0x2000
3873 2000  0674         DW    0x2000
           0675                         ;  #endasm
           0676                         ;  #pragma updateBank exit=UserBank_01
           0677                         ;}
3874 0008  0678         RETURN
           0679                         ;
           0680                         ;#define waitMS_address  0x3876
           0681                         ;#pragma origin waitMS_address
     0000  0682         ORG 0x3876
           0683                         ;void waitMS(uns8 ms @ W)
           0684                         ;{
           0685 waitMS
           0686                         ;  #asm
           0687                         ;    DW 0x2000
3876 2000  0688         DW    0x2000
           0689                         ;  #endasm
           0690                         ;  #pragma updateBank exit=UserBank_01
           0691                         ;}
3877 0008  0692         RETURN
           0693                         ;
           0694                         ;#define startCapture_address    0x3879
           0695                         ;#pragma origin startCapture_address
     0000  0696         ORG 0x3879
           0697                         ;void startCapture()
           0698                         ;{
           0699 startCapture
           0700                         ;  #asm
           0701                         ;    DW 0x2000
3879 2000  0702         DW    0x2000
           0703                         ;  #endasm
           0704                         ;  #pragma updateBank exit=UserBank_01
           0705                         ;}
387A 0008  0706         RETURN
           0707                         ;
           0708                         ;#define captureTicks_address    0x387c
           0709                         ;#pragma origin captureTicks_address
     0000  0710         ORG 0x387C
           0711                         ;void captureTicks()
           0712                         ;{
           0713 captureTicks
           0714                         ;  #asm
           0715                         ;    DW 0x2000
387C 2000  0716         DW    0x2000
           0717                         ;  #endasm
           0718                         ;  #pragma updateBank exit=UserBank_01
           0719                         ;}
387D 0008  0720         RETURN
           0721                         ;
           0722                         ;#define waitNewTick_address 0x3882
           0723                         ;#pragma origin waitNewTick_address
     0000  0724         ORG 0x3882
           0725                         ;void waitNewTick()
           0726                         ;{
           0727 waitNewTick
           0728                         ;  #asm
           0729                         ;    DW 0x2000
3882 2000  0730         DW    0x2000
           0731                         ;  #endasm
           0732                         ;  #pragma updateBank exit=UserBank_01
           0733                         ;}
3883 0008  0734         RETURN
           0735                         ;
           0736                         ;#define enableSPI_address   0x3885
           0737                         ;#pragma origin enableSPI_address
     0000  0738         ORG 0x3885
           0739                         ;void enableSPI()
           0740                         ;{
           0741 enableSPI
           0742                         ;  #asm
           0743                         ;    DW 0x2000
3885 2000  0744         DW    0x2000
           0745                         ;  #endasm
           0746                         ;  #pragma updateBank exit=UserBank_01
           0747                         ;}
3886 0008  0748         RETURN
           0749                         ;
           0750                         ;#define disableSPI_address  0x3888
           0751                         ;#pragma origin disableSPI_address
     0000  0752         ORG 0x3888
           0753                         ;void disableSPI()
           0754                         ;{
           0755 disableSPI
           0756                         ;  #asm
           0757                         ;    DW 0x2000
3888 2000  0758         DW    0x2000
           0759                         ;  #endasm
           0760                         ;  #pragma updateBank exit=UserBank_01
           0761                         ;}
3889 0008  0762         RETURN
           0763                         ;
           0764                         ;#define startSPI_address    0x388b
           0765                         ;#pragma origin startSPI_address
     0000  0766         ORG 0x388B
           0767                         ;void startSPI(uns8 length @ W)
           0768                         ;{
           0769 startSPI
           0770                         ;  #asm
           0771                         ;    DW 0x2000
388B 2000  0772         DW    0x2000
           0773                         ;  #endasm
           0774                         ;  #pragma updateBank exit=UserBank_01
           0775                         ;}
388C 0008  0776         RETURN
           0777                         ;
           0778                         ;#define stopSPI_address 0x388e
           0779                         ;#pragma origin stopSPI_address
     0000  0780         ORG 0x388E
           0781                         ;void stopSPI()
           0782                         ;{
           0783 stopSPI
           0784                         ;  #asm
           0785                         ;    DW 0x2000
388E 2000  0786         DW    0x2000
           0787                         ;  #endasm
           0788                         ;  #pragma updateBank exit=UserBank_01
           0789                         ;}
388F 0008  0790         RETURN
           0791                         ;
           0792                         ;#define restartSPI_address  0x3891
           0793                         ;#pragma origin restartSPI_address
     0000  0794         ORG 0x3891
           0795                         ;void restartSPI()
           0796                         ;{
           0797 restartSPI
           0798                         ;  #asm
           0799                         ;    DW 0x2000
3891 2000  0800         DW    0x2000
           0801                         ;  #endasm
           0802                         ;  #pragma updateBank exit=UserBank_01
           0803                         ;}
3892 0008  0804         RETURN
           0805                         ;
           0806                         ;#define getStatusSPI_address    0x3894
           0807                         ;#pragma origin getStatusSPI_address
     0000  0808         ORG 0x3894
           0809                         ;bit getStatusSPI()
           0810                         ;{
           0811 getStatusSPI
           0812                         ;  #asm
           0813                         ;    DW 0x2000
3894 2000  0814         DW    0x2000
           0815                         ;  #endasm
           0816                         ;  #pragma updateBank exit=UserBank_01
           0817                         ;  return Carry;
3895 0008  0818         RETURN
           0819                         ;}
           0820                         ;
           0821                         ;#define setRFpower_address  0x3897
           0822                         ;#pragma origin setRFpower_address
     0000  0823         ORG 0x3897
           0824                         ;void setRFpower(uns8 level @ W)
           0825                         ;{
           0826 setRFpower
           0827                         ;  #asm
           0828                         ;    DW 0x2000
3897 2000  0829         DW    0x2000
           0830                         ;  #endasm
           0831                         ;  #pragma updateBank exit=UserBank_01
           0832                         ;}
3898 0008  0833         RETURN
           0834                         ;
           0835                         ;#define setLEDG_address 0x389a
           0836                         ;#pragma origin setLEDG_address
     0000  0837         ORG 0x389A
           0838                         ;void setLEDG()
           0839                         ;{
           0840 setLEDG
           0841                         ;  #asm
           0842                         ;    DW 0x2000
389A 2000  0843         DW    0x2000
           0844                         ;  #endasm
           0845                         ;  #pragma updateBank exit=UserBank_01
           0846                         ;}
389B 0008  0847         RETURN
           0848                         ;
           0849                         ;#define setRFchannel_address    0x389d
           0850                         ;#pragma origin setRFchannel_address
     0000  0851         ORG 0x389D
           0852                         ;void setRFchannel(uns8 channel @ W)
           0853                         ;{
           0854 setRFchannel
           0855                         ;  #asm
           0856                         ;    DW 0x2000
389D 2000  0857         DW    0x2000
           0858                         ;  #endasm
           0859                         ;  #pragma updateBank exit=UserBank_01
           0860                         ;}
389E 0008  0861         RETURN
           0862                         ;
           0863                         ;#define setRFmode_address   0x38a0
           0864                         ;#pragma origin setRFmode_address
     0000  0865         ORG 0x38A0
           0866                         ;void setRFmode(uns8 mode @ W)
           0867                         ;{
           0868 setRFmode
           0869                         ;  #asm
           0870                         ;    DW 0x2000
38A0 2000  0871         DW    0x2000
           0872                         ;  #endasm
           0873                         ;  #pragma updateBank exit=UserBank_01
           0874                         ;}
38A1 0008  0875         RETURN
           0876                         ;
           0877                         ;#define setRFspeed_address  0x38a3
           0878                         ;#pragma origin setRFspeed_address
     0000  0879         ORG 0x38A3
           0880                         ;void setRFspeed(uns8 speed @ W)
           0881                         ;{
           0882 setRFspeed
           0883                         ;  #asm
           0884                         ;    DW 0x2000
38A3 2000  0885         DW    0x2000
           0886                         ;  #endasm
           0887                         ;  #pragma updateBank exit=UserBank_01
           0888                         ;}
38A4 0008  0889         RETURN
           0890                         ;
           0891                         ;#define setRFsleep_address  0x38a6
           0892                         ;#pragma origin setRFsleep_address
     0000  0893         ORG 0x38A6
           0894                         ;void setRFsleep()
           0895                         ;{
           0896 setRFsleep
           0897                         ;  #asm
           0898                         ;    DW 0x2000
38A6 2000  0899         DW    0x2000
           0900                         ;  #endasm
           0901                         ;  #pragma updateBank exit=UserBank_01
           0902                         ;}
38A7 0008  0903         RETURN
           0904                         ;
           0905                         ;#define setRFready_address  0x38a9
           0906                         ;#pragma origin setRFready_address
     0000  0907         ORG 0x38A9
           0908                         ;void setRFready()
           0909                         ;{
           0910 setRFready
           0911                         ;  #asm
           0912                         ;    DW 0x2000
38A9 2000  0913         DW    0x2000
           0914                         ;  #endasm
           0915                         ;  #pragma updateBank exit=UserBank_01
           0916                         ;}
38AA 0008  0917         RETURN
           0918                         ;
           0919                         ;#define RFTXpacket_address  0x38ac
           0920                         ;#pragma origin RFTXpacket_address
     0000  0921         ORG 0x38AC
           0922                         ;void RFTXpacket()
           0923                         ;{
           0924 RFTXpacket
           0925                         ;  #asm
           0926                         ;    DW 0x2000
38AC 2000  0927         DW    0x2000
           0928                         ;  #endasm
           0929                         ;  #pragma updateBank exit=UserBank_01
           0930                         ;}
38AD 0008  0931         RETURN
           0932                         ;
           0933                         ;#define RFRXpacket_address  0x38af
           0934                         ;#pragma origin RFRXpacket_address
     0000  0935         ORG 0x38AF
           0936                         ;bit RFRXpacket()
           0937                         ;{
           0938 RFRXpacket
           0939                         ;  #asm
           0940                         ;    DW 0x2000
38AF 2000  0941         DW    0x2000
           0942                         ;  #endasm
           0943                         ;  #pragma updateBank exit=UserBank_01
           0944                         ;  return Carry;
38B0 0008  0945         RETURN
           0946                         ;}
           0947                         ;
           0948                         ;#define checkRF_address 0x38b2
           0949                         ;#pragma origin checkRF_address
     0000  0950         ORG 0x38B2
           0951                         ;bit checkRF(uns8 level @ W)
           0952                         ;{
           0953 checkRF
           0954                         ;  #asm
           0955                         ;    DW 0x2000
38B2 2000  0956         DW    0x2000
           0957                         ;  #endasm
           0958                         ;  #pragma updateBank exit=UserBank_01
           0959                         ;  return Carry;
38B3 0008  0960         RETURN
           0961                         ;}
           0962                         ;
           0963                         ;#define amIBonded_address   0x38b8
           0964                         ;#pragma origin amIBonded_address
     0000  0965         ORG 0x38B8
           0966                         ;bit amIBonded()
           0967                         ;{
           0968 amIBonded
           0969                         ;  #asm
           0970                         ;    DW 0x2000
38B8 2000  0971         DW    0x2000
           0972                         ;  #endasm
           0973                         ;  #pragma updateBank exit=UserBank_01
           0974                         ;  return Carry;
38B9 0008  0975         RETURN
           0976                         ;}
           0977                         ;
           0978                         ;#define removeBond_address  0x38bb
           0979                         ;#pragma origin removeBond_address
     0000  0980         ORG 0x38BB
           0981                         ;void removeBond()
           0982                         ;{
           0983 removeBond
           0984                         ;  #asm
           0985                         ;    DW 0x2000
38BB 2000  0986         DW    0x2000
           0987                         ;  #endasm
           0988                         ;  #pragma updateBank exit=UserBank_01
           0989                         ;}
38BC 0008  0990         RETURN
           0991                         ;
           0992                         ;#define bondNewNode_address 0x38be
           0993                         ;#pragma origin bondNewNode_address
     0000  0994         ORG 0x38BE
           0995                         ;bit bondNewNode(uns8 address @ W)
           0996                         ;{
           0997 bondNewNode
           0998                         ;  #asm
           0999                         ;    DW 0x2000
38BE 2000  1000         DW    0x2000
           1001                         ;  #endasm
           1002                         ;  #pragma updateBank exit=UserBank_01
           1003                         ;  return Carry;
38BF 0008  1004         RETURN
           1005                         ;}
           1006                         ;
           1007                         ;#define isBondedNode_address    0x38c1
           1008                         ;#pragma origin isBondedNode_address
     0000  1009         ORG 0x38C1
           1010                         ;bit isBondedNode(uns8 address @ W)
           1011                         ;{
           1012 isBondedNode
           1013                         ;  #asm
           1014                         ;    DW 0x2000
38C1 2000  1015         DW    0x2000
           1016                         ;  #endasm
           1017                         ;  #pragma updateBank exit=UserBank_01
           1018                         ;  return Carry;
38C2 0008  1019         RETURN
           1020                         ;}
           1021                         ;
           1022                         ;#define removeBondedNode_address    0x38c4
           1023                         ;#pragma origin removeBondedNode_address
     0000  1024         ORG 0x38C4
           1025                         ;void removeBondedNode(uns8 address @ W)
           1026                         ;{
           1027 removeBondedNode
           1028                         ;  #asm
           1029                         ;    DW 0x2000
38C4 2000  1030         DW    0x2000
           1031                         ;  #endasm
           1032                         ;  #pragma updateBank exit=UserBank_01
           1033                         ;}
38C5 0008  1034         RETURN
           1035                         ;
           1036                         ;#define rebondNode_address  0x38c7
           1037                         ;#pragma origin rebondNode_address
     0000  1038         ORG 0x38C7
           1039                         ;bit rebondNode(uns8 address @ W)
           1040                         ;{
           1041 rebondNode
           1042                         ;  #asm
           1043                         ;    DW 0x2000
38C7 2000  1044         DW    0x2000
           1045                         ;  #endasm
           1046                         ;  #pragma updateBank exit=UserBank_01
           1047                         ;  return Carry;
38C8 0008  1048         RETURN
           1049                         ;}
           1050                         ;
           1051                         ;#define clearAllBonds_address   0x38ca
           1052                         ;#pragma origin clearAllBonds_address
     0000  1053         ORG 0x38CA
           1054                         ;void clearAllBonds()
           1055                         ;{
           1056 clearAllBonds
           1057                         ;  #asm
           1058                         ;    DW 0x2000
38CA 2000  1059         DW    0x2000
           1060                         ;  #endasm
           1061                         ;  #pragma updateBank exit=UserBank_01
           1062                         ;}
38CB 0008  1063         RETURN
           1064                         ;
           1065                         ;#define setNonetMode_address    0x38cd
           1066                         ;#pragma origin setNonetMode_address
     0000  1067         ORG 0x38CD
           1068                         ;void setNonetMode()
           1069                         ;{
           1070 setNonetMode
           1071                         ;  #asm
           1072                         ;    DW 0x2000
38CD 2000  1073         DW    0x2000
           1074                         ;  #endasm
           1075                         ;  #pragma updateBank exit=UserBank_01
           1076                         ;}
38CE 0008  1077         RETURN
           1078                         ;
           1079                         ;#define setCoordinatorMode_address  0x38d0
           1080                         ;#pragma origin setCoordinatorMode_address
     0000  1081         ORG 0x38D0
           1082                         ;void setCoordinatorMode()
           1083                         ;{
           1084 setCoordinatorMode
           1085                         ;  #asm
           1086                         ;    DW 0x2000
38D0 2000  1087         DW    0x2000
           1088                         ;  #endasm
           1089                         ;  #pragma updateBank exit=UserBank_01
           1090                         ;}
38D1 0008  1091         RETURN
           1092                         ;
           1093                         ;#define setNodeMode_address 0x38d3
           1094                         ;#pragma origin setNodeMode_address
     0000  1095         ORG 0x38D3
           1096                         ;void setNodeMode()
           1097                         ;{
           1098 setNodeMode
           1099                         ;  #asm
           1100                         ;    DW 0x2000
38D3 2000  1101         DW    0x2000
           1102                         ;  #endasm
           1103                         ;  #pragma updateBank exit=UserBank_01
           1104                         ;}
38D4 0008  1105         RETURN
           1106                         ;
           1107                         ;#define setNetworkFilteringOn_address   0x38d6
           1108                         ;#pragma origin setNetworkFilteringOn_address
     0000  1109         ORG 0x38D6
           1110                         ;void setNetworkFilteringOn()
           1111                         ;{
           1112 setNetworkFilteringOn
           1113                         ;  #asm
           1114                         ;    DW 0x2000
38D6 2000  1115         DW    0x2000
           1116                         ;  #endasm
           1117                         ;  #pragma updateBank exit=UserBank_01
           1118                         ;}
38D7 0008  1119         RETURN
           1120                         ;
           1121                         ;#define setNetworkFilteringOff_address  0x38d9
           1122                         ;#pragma origin setNetworkFilteringOff_address
     0000  1123         ORG 0x38D9
           1124                         ;void setNetworkFilteringOff()
           1125                         ;{
           1126 setNetworkFilteringOff
           1127                         ;  #asm
           1128                         ;    DW 0x2000
38D9 2000  1129         DW    0x2000
           1130                         ;  #endasm
           1131                         ;  #pragma updateBank exit=UserBank_01
           1132                         ;}
38DA 0008  1133         RETURN
           1134                         ;
           1135                         ;#define getNetworkParams_address    0x38dc
           1136                         ;#pragma origin getNetworkParams_address
     0000  1137         ORG 0x38DC
           1138                         ;uns8 getNetworkParams()
           1139                         ;{
           1140 getNetworkParams
           1141                         ;  #asm
           1142                         ;    DW 0x2000
38DC 2000  1143         DW    0x2000
           1144                         ;  #endasm
           1145                         ;  #pragma updateBank exit=UserBank_01
           1146                         ;  return W;
38DD 0008  1147         RETURN
           1148                         ;}
           1149                         ;
           1150                         ;#define setRoutingOn_address    0x38df
           1151                         ;#pragma origin setRoutingOn_address
     0000  1152         ORG 0x38DF
           1153                         ;void setRoutingOn()
           1154                         ;{
           1155 setRoutingOn
           1156                         ;  #asm
           1157                         ;    DW 0x2000
38DF 2000  1158         DW    0x2000
           1159                         ;  #endasm
           1160                         ;  #pragma updateBank exit=UserBank_01
           1161                         ;}
38E0 0008  1162         RETURN
           1163                         ;
           1164                         ;#define setRoutingOff_address   0x38e2
           1165                         ;#pragma origin setRoutingOff_address
     0000  1166         ORG 0x38E2
           1167                         ;void setRoutingOff()
           1168                         ;{
           1169 setRoutingOff
           1170                         ;  #asm
           1171                         ;    DW 0x2000
38E2 2000  1172         DW    0x2000
           1173                         ;  #endasm
           1174                         ;  #pragma updateBank exit=UserBank_01
           1175                         ;}
38E3 0008  1176         RETURN
           1177                         ;
           1178                         ;#define answerSystemPacket_address  0x38e8
           1179                         ;#pragma origin answerSystemPacket_address
     0000  1180         ORG 0x38E8
           1181                         ;void answerSystemPacket()
           1182                         ;{
           1183 answerSystemPacket
           1184                         ;  #asm
           1185                         ;    DW 0x2000
38E8 2000  1186         DW    0x2000
           1187                         ;  #endasm
           1188                         ;  #pragma updateBank exit=UserBank_01
           1189                         ;}
38E9 0008  1190         RETURN
           1191                         ;
           1192                         ;#define discovery_address   0x38eb
           1193                         ;#pragma origin discovery_address
     0000  1194         ORG 0x38EB
           1195                         ;uns8 discovery(uns8 MaxNodeAddress @ W)
           1196                         ;{
           1197 discovery
           1198                         ;  #asm
           1199                         ;    DW 0x2000
38EB 2000  1200         DW    0x2000
           1201                         ;  #endasm
           1202                         ;  #pragma updateBank exit=UserBank_01
           1203                         ;  return W;
38EC 0008  1204         RETURN
           1205                         ;}
           1206                         ;
           1207                         ;#define wasRouted_address   0x38ee
           1208                         ;#pragma origin wasRouted_address
     0000  1209         ORG 0x38EE
           1210                         ;bit wasRouted()
           1211                         ;{
           1212 wasRouted
           1213                         ;  #asm
           1214                         ;    DW 0x2000
38EE 2000  1215         DW    0x2000
           1216                         ;  #endasm
           1217                         ;  #pragma updateBank exit=UserBank_01
           1218                         ;  return Carry;
38EF 0008  1219         RETURN
           1220                         ;}
           1221                         ;
           1222                         ;#define optimizeHops_address    0x38f1
           1223                         ;#pragma origin optimizeHops_address
     0000  1224         ORG 0x38F1
           1225                         ;bit optimizeHops(uns8 method @ W)
           1226                         ;{
           1227 optimizeHops
           1228                         ;  #asm
           1229                         ;    DW 0x2000
38F1 2000  1230         DW    0x2000
           1231                         ;  #endasm
           1232                         ;  #pragma updateBank exit=UserBank_01
           1233                         ;  return Carry;
38F2 0008  1234         RETURN
           1235                         ;}
           1236                         ;
           1237                         ;#define getSupplyVoltage_address    0x38f4
           1238                         ;#pragma origin getSupplyVoltage_address
     0000  1239         ORG 0x38F4
           1240                         ;uns8 getSupplyVoltage()
           1241                         ;{
           1242 getSupplyVoltage
           1243                         ;  #asm
           1244                         ;    DW 0x2000
38F4 2000  1245         DW    0x2000
           1246                         ;  #endasm
           1247                         ;  #pragma updateBank exit=UserBank_01
           1248                         ;  return W;
38F5 0008  1249         RETURN
           1250                         ;}
           1251                         ;
           1252                         ;#define getTemperature_address  0x38f7
           1253                         ;#pragma origin getTemperature_address
     0000  1254         ORG 0x38F7
           1255                         ;int8 getTemperature()
           1256                         ;{
           1257 getTemperature
           1258                         ;  #asm
           1259                         ;    DW 0x2000
38F7 2000  1260         DW    0x2000
           1261                         ;  #endasm
           1262                         ;  #pragma updateBank exit=UserBank_01
           1263                         ;  return W;
38F8 0008  1264         RETURN
           1265                         ;}
           1266                         ;
           1267                         ;#define clearBufferRF_address   0x38fa
           1268                         ;#pragma origin clearBufferRF_address
     0000  1269         ORG 0x38FA
           1270                         ;void clearBufferRF()
           1271                         ;{
           1272 clearBufferRF
           1273                         ;  #asm
           1274                         ;    DW 0x2000
38FA 2000  1275         DW    0x2000
           1276                         ;  #endasm
           1277                         ;  #pragma updateBank exit=UserBank_01
           1278                         ;}
38FB 0008  1279         RETURN
           1280                         ;
           1281                         ;#define isDiscoveredNode_address    0x3910
           1282                         ;#pragma origin isDiscoveredNode_address
     0000  1283         ORG 0x3910
           1284                         ;bit isDiscoveredNode(uns8 address @ W)
           1285                         ;{
           1286 isDiscoveredNode
           1287                         ;  #asm
           1288                         ;    DW 0x2000
3910 2000  1289         DW    0x2000
           1290                         ;  #endasm
           1291                         ;  #pragma updateBank exit=UserBank_01
           1292                         ;  return Carry;
3911 0008  1293         RETURN
           1294                         ;}
           1295                         ;
           1296                         ;#define enableRFPGM_address 0x3913
           1297                         ;#pragma origin enableRFPGM_address
     0000  1298         ORG 0x3913
           1299                         ;void enableRFPGM()
           1300                         ;{
           1301 enableRFPGM
           1302                         ;  #asm
           1303                         ;    DW 0x2000
3913 2000  1304         DW    0x2000
           1305                         ;  #endasm
           1306                         ;  #pragma updateBank exit=UserBank_01
           1307                         ;}
3914 0008  1308         RETURN
           1309                         ;
           1310                         ;#define disableRFPGM_address    0x3916
           1311                         ;#pragma origin disableRFPGM_address
     0000  1312         ORG 0x3916
           1313                         ;void disableRFPGM()
           1314                         ;{
           1315 disableRFPGM
           1316                         ;  #asm
           1317                         ;    DW 0x2000
3916 2000  1318         DW    0x2000
           1319                         ;  #endasm
           1320                         ;  #pragma updateBank exit=UserBank_01
           1321                         ;}
3917 0008  1322         RETURN
           1323                         ;
           1324                         ;#define setupRFPGM_address  0x3919
           1325                         ;#pragma origin setupRFPGM_address
     0000  1326         ORG 0x3919
           1327                         ;void setupRFPGM(uns8 x @ W)
           1328                         ;{
           1329 setupRFPGM
           1330                         ;  #asm
           1331                         ;    DW 0x2000
3919 2000  1332         DW    0x2000
           1333                         ;  #endasm
           1334                         ;  #pragma updateBank exit=UserBank_01
           1335                         ;}
391A 0008  1336         RETURN
           1337                         ;
           1338                         ;#define runRFPGM_address    0x391c
           1339                         ;#pragma origin runRFPGM_address
     0000  1340         ORG 0x391C
           1341                         ;void runRFPGM()
           1342                         ;{
           1343 runRFPGM
           1344                         ;  #asm
           1345                         ;    DW 0x2000
391C 2000  1346         DW    0x2000
           1347                         ;  #endasm
           1348                         ;  #pragma updateBank exit=UserBank_01
           1349                         ;}
391D 0008  1350         RETURN
           1351                         ;
           1352                         ;#define iqrfDeepSleep_address   0x391f
           1353                         ;#pragma origin iqrfDeepSleep_address
     0000  1354         ORG 0x391F
           1355                         ;void iqrfDeepSleep()
           1356                         ;{
           1357 iqrfDeepSleep
           1358                         ;  #asm
           1359                         ;    DW 0x2000
391F 2000  1360         DW    0x2000
           1361                         ;  #endasm
           1362                         ;  #pragma updateBank exit=UserBank_01
           1363                         ;}
3920 0008  1364         RETURN
           1365                         ;
           1366                         ;#define wasRFICrestarted_address    0x3922
           1367                         ;#pragma origin wasRFICrestarted_address
     0000  1368         ORG 0x3922
           1369                         ;#if !defined( TR7xD )
           1370                         ;    bit wasRFICrestarted()
           1371                         ;    {
           1372 wasRFICrestarted
           1373                         ;      #asm
           1374                         ;        DW 0x2000
3922 2000  1375         DW    0x2000
           1376                         ;      #endasm
           1377                         ;      #pragma updateBank exit=UserBank_01
           1378                         ;      return Carry;
3923 0008  1379         RETURN
           1380                         ;    }
           1381                         ;#else
           1382                         ;    uns8 wasRFICrestarted()
           1383                         ;    {
           1384                         ;      #asm
           1385                         ;        DW 0x2000
           1386                         ;      #endasm
           1387                         ;      #pragma updateBank exit=UserBank_01
           1388                         ;      return W;
           1389                         ;    }
           1390                         ;#endif
           1391                         ;
           1392                         ;#define eeeWriteData_address    0x3925
           1393                         ;#pragma origin eeeWriteData_address
     0000  1394         ORG 0x3925
           1395                         ;bit eeeWriteData(uns16 address @ param3)
           1396                         ;{
           1397 eeeWriteData
           1398                         ;  #asm
           1399                         ;    DW 0x2000
3925 2000  1400         DW    0x2000
           1401                         ;  #endasm
           1402                         ;  #pragma updateBank exit=UserBank_01
           1403                         ;  return Carry;
3926 0008  1404         RETURN
           1405                         ;}
           1406                         ;
           1407                         ;#define eeeReadData_address 0x3928
           1408                         ;#pragma origin eeeReadData_address
     0000  1409         ORG 0x3928
           1410                         ;bit eeeReadData(uns16 address @ param3)
           1411                         ;{
           1412 eeeReadData
           1413                         ;  #asm
           1414                         ;    DW 0x2000
3928 2000  1415         DW    0x2000
           1416                         ;  #endasm
           1417                         ;  #pragma updateBank exit=UserBank_01
           1418                         ;  return Carry;
3929 0008  1419         RETURN
           1420                         ;}
           1421                         ;
           1422                         ;#define setINDF0_address    0x3931
           1423                         ;#pragma origin setINDF0_address
     0000  1424         ORG 0x3931
           1425                         ;void setINDF0(uns8 value @ W)
           1426                         ;{
           1427 setINDF0
           1428                         ;  #asm
           1429                         ;    DW 0x2000
3931 2000  1430         DW    0x2000
           1431                         ;  #endasm
           1432                         ;  #pragma updateBank exit=UserBank_01
           1433                         ;}
3932 0008  1434         RETURN
           1435                         ;
           1436                         ;#define setINDF1_address    0x3934
           1437                         ;#pragma origin setINDF1_address
     0000  1438         ORG 0x3934
           1439                         ;void setINDF1(uns8 value @ W)
           1440                         ;{
           1441 setINDF1
           1442                         ;  #asm
           1443                         ;    DW 0x2000
3934 2000  1444         DW    0x2000
           1445                         ;  #endasm
           1446                         ;  #pragma updateBank exit=UserBank_01
           1447                         ;}
3935 0008  1448         RETURN
           1449                         ;
           1450                         ;#define getRSSI_address 0x3937
           1451                         ;#pragma origin getRSSI_address
     0000  1452         ORG 0x3937
           1453                         ;uns8 getRSSI()
           1454                         ;{
           1455 getRSSI
           1456                         ;  #asm
           1457                         ;    DW 0x2000
3937 2000  1458         DW    0x2000
           1459                         ;  #endasm
           1460                         ;  #pragma updateBank exit=UserBank_01
           1461                         ;  return W;
3938 0008  1462         RETURN
           1463                         ;}
           1464                         ;
           1465                         ;#define removeBondAddress_address   0x393a
           1466                         ;#pragma origin removeBondAddress_address
     0000  1467         ORG 0x393A
           1468                         ;void removeBondAddress()
           1469                         ;{
           1470 removeBondAddress
           1471                         ;  #asm
           1472                         ;    DW 0x2000
393A 2000  1473         DW    0x2000
           1474                         ;  #endasm
           1475                         ;  #pragma updateBank exit=UserBank_01
           1476                         ;}
393B 0008  1477         RETURN
           1478                         ;
           1479                         ;#define sendFRC_address 0x393d
           1480                         ;#pragma origin sendFRC_address
     0000  1481         ORG 0x393D
           1482                         ;uns8 sendFRC(uns8 command @ W)
           1483                         ;{
           1484 sendFRC
           1485                         ;  #asm
           1486                         ;    DW 0x2000
393D 2000  1487         DW    0x2000
           1488                         ;  #endasm
           1489                         ;  #pragma updateBank exit=UserBank_01
           1490                         ;  return W;
393E 0008  1491         RETURN
           1492                         ;}
           1493                         ;
           1494                         ;#define responseFRC_address 0x3940
           1495                         ;#pragma origin responseFRC_address
     0000  1496         ORG 0x3940
           1497                         ;void responseFRC()
           1498                         ;{
           1499 responseFRC
           1500                         ;  #asm
           1501                         ;    DW 0x2000
3940 2000  1502         DW    0x2000
           1503                         ;  #endasm
           1504                         ;  #pragma updateBank exit=UserBank_01
           1505                         ;}
3941 0008  1506         RETURN
           1507                         ;
           1508                         ;#define bondRequestAdvanced_address 0x3943
           1509                         ;#pragma origin bondRequestAdvanced_address
     0000  1510         ORG 0x3943
           1511                         ;bit bondRequestAdvanced()
           1512                         ;{
           1513 bondRequestAdvanced
           1514                         ;  #asm
           1515                         ;    DW 0x2000
3943 2000  1516         DW    0x2000
           1517                         ;  #endasm
           1518                         ;  #pragma updateBank exit=UserBank_01
           1519                         ;  return Carry;
3944 0008  1520         RETURN
           1521                         ;}
           1522                         ;
           1523                         ;#define prebondNodeAtNode_address   0x3946
           1524                         ;#pragma origin prebondNodeAtNode_address
     0000  1525         ORG 0x3946
           1526                         ;bit prebondNodeAtNode()
           1527                         ;{
           1528 prebondNodeAtNode
           1529                         ;  #asm
           1530                         ;    DW 0x2000
3946 2000  1531         DW    0x2000
           1532                         ;  #endasm
           1533                         ;  #pragma updateBank exit=UserBank_01
           1534                         ;  return Carry;
3947 0008  1535         RETURN
           1536                         ;}
           1537                         ;
           1538                         ;#define nodeAuthorization_address   0x3949
           1539                         ;#pragma origin nodeAuthorization_address
     0000  1540         ORG 0x3949
           1541                         ;bit nodeAuthorization(uns8 address @ W)
           1542                         ;{
           1543 nodeAuthorization
           1544                         ;  #asm
           1545                         ;    DW 0x2000
3949 2000  1546         DW    0x2000
           1547                         ;  #endasm
           1548                         ;  #pragma updateBank exit=UserBank_01
           1549                         ;  return Carry;
394A 0008  1550         RETURN
           1551                         ;}
           1552                         ;
           1553                         ;#define dummy01_address 0x394c
           1554                         ;#pragma origin dummy01_address
     0000  1555         ORG 0x394C
           1556                         ;void dummy01()
           1557                         ;{
           1558 dummy01
           1559                         ;  #asm
           1560                         ;  DW 0x2000
394C 2000  1561         DW    0x2000
           1562                         ;  #endasm
           1563                         ;  #pragma updateBank exit=UserBank_01
           1564                         ;}
394D 0008  1565         RETURN
           1566                         ;
           1567                         ;#define setAccessPassword_address   0x3958
           1568                         ;#pragma origin setAccessPassword_address
     0000  1569         ORG 0x3958
           1570                         ;void setAccessPassword()
           1571                         ;{
           1572 setAccessPassword
           1573                         ;  #asm
           1574                         ;    DW 0x2000
3958 2000  1575         DW    0x2000
           1576                         ;  #endasm
           1577                         ;  #pragma updateBank exit=UserBank_01
           1578                         ;}
3959 0008  1579         RETURN
           1580                         ;
           1581                         ;#define setUserKey_address  0x395b
           1582                         ;#pragma origin setUserKey_address
     0000  1583         ORG 0x395B
           1584                         ;void setUserKey()
           1585                         ;{
           1586 setUserKey
           1587                         ;  #asm
           1588                         ;    DW 0x2000
395B 2000  1589         DW    0x2000
           1590                         ;  #endasm
           1591                         ;  #pragma updateBank exit=UserBank_01
           1592                         ;}
395C 0008  1593         RETURN
           1594                         ;
           1595                         ;#define amIRecipientOfFRC_address   0x3961
           1596                         ;#pragma origin amIRecipientOfFRC_address
     0000  1597         ORG 0x3961
           1598                         ;bit amIRecipientOfFRC()
           1599                         ;{
           1600 amIRecipientOfFRC
           1601                         ;  #asm
           1602                         ;    DW 0x2000
3961 2000  1603         DW    0x2000
           1604                         ;  #endasm
           1605                         ;  #pragma updateBank exit=UserBank_01
           1606                         ;  return Carry;
3962 0008  1607         RETURN
           1608                         ;}
           1609                         ;
           1610                         ;#define setLEDR_address 0x3964
           1611                         ;#pragma origin setLEDR_address
     0000  1612         ORG 0x3964
           1613                         ;void setLEDR()
           1614                         ;{
           1615 setLEDR
           1616                         ;  #asm
           1617                         ;    DW 0x2000
3964 2000  1618         DW    0x2000
           1619                         ;  #endasm
           1620                         ;  #pragma updateBank exit=UserBank_01
           1621                         ;}
3965 0008  1622         RETURN
           1623                         ;
           1624                         ;#define encryptBufferRF_address 0x3967
           1625                         ;#pragma origin encryptBufferRF_address
     0000  1626         ORG 0x3967
           1627                         ;void encryptBufferRF(uns8 blocks @ W)
           1628                         ;{
           1629 encryptBufferRF
           1630                         ;  #asm
           1631                         ;    DW 0x2000
3967 2000  1632         DW    0x2000
           1633                         ;  #endasm
           1634                         ;  #pragma updateBank exit=UserBank_01
           1635                         ;}
3968 0008  1636         RETURN
           1637                         ;
           1638                         ;#define decryptBufferRF_address 0x396a
           1639                         ;#pragma origin decryptBufferRF_address
     0000  1640         ORG 0x396A
           1641                         ;void decryptBufferRF(uns8 blocks @ W)
           1642                         ;{
           1643 decryptBufferRF
           1644                         ;  #asm
           1645                         ;    DW 0x2000
396A 2000  1646         DW    0x2000
           1647                         ;  #endasm
           1648                         ;  #pragma updateBank exit=UserBank_01
           1649                         ;}
396B 0008  1650         RETURN
           1651                         ;
           1652                         ;#define prebondNodeAtCoordinator_address    0x396d
           1653                         ;#pragma origin prebondNodeAtCoordinator_address
     0000  1654         ORG 0x396D
           1655                         ;bit prebondNodeAtCoordinator(uns8 address @ W)
           1656                         ;{
           1657 prebondNodeAtCoordinator
           1658                         ;  #asm
           1659                         ;    DW 0x2000
396D 2000  1660         DW    0x2000
           1661                         ;  #endasm
           1662                         ;  #pragma updateBank exit=UserBank_01
           1663                         ;  return Carry;
396E 0008  1664         RETURN
           1665                         ;}
           1666                         ;
           1667                         ;#define setFSRs_address 0x3970
           1668                         ;#pragma origin setFSRs_address
     0000  1669         ORG 0x3970
           1670                         ;uns8 setFSRs(uns8 fsrs @ W)
           1671                         ;{
           1672 setFSRs
           1673                         ;  #asm
           1674                         ;    DW 0x2000
3970 2000  1675         DW    0x2000
           1676                         ;  #endasm
           1677                         ;  #pragma updateBank exit=UserBank_01
           1678                         ;  return W;
3971 0008  1679         RETURN
           1680                         ;}
           1681                         ;
           1682                         ;// For internal usage only
           1683                         ;#define updateCRC16_address 0x3973
           1684                         ;#pragma origin updateCRC16_address
     0000  1685         ORG 0x3973
           1686                         ;void updateCRC16(uns8 value @ W)
           1687                         ;{
           1688 updateCRC16
           1689                         ;  #asm
           1690                         ;    DW 0x2000
3973 2000  1691         DW    0x2000
           1692                         ;  #endasm
           1693                         ;  #pragma updateBank exit=UserBank_01
           1694                         ;}
3974 0008  1695         RETURN
           1696                         ;
           1697                         ;#define smartConnect_address    0x3976
           1698                         ;#pragma origin smartConnect_address
     0000  1699         ORG 0x3976
           1700                         ;bit smartConnect(uns8 address @ W)
           1701                         ;{
           1702 smartConnect
           1703                         ;  #asm
           1704                         ;    DW 0x2000
3976 2000  1705         DW    0x2000
           1706                         ;  #endasm
           1707                         ;  #pragma updateBank exit=UserBank_01
           1708                         ;  return Carry;
3977 0008  1709         RETURN
           1710                         ;}
           1711                         ;
           1712                         ;#define addressBitmap_address   0x3979
           1713                         ;#pragma origin addressBitmap_address
     0000  1714         ORG 0x3979
           1715                         ;uns8 addressBitmap(uns8 bitIndex @ W)
           1716                         ;{
           1717 addressBitmap
           1718                         ;  #asm
           1719                         ;    DW 0x2000
3979 2000  1720         DW    0x2000
           1721                         ;  #endasm
           1722                         ;  #pragma updateBank exit=UserBank_01
           1723                         ;  return W;
397A 0008  1724         RETURN
           1725                         ;}
           1726                         ;
           1727                         ;#define setServiceChannel_address   0x397c
           1728                         ;#pragma origin setServiceChannel_address
     0000  1729         ORG 0x397C
           1730                         ;bit setServiceChannel(uns8 channelNumber @ W)
           1731                         ;{
           1732 setServiceChannel
           1733                         ;  #asm
           1734                         ;    DW 0x2000
397C 2000  1735         DW    0x2000
           1736                         ;  #endasm
           1737                         ;  #pragma updateBank exit=UserBank_01
           1738                         ;  return Carry;
397D 0008  1739         RETURN
           1740                         ;}
           1741                         ;
           1742                         ;#pragma optimize 1
           1743                         ;#pragma update_RP 1
           1744                         ;#pragma update_PAGE 1
           1745                         ;#pragma origin __APPLICATION_ADDRESS
     0000  1746         ORG 0x3A00
           1747 
           1748   ; FILE C:\customdpa\DPA.h
           1749                         ;// *********************************************************************
           1750                         ;//   General public DPA header file                                    *
           1751                         ;// *********************************************************************
           1752                         ;// Copyright (c) MICRORISC s.r.o.
           1753                         ;//
           1754                         ;// File:    $RCSfile: DPA.h,v $
           1755                         ;// Version: $Revision: 1.329 $
           1756                         ;// Date:    $Date: 2024/12/05 09:28:57 $
           1757                         ;//
           1758                         ;// Revision history:
           1759                         ;//   2024/11/05  Release for DPA 4.32
           1760                         ;//   2024/04/17  Release for DPA 4.31
           1761                         ;//   2023/03/07  Release for DPA 4.30
           1762                         ;//   2022/10/05  Release for DPA 4.18
           1763                         ;//   2022/02/24  Release for DPA 4.17
           1764                         ;//   2021/08/20  Release for DPA 4.16
           1765                         ;//   2020/09/03  Release for DPA 4.15
           1766                         ;//   2020/04/03  Release for DPA 4.14
           1767                         ;//   2020/02/27  Release for DPA 4.13
           1768                         ;//   2020/01/09  Release for DPA 4.12
           1769                         ;//   2019/12/11  Release for DPA 4.11
           1770                         ;//   2019/10/09  Release for DPA 4.10
           1771                         ;//   2019/06/12  Release for DPA 4.03
           1772                         ;//   2019/06/03  Release for DPA 4.02
           1773                         ;//   2019/03/07  Release for DPA 4.01
           1774                         ;//   2019/01/10  Release for DPA 4.00
           1775                         ;//   2018/10/25  Release for DPA 3.03
           1776                         ;//   2017/11/16  Release for DPA 3.02
           1777                         ;//   2017/08/14  Release for DPA 3.01
           1778                         ;//   2017/03/13  Release for DPA 3.00
           1779                         ;//   2016/09/12  Release for DPA 2.28
           1780                         ;//   2016/04/14  Release for DPA 2.27
           1781                         ;//   2016/03/03  Release for DPA 2.26
           1782                         ;//   2016/01/21  Release for DPA 2.25
           1783                         ;//   2015/12/01  Release for DPA 2.24
           1784                         ;//   2015/10/23  Release for DPA 2.23
           1785                         ;//   2015/09/25  Release for DPA 2.22
           1786                         ;//   2015/09/03  Release for DPA 2.21
           1787                         ;//   2015/08/05  Release for DPA 2.20
           1788                         ;//   2014/10/31  Release for DPA 2.10
           1789                         ;//   2014/04/30  Release for DPA 2.00
           1790                         ;//   2013/10/03  Release for DPA 1.00
           1791                         ;//
           1792                         ;// *********************************************************************
           1793                         ;
           1794                         ;// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
           1795                         ;// IQRF Standards documentation https://doc.iqrf.org/
           1796                         ;
           1797                         ;#ifndef _DPA_HEADER_
           1798                         ;#define _DPA_HEADER_
           1799                         ;
           1800                         ;//############################################################################################
           1801                         ;
           1802                         ;// DPA version
           1803                         ;#define DPA_VERSION_MASTER          0x0432
           1804                         ;
           1805                         ;#if defined( __CC5X__ ) && !defined( CC5XnotDPA )
           1806                         ;// Compiled only at CC5X
           1807                         ;#if __CC5X__ < 3800
           1808                         ;#error Insufficient CC5X compiler version, V3.8 is minimum
           1809                         ;#endif
           1810                         ;
           1811                         ;#if IQRFOS < 406
           1812                         ;#error IQRF OS 4.06+ is required
           1813                         ;#endif
           1814                         ;
           1815                         ;// Bank for custom variables
           1816                         ;#pragma rambank = UserBank_01
           1817                         ;
           1818                         ;// Main DPA API entry address (also start of the licensed FLASH)
           1819                         ;#define DPA_API_ADDRESS             __LICENSED_FLASH
           1820                         ;
           1821                         ;// Main DPA entry address
           1822                         ;#define MAIN_DPA_ADDRESS            ( DPA_API_ADDRESS + 4 )
           1823                         ;
           1824                         ;// Main DPA API entry address stub
           1825                         ;#define DPA_API_ADDRESS_ENTRY       0x3A08
           1826                         ;
           1827                         ;// Address of the DPA Custom Handler
           1828                         ;#define CUSTOM_HANDLER_ADDRESS      0x3A20
           1829                         ;
           1830                         ;// Address of the DPA Custom Handler end + 1
           1831                         ;#if defined TR7xD
           1832                         ;#define CUSTOM_HANDLER_ADDRESS_END  0x3D80
           1833                         ;#else
           1834                         ;#define CUSTOM_HANDLER_ADDRESS_END  __USER_INTERRUPT
           1835                         ;#endif
           1836                         ;
           1837                         ;// DPA API entry function
           1838                         ;uns8  DpaApiEntry( uns8 par1, uns8 par2, uns8 apiIndex );
           1839                         ;
           1840                         ;// DPA API codes
           1841                         ;#define DPA_API_RFTX_DPAPACKET              0
           1842                         ;#define DPA_API_READ_CONFIG_BYTE            1
           1843                         ;#define DPA_API_SEND_TO_IFACEMASTER         2
           1844                         ;#define DPA_API_COORDINATOR_RFTX_DPAPACKET  3
           1845                         ;#define DPA_API_LOCAL_REQUEST               4
           1846                         ;#define DPA_API_SET_PERIPHERAL_ERROR        5
           1847                         ;#define DPA_API_SET_RF_DEFAULTS             6
           1848                         ;#define DPA_API_LOCAL_FRC                   7
           1849                         ;#define DPA_API_CRC8                        8
           1850                         ;#define DPA_API_AGGREGATE_FRC               9
           1851                         ;#define DPA_API_SET_OTK                     10
           1852                         ;#define DPA_API_I2C_INIT                    11
           1853                         ;#define DPA_API_I2C_START                   12
           1854                         ;#define DPA_API_I2C_WRITE                   13
           1855                         ;#define DPA_API_I2C_READ                    14
           1856                         ;#define DPA_API_I2C_STOP                    15
           1857                         ;#define DPA_API_I2C_WAIT_FOR_ACK            16
           1858                         ;#define DPA_API_I2C_SHUTDOWN                17
           1859                         ;#define DPA_API_I2C_WAIT_FOR_IDLE           18
           1860                         ;#define DPA_API_SLEEP                       19
           1861                         ;#define DPA_API_AFTER_SLEEP                 20
           1862                         ;#define DPA_API_RANDOM                      21
           1863                         ;#if !defined( TR7xD )
           1864                         ;#define DPA_API_MENU                        22
           1865                         ;#define DPA_API_MENU_INDICATE_RESULT        23
           1866                         ;#define DPA_API_MENU_EXECUTE                24
           1867                         ;#define DPA_API_DEEP_SLEEP                  25
           1868                         ;#endif
           1869                         ;
           1870                         ;// Used buffer size symbols
           1871                         ;#define sizeofBufferRF                      sizeof( bufferRF )
           1872                         ;#define sizeofBufferAUX                     sizeof( bufferAUX )
           1873                         ;#define sizeofBufferCOM                     sizeof( bufferCOM )
           1874                         ;#define sizeofBufferINFO                    sizeof( bufferINFO )
           1875                         ;
           1876                         ;// Converts conventional address to the linear one at PIC16LF1938
           1877                         ;// Note: This is workaround of CC5X preprocessor bug "No '#endif' detected"
           1878                         ;#define error_ #error Address cannot be linearized
           1879                         ;#define LINEARIZE_ADDRESS( a ) \
           1880                         ;#if ( ((uns16)(a)) - ( ((uns16)(a)) / 0x80 ) * 0x80 ) >= 0x20 && ( ((uns16)(a)) - ( ((uns16)(a)) / 0x80 ) * 0x80 ) <= 0x6F && ( ((uns16)(a)) / 0x80 ) <= 12 \
           1881                         ;( ( ( ((uns16)(a)) / 0x80 ) * 0x50 ) + ( ((uns16)(a)) - 0x20 - ( ((uns16)(a)) / 0x80 ) * 0x80 ) + 0x2000 ) \
           1882                         ;#else \
           1883                         ;error_ \
           1884                         ;#endif
           1885                         ;#undef error_
           1886                         ;
           1887                         ;#define STRUCTATTR
           1888                         ;
           1889                         ;#else //__CC5X__
           1890                         ;// Not compiled at CC5X
           1891                         ;
           1892                         ;#if !defined( CC5XnotDPA )
           1893                         ;// Define CC5X types
           1894                         ;typedef int8_t    int8;
           1895                         ;typedef int16_t   int16;
           1896                         ;typedef uint8_t   uns8;
           1897                         ;typedef uint16_t  uns16;
           1898                         ;// Disables alignment of members of structures
           1899                         ;#define STRUCTATTR  __attribute__((packed))
           1900                         ;#else
           1901                         ;#define STRUCTATTR
           1902                         ;#endif
           1903                         ;
           1904                         ;// Fake buffer sizes
           1905                         ;#define sizeofBufferRF    64
           1906                         ;#define sizeofBufferAUX   64
           1907                         ;#define sizeofBufferCOM   64
           1908                         ;#define sizeofBufferINFO  64
           1909                         ;
           1910                         ;#endif  // __CC5X__
           1911                         ;
           1912                         ;// Indexes of configuration bytes used by DpaApiReadConfigByte( index )
           1913                         ;// Checksum
           1914                         ;#define CFGIND_CHECKSUM         0x00
           1915                         ;// Embedded peripherals
           1916                         ;#define CFGIND_DPA_PERIPHERALS  0x01
           1917                         ;// DPA configuration flags #0
           1918                         ;#define CFGIND_DPA_FLAGS0       0x05
           1919                         ;// Main RF channel, used by the subordinate network
           1920                         ;#define CFGIND_CHANNEL_2ND_A    0x06
           1921                         ;// Second RF channel, used by the subordinate network
           1922                         ;#define CFGIND_CHANNEL_2ND_B    0x07
           1923                         ;// TX power
           1924                         ;#define CFGIND_TXPOWER          0x08
           1925                         ;// RX filter used by checkRF()
           1926                         ;#define CFGIND_RXFILTER         0x09
           1927                         ;// toutRF for LP mode
           1928                         ;#define CFGIND_DPA_LP_TOUTRF    0x0A
           1929                         ;// UART interface baud rate
           1930                         ;#define CFGIND_DPA_UART_IFACE_SPEED 0x0B
           1931                         ;// Alternate DSM channel
           1932                         ;#define CFGIND_ALTERNATE_DSM_CHANNEL 0x0C
           1933                         ;// DPA configuration flags #1
           1934                         ;#define CFGIND_DPA_FLAGS1       0x0D
           1935                         ;// Main RF channel
           1936                         ;#define CFGIND_CHANNEL_A        0x11
           1937                         ;// Second RF channel
           1938                         ;#define CFGIND_CHANNEL_B        0x12
           1939                         ;
           1940                         ;// 0: checks only mandatory precondition in order to prevent critical side-effects
           1941                         ;// 1: as above plus checks meaningful parameter conditions
           1942                         ;// 2: full implemented parameter checking (default)
           1943                         ;#ifndef PARAM_CHECK_LEVEL
           1944                         ;#define PARAM_CHECK_LEVEL 2
           1945                         ;#endif
           1946                         ;
           1947                         ;// "foursome" at IFace structure
           1948                         ;typedef struct
           1949                         ;{
           1950                         ;  // Node address low byte
           1951                         ;  uns8  NADRlow;
           1952                         ;  // Node address high byte
           1953                         ;  uns8  NADRhigh;
           1954                         ;  // Peripheral number
           1955                         ;  uns8  PNUM;
           1956                         ;  // Peripheral command
           1957                         ;  uns8  PCMD;
           1958                         ;  // HWPID
           1959                         ;  uns16 HWPID;
           1960                         ;} STRUCTATTR TDpaIFaceHeader;
           1961                         ;
           1962                         ;// Maximum command PCMD value (except reserved 0x3F = CMD_GET_PER_INFO)
           1963                         ;#define PCMD_MAX                    0x7f
           1964                         ;// Bit mask at PCMD that indicates DPA Response message
           1965                         ;#define RESPONSE_FLAG               0x80
           1966                         ;
           1967                         ;// IQMESH coordinator address
           1968                         ;#define COORDINATOR_ADDRESS         0x00
           1969                         ;// IQMESH broadcast address
           1970                         ;#define BROADCAST_ADDRESS           0xff
           1971                         ;// IQMESH temporary address, assigned by pre-bonding before authorization is done
           1972                         ;#define TEMPORARY_ADDRESS           0xfe
           1973                         ;// Address of the local device addressed by IFace
           1974                         ;#define LOCAL_ADDRESS               0xfc
           1975                         ;// Maximum IQMESH network device address
           1976                         ;#define MAX_ADDRESS                 ( 240 - 1 )
           1977                         ;
           1978                         ;// Time slots lengths in 10 ms
           1979                         ;#define MIN_STD_TIMESLOT    4
           1980                         ;#define MAX_STD_TIMESLOT    6
           1981                         ;
           1982                         ;#define MIN_LP_TIMESLOT     8
           1983                         ;#define MAX_LP_TIMESLOT     10
           1984                         ;
           1985                         ;// Maximum number of DPA PData bytes ( minus 8 = 6B foursome + 8b error code + 8b DpaValue )
           1986                         ;#define DPA_MAX_DATA_LENGTH         ( sizeofBufferCOM - sizeof( TDpaIFaceHeader ) - 2 * sizeof( uns8 ) )
           1987                         ;
           1988                         ;// Maximum number of peripherals info that can fit in the message
           1989                         ;#define MAX_PERIPHERALS_PER_BLOCK_INFO  ( DPA_MAX_DATA_LENGTH / sizeof( TPeripheralInfoAnswer ) )
           1990                         ;
           1991                         ;// Embedded peripheral numbers
           1992                         ;#define PNUM_COORDINATOR    0x00
           1993                         ;#define PNUM_NODE           0x01
           1994                         ;#define PNUM_OS             0x02
           1995                         ;#define PNUM_EEPROM         0x03
           1996                         ;#define PNUM_EEEPROM        0x04
           1997                         ;#define PNUM_RAM            0x05
           1998                         ;#define PNUM_LEDR           0x06
           1999                         ;#define PNUM_LEDG           0x07
           2000                         ;#define PNUM_IO             0x09
           2001                         ;#define PNUM_THERMOMETER    0x0A
           2002                         ;#define PNUM_UART           0x0C
           2003                         ;#define PNUM_FRC            0x0D
           2004                         ;
           2005                         ;// Number of the 1st user peripheral
           2006                         ;#define PNUM_USER           0x20
           2007                         ;// Number of the last user peripheral
           2008                         ;#define PNUM_USER_MAX       0x3E
           2009                         ;// Maximum peripheral number
           2010                         ;#define PNUM_MAX            0x7F
           2011                         ;
           2012                         ;// Fake peripheral number used to flag DPA response with error sent by RF
           2013                         ;#define PNUM_ERROR_FLAG     0xFE
           2014                         ;// Special peripheral used for enumeration
           2015                         ;#define PNUM_ENUMERATION    0xFF
           2016                         ;
           2017                         ;// DPA Commands for embedded peripherals
           2018                         ;#define CMD_COORDINATOR_ADDR_INFO  0
           2019                         ;#define CMD_COORDINATOR_DISCOVERED_DEVICES 1
           2020                         ;#define CMD_COORDINATOR_BONDED_DEVICES 2
           2021                         ;#define CMD_COORDINATOR_CLEAR_ALL_BONDS 3
           2022                         ;#define CMD_COORDINATOR_BOND_NODE 4
           2023                         ;#define CMD_COORDINATOR_REMOVE_BOND 5
           2024                         ;#define CMD_COORDINATOR_DISCOVERY 7
           2025                         ;#define CMD_COORDINATOR_SET_DPAPARAMS 8
           2026                         ;#define CMD_COORDINATOR_SET_HOPS 9
           2027                         ;#define CMD_COORDINATOR_BACKUP 11
           2028                         ;#define CMD_COORDINATOR_RESTORE 12
           2029                         ;#define CMD_COORDINATOR_AUTHORIZE_BOND 13
           2030                         ;#define CMD_COORDINATOR_BRIDGE 14
           2031                         ;#define CMD_COORDINATOR_SMART_CONNECT 18
           2032                         ;#define CMD_COORDINATOR_SET_MID 19
           2033                         ;
           2034                         ;#define CMD_NODE_READ 0
           2035                         ;#define CMD_NODE_REMOVE_BOND 1
           2036                         ;#define CMD_NODE_BACKUP 6
           2037                         ;#define CMD_NODE_RESTORE 7
           2038                         ;#define CMD_NODE_VALIDATE_BONDS 8
           2039                         ;
           2040                         ;#define CMD_OS_READ 0
           2041                         ;#define CMD_OS_RESET 1
           2042                         ;#define CMD_OS_READ_CFG 2
           2043                         ;#define CMD_OS_RFPGM 3
           2044                         ;#define CMD_OS_SLEEP 4
           2045                         ;#define CMD_OS_BATCH 5
           2046                         ;#define CMD_OS_SET_SECURITY 6
           2047                         ;#define CMD_OS_INDICATE 7
           2048                         ;#define CMD_OS_RESTART 8
           2049                         ;#define CMD_OS_WRITE_CFG_BYTE 9
           2050                         ;#define CMD_OS_LOAD_CODE 10
           2051                         ;#define CMD_OS_SELECTIVE_BATCH 11
           2052                         ;#define CMD_OS_TEST_RF_SIGNAL 12
           2053                         ;#define CMD_OS_FACTORY_SETTINGS 13
           2054                         ;#define CMD_OS_WRITE_CFG 15
           2055                         ;
           2056                         ;#define CMD_RAM_READ 0
           2057                         ;#define CMD_RAM_WRITE 1
           2058                         ;#define CMD_RAM_READ_ANY    15
           2059                         ;
           2060                         ;#define CMD_EEPROM_READ CMD_RAM_READ
           2061                         ;#define CMD_EEPROM_WRITE CMD_RAM_WRITE
           2062                         ;
           2063                         ;#define CMD_EEEPROM_XREAD ( CMD_RAM_READ + 2 )
           2064                         ;#define CMD_EEEPROM_XWRITE ( CMD_RAM_WRITE + 2 )
           2065                         ;
           2066                         ;#define CMD_LED_SET_OFF 0
           2067                         ;#define CMD_LED_SET_ON 1
           2068                         ;#define CMD_LED_PULSE 3
           2069                         ;#define CMD_LED_FLASHING 4
           2070                         ;
           2071                         ;#define CMD_IO_DIRECTION  0
           2072                         ;#define CMD_IO_SET  1
           2073                         ;#define CMD_IO_GET  2
           2074                         ;
           2075                         ;#define CMD_THERMOMETER_READ 0
           2076                         ;
           2077                         ;#define CMD_UART_OPEN 0
           2078                         ;#define CMD_UART_CLOSE 1
           2079                         ;#define CMD_UART_WRITE_READ 2
           2080                         ;#define CMD_UART_CLEAR_WRITE_READ 3
           2081                         ;
           2082                         ;#define CMD_FRC_SEND 0
           2083                         ;#define CMD_FRC_EXTRARESULT 1
           2084                         ;#define CMD_FRC_SEND_SELECTIVE 2
           2085                         ;#define CMD_FRC_SET_PARAMS 3
           2086                         ;
           2087                         ;#define CMD_GET_PER_INFO  0x3f
           2088                         ;
           2089                         ;// DPA peripheral type
           2090                         ;typedef enum
           2091                         ;{
           2092                         ;  PERIPHERAL_TYPE_DUMMY = 0x00,
           2093                         ;  PERIPHERAL_TYPE_COORDINATOR = 0x01,
           2094                         ;  PERIPHERAL_TYPE_NODE = 0x02,
           2095                         ;  PERIPHERAL_TYPE_OS = 0x03,
           2096                         ;  PERIPHERAL_TYPE_EEPROM = 0x04,
           2097                         ;  PERIPHERAL_TYPE_BLOCK_EEPROM = 0x05,
           2098                         ;  PERIPHERAL_TYPE_RAM = 0x06,
           2099                         ;  PERIPHERAL_TYPE_LED = 0x07,
           2100                         ;  PERIPHERAL_TYPE_SPI = 0x08,
           2101                         ;  PERIPHERAL_TYPE_IO = 0x09,
           2102                         ;  PERIPHERAL_TYPE_UART = 0x0a,
           2103                         ;  PERIPHERAL_TYPE_THERMOMETER = 0x0b,
           2104                         ;  PERIPHERAL_TYPE_ADC = 0x0c,
           2105                         ;  PERIPHERAL_TYPE_PWM = 0x0d,
           2106                         ;  PERIPHERAL_TYPE_FRC = 0x0e,
           2107                         ;  // Starts peripheral type number interval for user peripherals
           2108                         ;  PERIPHERAL_TYPE_USER_AREA = 0x80
           2109                         ;} TDpaPeripheralType;
           2110                         ;
           2111                         ;// Peripheral extended information
           2112                         ;typedef enum
           2113                         ;{
           2114                         ;  PERIPHERAL_TYPE_EXTENDED_DEFAULT = 0x00,
           2115                         ;  PERIPHERAL_TYPE_EXTENDED_READ = 0x01,
           2116                         ;  PERIPHERAL_TYPE_EXTENDED_WRITE = 0x02,
           2117                         ;  PERIPHERAL_TYPE_EXTENDED_READ_WRITE = PERIPHERAL_TYPE_EXTENDED_READ | PERIPHERAL_TYPE_EXTENDED_WRITE
           2118                         ;} TDpaPeripheralTypeExtended;
           2119                         ;
           2120                         ;// Response packet error codes
           2121                         ;typedef enum
           2122                         ;{
           2123                         ;  // No error
           2124                         ;  STATUS_NO_ERROR = 0,
           2125                         ;
           2126                         ;  // General fail
           2127                         ;  ERROR_FAIL = 1,
           2128                         ;  // Incorrect PCMD
           2129                         ;  ERROR_PCMD = 2,
           2130                         ;  // Incorrect PNUM or PCMD
           2131                         ;  ERROR_PNUM = 3,
           2132                         ;  // Incorrect Address value when addressing memory type peripherals
           2133                         ;  ERROR_ADDR = 4,
           2134                         ;  // Incorrect Data length
           2135                         ;  ERROR_DATA_LEN = 5,
           2136                         ;  // Incorrect Data
           2137                         ;  ERROR_DATA = 6,
           2138                         ;  // Incorrect HWPID used
           2139                         ;  ERROR_HWPID = 7,
           2140                         ;  // Incorrect NADR
           2141                         ;  ERROR_NADR = 8,
           2142                         ;  // IFACE data consumed by Custom DPA Handler
           2143                         ;  ERROR_IFACE_CUSTOM_HANDLER = 9,
           2144                         ;  // Custom DPA Handler is missing
           2145                         ;  ERROR_MISSING_CUSTOM_DPA_HANDLER = 10,
           2146                         ;
           2147                         ;  // Beginning of the user code error interval
           2148                         ;  ERROR_USER_FROM = 0x20,
           2149                         ;  // End of the user code error interval
           2150                         ;  ERROR_USER_TO = 0x3f,
           2151                         ;
           2152                         ;  // Bit/flag reserved for a future use
           2153                         ;  STATUS_RESERVED_FLAG = 0x40,
           2154                         ;  // Bit to flag asynchronous DPA Response from [N]
           2155                         ;  STATUS_ASYNC_RESPONSE = 0x80,
           2156                         ;  // Error code used to mark DPA Confirmation
           2157                         ;  STATUS_CONFIRMATION = 0xff
           2158                         ;} TErrorCodes;
           2159                         ;
           2160                         ;// Embedded FRC commands
           2161                         ;typedef enum
           2162                         ;{
           2163                         ;  // 2 bits
           2164                         ;  FRC_Ping = 0x00,
           2165                         ;  FRC_AcknowledgedBroadcastBits = 0x02,
           2166                         ;  FRC_PrebondedAlive = 0x03,
           2167                         ;  FRC_SupplyVoltage = 0x04,
           2168                         ;  FRC_PrebondedMemoryCompare2B = 0x05,
           2169                         ;  // 1 byte
           2170                         ;  FRC_Temperature = 0x80,
           2171                         ;  FRC_AcknowledgedBroadcastBytes = 0x81,
           2172                         ;  FRC_MemoryRead = 0x82,
           2173                         ;  FRC_MemoryReadPlus1 = 0x83,
           2174                         ;  FRC_FrcResponseTime = 0x84,
           2175                         ;  FRC_TestRFsignal = 0x85,
           2176                         ;  // 4 bytes
           2177                         ;  FRC_PrebondedMemoryRead4BPlus1 = 0xF8,
           2178                         ;  FRC_MemoryRead4B = 0xFA
           2179                         ;} TFRCommands;
           2180                         ;
           2181                         ;// Intervals of user FRC codes
           2182                         ;#define FRC_USER_BIT_FROM     0x40
           2183                         ;#define FRC_USER_BIT_TO       0x7F
           2184                         ;#define FRC_USER_BYTE_FROM    0xC0
           2185                         ;#define FRC_USER_BYTE_TO      0xDF
           2186                         ;#define FRC_USER_2BYTE_FROM   0xF0
           2187                         ;#define FRC_USER_2BYTE_TO     0xF7
           2188                         ;#define FRC_USER_4BYTE_FROM   0xFC
           2189                         ;#define FRC_USER_4BYTE_TO     0xFF
           2190                         ;
           2191                         ;// No HWPID specified
           2192                         ;#define HWPID_Default         0x0000
           2193                         ;// Use this type to override HWPID check
           2194                         ;#define HWPID_DoNotCheck      0xFfFf
           2195                         ;
           2196                         ;// RAM peripheral block definitions
           2197                         ;#ifdef TR7xD
           2198                         ;#define PERIPHERAL_RAM_LENGTH 48
           2199                         ;#else
           2200                         ;#define PERIPHERAL_RAM_LENGTH 80
           2201                         ;#endif
           2202                         ;
           2203                         ;// Start address of EEPROM peripheral in the real EEPROM
           2204                         ;#ifndef COORDINATOR_CUSTOM_HANDLER // Node
           2205                         ;#define PERIPHERAL_EEPROM_START     ( (uns8)0x00 )
           2206                         ;#else // Coordinator
           2207                         ;#define PERIPHERAL_EEPROM_START     ( (uns8)0x80 )
           2208                         ;#endif
           2209                         ;
           2210                         ;// Length of the internal EEPROM peripheral array
           2211                         ;#define PERIPHERAL_EEPROM_LENGTH            ( (uns8)( 0xC0 - PERIPHERAL_EEPROM_START ) )
           2212                         ;
           2213                         ;// Length of the readable area of serial EEEPROM from the EEEPROM DPA peripheral write point of view.
           2214                         ;#define EEEPROM_READ_LENGTH                 0x8000
           2215                         ;// Length of the writable area of serial EEEPROM from the EEEPROM DPA peripheral write point of view.
           2216                         ;#define EEEPROM_WRITE_LENGTH                0x4000
           2217                         ;
           2218                         ;// Starting address of the IO Setup DPA storage at external EEPROM
           2219                         ;#define IOSETUP_EEEPROM_ADDR                ( 0x0000 + sizeofBufferAUX )
           2220                         ;// Length of the IO setup memory block
           2221                         ;#define IOSETUP_LENGTH                      sizeofBufferAUX
           2222                         ;
           2223                         ;#if !defined( TR7xD )
           2224                         ;// Parameter at [_]DpaApi[Deep]Sleep() for not using Watchdog timer wakeup
           2225                         ;#define DpaApiSleep_WdtOff                  0b00000.0
           2226                         ;#endif
           2227                         ;
           2228                         ;// ---------------------------------------------------------
           2229                         ;
           2230                         ;// Enumerate peripherals structure
           2231                         ;typedef struct
           2232                         ;{
           2233                         ;  uns16 DpaVersion;
           2234                         ;  uns8  UserPerNr;
           2235                         ;  uns8  EmbeddedPers[PNUM_USER / 8];
           2236                         ;  uns16 HWPID;
           2237                         ;  uns16 HWPIDver;
           2238                         ;  uns8  Flags;
           2239                         ;  uns8  UserPer[( PNUM_MAX - PNUM_USER + 1 + 7 ) / 8];
           2240                         ;} STRUCTATTR TEnumPeripheralsAnswer;
           2241                         ;
           2242                         ;#define FlagUserPer(UserPersArray,UserPerNumber)    UserPersArray[((UserPerNumber)-PNUM_USER) / 8] |= (uns8)0x01 << (((UserPerNumber)-PNUM_USER) % 8);
           2243                         ;
           2244                         ;// Get peripheral info structure (CMD_GET_PER_INFO)
           2245                         ;typedef struct
           2246                         ;{
           2247                         ;  uns8  PerTE;
           2248                         ;  uns8  PerT;
           2249                         ;  uns8  Par1;
           2250                         ;  uns8  Par2;
           2251                         ;} STRUCTATTR TPeripheralInfoAnswer;
           2252                         ;
           2253                         ;// Error DPA response (PNUM_ERROR_FLAG)
           2254                         ;typedef struct
           2255                         ;{
           2256                         ;  uns8  ErrN;
           2257                         ;  uns8  PNUMoriginal;
           2258                         ;} STRUCTATTR TErrorAnswer;
           2259                         ;
           2260                         ;// Structure returned by CMD_COORDINATOR_ADDR_INFO
           2261                         ;typedef struct
           2262                         ;{
           2263                         ;  uns8  DevNr;
           2264                         ;  uns8  DID;
           2265                         ;} STRUCTATTR TPerCoordinatorAddrInfo_Response;
           2266                         ;
           2267                         ;// Structure for CMD_COORDINATOR_BOND_NODE
           2268                         ;typedef struct
           2269                         ;{
           2270                         ;  uns8  ReqAddr;
           2271                         ;  uns8  BondingTestRetries;
           2272                         ;} STRUCTATTR TPerCoordinatorBondNode_Request;
           2273                         ;
           2274                         ;// Structure returned by CMD_COORDINATOR_BOND_NODE or CMD_COORDINATOR_SMART_CONNECT
           2275                         ;typedef struct
           2276                         ;{
           2277                         ;  uns8  BondAddr;
           2278                         ;  uns8  DevNr;
           2279                         ;} STRUCTATTR TPerCoordinatorBondNodeSmartConnect_Response;
           2280                         ;
           2281                         ;// Structure for CMD_COORDINATOR_REMOVE_BOND
           2282                         ;typedef struct
           2283                         ;{
           2284                         ;  uns8  BondAddr;
           2285                         ;} STRUCTATTR TPerCoordinatorRemoveBond_Request;
           2286                         ;
           2287                         ;// Structure returned by CMD_COORDINATOR_REMOVE_BOND
           2288                         ;typedef struct
           2289                         ;{
           2290                         ;  uns8  DevNr;
           2291                         ;} STRUCTATTR TPerCoordinatorRemoveBond_Response;
           2292                         ;
           2293                         ;// Structure for CMD_COORDINATOR_DISCOVERY
           2294                         ;typedef struct
           2295                         ;{
           2296                         ;  uns8  TxPower;
           2297                         ;  uns8  MaxAddr;
           2298                         ;} STRUCTATTR TPerCoordinatorDiscovery_Request;
           2299                         ;
           2300                         ;// Structure returned by CMD_COORDINATOR_DISCOVERY
           2301                         ;typedef struct
           2302                         ;{
           2303                         ;  uns8  DiscNr;
           2304                         ;} STRUCTATTR TPerCoordinatorDiscovery_Response;
           2305                         ;
           2306                         ;// Structure for and also returned by CMD_COORDINATOR_SET_DPAPARAMS
           2307                         ;typedef struct
           2308                         ;{
           2309                         ;  uns8  DpaParam;
           2310                         ;} STRUCTATTR TPerCoordinatorSetDpaParams_Request_Response;
           2311                         ;
           2312                         ;// Structure for and also returned by CMD_COORDINATOR_SET_HOPS
           2313                         ;typedef struct
           2314                         ;{
           2315                         ;  uns8  RequestHops;
           2316                         ;  uns8  ResponseHops;
           2317                         ;} STRUCTATTR TPerCoordinatorSetHops_Request_Response;
           2318                         ;
           2319                         ;// Structure for CMD_COORDINATOR_BACKUP and CMD_NODE_BACKUP
           2320                         ;typedef struct
           2321                         ;{
           2322                         ;  uns8  Index;
           2323                         ;} STRUCTATTR TPerCoordinatorNodeBackup_Request;
           2324                         ;
           2325                         ;// Structure returned by CMD_COORDINATOR_BACKUP and CMD_NODE_BACKUP
           2326                         ;typedef struct
           2327                         ;{
           2328                         ;  uns8  NetworkData[49];
           2329                         ;} STRUCTATTR TPerCoordinatorNodeBackup_Response;
           2330                         ;
           2331                         ;// Structure for CMD_COORDINATOR_RESTORE and CMD_NODE_RESTORE
           2332                         ;typedef struct
           2333                         ;{
           2334                         ;  uns8  NetworkData[49];
           2335                         ;} STRUCTATTR TPerCoordinatorNodeRestore_Request;
           2336                         ;
           2337                         ;// Structure for CMD_COORDINATOR_AUTHORIZE_BOND
           2338                         ;typedef struct
           2339                         ;{
           2340                         ;  uns8  ReqAddr;
           2341                         ;  uns8  MID[4];
           2342                         ;} STRUCTATTR TPerCoordinatorAuthorizeBond_Request;
           2343                         ;
           2344                         ;// Structure returned by CMD_COORDINATOR_AUTHORIZE_BOND
           2345                         ;typedef struct
           2346                         ;{
           2347                         ;  uns8  BondAddr;
           2348                         ;  uns8  DevNr;
           2349                         ;} STRUCTATTR TPerCoordinatorAuthorizeBond_Response;
           2350                         ;
           2351                         ;// Structure for CMD_COORDINATOR_BRIDGE
           2352                         ;typedef struct
           2353                         ;{
           2354                         ;  TDpaIFaceHeader subHeader;
           2355                         ;  uns8  subPData[DPA_MAX_DATA_LENGTH - sizeof( TDpaIFaceHeader )];
           2356                         ;} STRUCTATTR TPerCoordinatorBridge_Request;
           2357                         ;
           2358                         ;// Structure returned by CMD_COORDINATOR_BRIDGE
           2359                         ;typedef struct
           2360                         ;{
           2361                         ;  TDpaIFaceHeader subHeader;
           2362                         ;  uns8  subRespCode;
           2363                         ;  uns8  subDpaValue;
           2364                         ;  uns8  subPData[DPA_MAX_DATA_LENGTH - sizeof( TDpaIFaceHeader ) - 2 * sizeof( uns8 )];
           2365                         ;} STRUCTATTR TPerCoordinatorBridge_Response;
           2366                         ;
           2367                         ;// Structure for CMD_COORDINATOR_SMART_CONNECT
           2368                         ;typedef struct
           2369                         ;{
           2370                         ;  uns8  ReqAddr;
           2371                         ;  uns8  BondingTestRetries;
           2372                         ;  uns8  IBK[16];
           2373                         ;  uns8  MID[4];
           2374                         ;  uns8  reserved0;
           2375                         ;  uns8  VirtualDeviceAddress;
           2376                         ;  uns8  UserData[4];
           2377                         ;  uns8  reserved1[10];
           2378                         ;} STRUCTATTR TPerCoordinatorSmartConnect_Request;
           2379                         ;
           2380                         ;// Structure for CMD_COORDINATOR_SET_MID
           2381                         ;typedef struct
           2382                         ;{
           2383                         ;  uns8  MID[4];
           2384                         ;  uns8  BondAddr;
           2385                         ;} STRUCTATTR TPerCoordinatorSetMID_Request;
           2386                         ;
           2387                         ;// Structure returned by CMD_NODE_READ
           2388                         ;typedef struct
           2389                         ;{
           2390                         ;  uns8  ntwADDR;
           2391                         ;  uns8  ntwVRN;
           2392                         ;  uns8  ntwZIN;
           2393                         ;  uns8  ntwDID;
           2394                         ;  uns8  ntwPVRN;
           2395                         ;  uns16 ntwUSERADDRESS;
           2396                         ;  uns16 ntwID;
           2397                         ;  uns8  ntwVRNFNZ;
           2398                         ;  uns8  ntwCFG;
           2399                         ;  uns8  Flags;
           2400                         ;} STRUCTATTR TPerNodeRead_Response;
           2401                         ;
           2402                         ;// Structures for CMD_NODE_VALIDATE_BONDS
           2403                         ;typedef struct
           2404                         ;{
           2405                         ;  uns8  Address;
           2406                         ;  uns8  MID[4];
           2407                         ;} STRUCTATTR TPerNodeValidateBondsItem;
           2408                         ;
           2409                         ;// Structure for CMD_NODE_VALIDATE_BONDS
           2410                         ;typedef struct
           2411                         ;{
           2412                         ;  TPerNodeValidateBondsItem Bonds[DPA_MAX_DATA_LENGTH / sizeof( TPerNodeValidateBondsItem )];
           2413                         ;} STRUCTATTR TPerNodeValidateBonds_Request;
           2414                         ;
           2415                         ;// Structure returned by CMD_OS_READ
           2416                         ;typedef struct
           2417                         ;{
           2418                         ;  uns8  MID[4];
           2419                         ;  uns8  OsVersion;
           2420                         ;  uns8  TrType;
           2421                         ;  uns16 OsBuild;
           2422                         ;  uns8  Rssi;
           2423                         ;  uns8  SupplyVoltage;
           2424                         ;  uns8  Flags;
           2425                         ;  uns8  SlotLimits;
           2426                         ;  uns8  IBK[16];
           2427                         ;  // Enumerate peripherals part, variable length because of UserPer field
           2428                         ;  uns16 DpaVersion;
           2429                         ;  uns8  UserPerNr;
           2430                         ;  uns8  EmbeddedPers[PNUM_USER / 8];
           2431                         ;  uns16 HWPID;
           2432                         ;  uns16 HWPIDver;
           2433                         ;  uns8  FlagsEnum;
           2434                         ;  uns8  UserPer[( PNUM_MAX - PNUM_USER + 1 + 7 ) / 8];
           2435                         ;} STRUCTATTR TPerOSRead_Response;
           2436                         ;
           2437                         ;// Structure returned by CMD_OS_READ_CFG
           2438                         ;typedef struct
           2439                         ;{
           2440                         ;  uns8  Checksum;
           2441                         ;  uns8  Configuration[31];
           2442                         ;  uns8  RFPGM;
           2443                         ;  uns8  Undocumented[1];
           2444                         ;} STRUCTATTR TPerOSReadCfg_Response;
           2445                         ;
           2446                         ;// Structure for CMD_OS_WRITE_CFG
           2447                         ;typedef struct
           2448                         ;{
           2449                         ;  uns8  Undefined;
           2450                         ;  uns8  Configuration[31];
           2451                         ;  uns8  RFPGM;
           2452                         ;} STRUCTATTR TPerOSWriteCfg_Request;
           2453                         ;
           2454                         ;// Structures for CMD_OS_WRITE_CFG_BYTE
           2455                         ;typedef struct
           2456                         ;{
           2457                         ;  uns8  Address;
           2458                         ;  uns8  Value;
           2459                         ;  uns8  Mask;
           2460                         ;} STRUCTATTR TPerOSWriteCfgByteTriplet;
           2461                         ;
           2462                         ;// Structure for CMD_OS_WRITE_CFG_BYTE
           2463                         ;typedef struct
           2464                         ;{
           2465                         ;  TPerOSWriteCfgByteTriplet Triplets[DPA_MAX_DATA_LENGTH / sizeof( TPerOSWriteCfgByteTriplet )];
           2466                         ;} STRUCTATTR TPerOSWriteCfgByte_Request;
           2467                         ;
           2468                         ;// Structure for CMD_OS_SET_SECURITY
           2469                         ;typedef struct
           2470                         ;{
           2471                         ;  uns8  Type;
           2472                         ;  uns8  Data[16];
           2473                         ;} STRUCTATTR TPerOSSetSecurity_Request;
           2474                         ;
           2475                         ;// Structure for CMD_OS_LOAD_CODE
           2476                         ;typedef struct
           2477                         ;{
           2478                         ;  uns8  Flags;
           2479                         ;  uns16 Address;
           2480                         ;  uns16 Length;
           2481                         ;  uns16 CheckSum;
           2482                         ;} STRUCTATTR TPerOSLoadCode_Request;
           2483                         ;
           2484                         ;// Structure for CMD_OS_SLEEP
           2485                         ;typedef struct
           2486                         ;{
           2487                         ;  uns16 Time;
           2488                         ;  uns8  Control;
           2489                         ;} STRUCTATTR TPerOSSleep_Request;
           2490                         ;
           2491                         ;// Structure for CMD_OS_SELECTIVE_BATCH
           2492                         ;typedef struct
           2493                         ;{
           2494                         ;  uns8  SelectedNodes[30];
           2495                         ;  uns8  Requests[DPA_MAX_DATA_LENGTH - 30];
           2496                         ;} STRUCTATTR TPerOSSelectiveBatch_Request;
           2497                         ;
           2498                         ;// Structure for CMD_OS_TEST_RF_SIGNAL request
           2499                         ;typedef struct
           2500                         ;{
           2501                         ;  uns8  Channel;
           2502                         ;  uns8  RXfilter;
           2503                         ;  uns16 Time;
           2504                         ;} STRUCTATTR TPerOSTestRfSignal_Request;
           2505                         ;
           2506                         ;// Structure for CMD_OS_TEST_RF_SIGNAL response
           2507                         ;typedef struct
           2508                         ;{
           2509                         ;  uns8  Counter;
           2510                         ;} STRUCTATTR TPerOSTestRfSignal_Response;
           2511                         ;
           2512                         ;// Structure for CMD_OS_INDICATE request
           2513                         ;typedef struct
           2514                         ;{
           2515                         ;  uns8  Control;
           2516                         ;} STRUCTATTR TPerOSIndicate_Request;
           2517                         ;
           2518                         ;// Structure for general memory request
           2519                         ;typedef struct
           2520                         ;{
           2521                         ;  // Address of data to write or read
           2522                         ;  uns8  Address;
           2523                         ;
           2524                         ;  union
           2525                         ;  {
           2526                         ;    // Memory read request
           2527                         ;    struct
           2528                         ;    {
           2529                         ;      // Length of data to read
           2530                         ;      uns8  Length;
           2531                         ;    } Read;
           2532                         ;
           2533                         ;    // Size of Address field
           2534                         ;#define MEMORY_WRITE_REQUEST_OVERHEAD   ( sizeof( uns8 ) )
           2535                         ;
           2536                         ;    // Memory write request
           2537                         ;    struct
           2538                         ;    {
           2539                         ;      uns8  PData[DPA_MAX_DATA_LENGTH - MEMORY_WRITE_REQUEST_OVERHEAD];
           2540                         ;    } Write;
           2541                         ;
           2542                         ;  } ReadWrite;
           2543                         ;} STRUCTATTR TPerMemoryRequest;
           2544                         ;
           2545                         ;// Structure for general extended memory request
           2546                         ;typedef struct
           2547                         ;{
           2548                         ;  // Address of data to write or read
           2549                         ;  uns16 Address;
           2550                         ;
           2551                         ;  union
           2552                         ;  {
           2553                         ;    // Memory read request
           2554                         ;    struct
           2555                         ;    {
           2556                         ;      // Length of data to read
           2557                         ;      uns8  Length;
           2558                         ;    } Read;
           2559                         ;
           2560                         ;    // Size of Address field
           2561                         ;#define XMEMORY_WRITE_REQUEST_OVERHEAD  ( sizeof( uns16 ) )
           2562                         ;
           2563                         ;    // Memory write request
           2564                         ;    struct
           2565                         ;    {
           2566                         ;      uns8  PData[DPA_MAX_DATA_LENGTH - XMEMORY_WRITE_REQUEST_OVERHEAD];
           2567                         ;    } Write;
           2568                         ;
           2569                         ;  } ReadWrite;
           2570                         ;} STRUCTATTR TPerXMemoryRequest;
           2571                         ;
           2572                         ;// Structure for CMD_IO requests
           2573                         ;typedef struct
           2574                         ;{
           2575                         ;  uns8  Port;
           2576                         ;  uns8  Mask;
           2577                         ;  uns8  Value;
           2578                         ;} STRUCTATTR TPerIOTriplet;
           2579                         ;
           2580                         ;typedef struct
           2581                         ;{
           2582                         ;  uns8  Header; // == PNUM_IO_DELAY
           2583                         ;  uns16 Delay;
           2584                         ;} STRUCTATTR TPerIODelay;
           2585                         ;
           2586                         ;// Union for CMD_IO_SET and CMD_IO_DIRECTION requests
           2587                         ;typedef union
           2588                         ;{
           2589                         ;  TPerIOTriplet Triplets[DPA_MAX_DATA_LENGTH / sizeof( TPerIOTriplet )];
           2590                         ;  TPerIODelay   Delays[DPA_MAX_DATA_LENGTH / sizeof( TPerIODelay )];
           2591                         ;} STRUCTATTR TPerIoDirectionAndSet_Request;
           2592                         ;
           2593                         ;// Structure returned by CMD_THERMOMETER_READ
           2594                         ;typedef struct
           2595                         ;{
           2596                         ;  int8  IntegerValue;
           2597                         ;  int16 SixteenthValue;
           2598                         ;} STRUCTATTR TPerThermometerRead_Response;
           2599                         ;
           2600                         ;// Structure for CMD_UART_OPEN
           2601                         ;typedef struct
           2602                         ;{
           2603                         ;  uns8  BaudRate;
           2604                         ;} STRUCTATTR TPerUartOpen_Request;
           2605                         ;
           2606                         ;// Structure for CMD_UART_[CLEAR_]WRITE_READ
           2607                         ;typedef struct
           2608                         ;{
           2609                         ;  uns8  ReadTimeout;
           2610                         ;  uns8  WrittenData[DPA_MAX_DATA_LENGTH - sizeof( uns8 )];
           2611                         ;} STRUCTATTR TPerUartWriteRead_Request;
           2612                         ;
           2613                         ;// Structure for CMD_FRC_SEND
           2614                         ;typedef struct
           2615                         ;{
           2616                         ;  uns8  FrcCommand;
           2617                         ;  uns8  UserData[30];
           2618                         ;} STRUCTATTR TPerFrcSend_Request;
           2619                         ;
           2620                         ;// Structure for CMD_FRC_SEND_SELECTIVE
           2621                         ;typedef struct
           2622                         ;{
           2623                         ;  uns8  FrcCommand;
           2624                         ;  uns8  SelectedNodes[30];
           2625                         ;  uns8  UserData[25];
           2626                         ;} STRUCTATTR TPerFrcSendSelective_Request;
           2627                         ;
           2628                         ;// Structure returned by CMD_FRC_SEND and CMD_FRC_SEND_SELECTIVE
           2629                         ;typedef struct
           2630                         ;{
           2631                         ;  uns8  Status;
           2632                         ;  uns8  FrcData[DPA_MAX_DATA_LENGTH - sizeof( uns8 )];
           2633                         ;} STRUCTATTR TPerFrcSend_Response;
           2634                         ;
           2635                         ;// Structure for request and response of CMD_FRC_SET_PARAMS
           2636                         ;typedef struct
           2637                         ;{
           2638                         ;  uns8  FrcParams;
           2639                         ;} STRUCTATTR TPerFrcSetParams_RequestResponse;
           2640                         ;
           2641                         ;// Interface and CMD_COORDINATOR_BRIDGE confirmation structure
           2642                         ;typedef struct
           2643                         ;{
           2644                         ;  // Number of hops
           2645                         ;  uns8  Hops;
           2646                         ;  // Time slot length in 10ms
           2647                         ;  uns8  TimeSlotLength;
           2648                         ;  // Number of hops for response
           2649                         ;  uns8  HopsResponse;
           2650                         ;} STRUCTATTR TIFaceConfirmation;
           2651                         ;
           2652                         ;// ---------------------------------------------------------
           2653                         ;
           2654                         ;// DPA Message data structure (packet w/o NADR, PNUM, PCMD, HWPID)
           2655                         ;typedef union
           2656                         ;{
           2657                         ;  // General DPA request
           2658                         ;  struct
           2659                         ;  {
           2660                         ;    uns8    PData[DPA_MAX_DATA_LENGTH];
           2661                         ;  } Request;
           2662                         ;
           2663                         ;  // General DPA response
           2664                         ;  struct
           2665                         ;  {
           2666                         ;    uns8    PData[DPA_MAX_DATA_LENGTH];
           2667                         ;  } Response;
           2668                         ;
           2669                         ;  // Enumerate peripherals structure
           2670                         ;  TEnumPeripheralsAnswer EnumPeripheralsAnswer;
           2671                         ;
           2672                         ;  // Get peripheral info structure (CMD_GET_PER_INFO)
           2673                         ;  TPeripheralInfoAnswer PeripheralInfoAnswer;
           2674                         ;
           2675                         ;  // Get peripheral info structure (CMD_GET_PER_INFO) for more peripherals
           2676                         ;  TPeripheralInfoAnswer PeripheralInfoAnswers[MAX_PERIPHERALS_PER_BLOCK_INFO];
           2677                         ;
           2678                         ;  // Error DPA response (PNUM_ERROR_FLAG)
           2679                         ;  TErrorAnswer ErrorAnswer;
           2680                         ;
           2681                         ;  // Structure returned by CMD_COORDINATOR_ADDR_INFO
           2682                         ;  TPerCoordinatorAddrInfo_Response PerCoordinatorAddrInfo_Response;
           2683                         ;
           2684                         ;  // Structure for CMD_COORDINATOR_BOND_NODE
           2685                         ;  TPerCoordinatorBondNode_Request PerCoordinatorBondNode_Request;
           2686                         ;
           2687                         ;  // Structure returned by CMD_COORDINATOR_BOND_NODE or CMD_COORDINATOR_SMART_CONNECT
           2688                         ;  TPerCoordinatorBondNodeSmartConnect_Response PerCoordinatorBondNodeSmartConnect_Response;
           2689                         ;
           2690                         ;  // Structure for CMD_COORDINATOR_REMOVE_BOND
           2691                         ;  TPerCoordinatorRemoveBond_Request PerCoordinatorRemoveBond_Request;
           2692                         ;
           2693                         ;  // Structure returned by CMD_COORDINATOR_REMOVE_BOND
           2694                         ;  TPerCoordinatorRemoveBond_Response PerCoordinatorRemoveBond_Response;
           2695                         ;
           2696                         ;  // Structure for CMD_COORDINATOR_DISCOVERY
           2697                         ;  TPerCoordinatorDiscovery_Request PerCoordinatorDiscovery_Request;
           2698                         ;
           2699                         ;  // Structure returned by CMD_COORDINATOR_DISCOVERY
           2700                         ;  TPerCoordinatorDiscovery_Response PerCoordinatorDiscovery_Response;
           2701                         ;
           2702                         ;  // Structure for and also returned by CMD_COORDINATOR_SET_DPAPARAMS
           2703                         ;  TPerCoordinatorSetDpaParams_Request_Response PerCoordinatorSetDpaParams_Request_Response;
           2704                         ;
           2705                         ;  // Structure for and also returned by CMD_COORDINATOR_SET_HOPS
           2706                         ;  TPerCoordinatorSetHops_Request_Response PerCoordinatorSetHops_Request_Response;
           2707                         ;
           2708                         ;  // Structure for CMD_COORDINATOR_BACKUP and CMD_NODE_BACKUP
           2709                         ;  TPerCoordinatorNodeBackup_Request PerCoordinatorNodeBackup_Request;
           2710                         ;
           2711                         ;  // Structure returned by CMD_COORDINATOR_BACKUP and CMD_NODE_BACKUP
           2712                         ;  TPerCoordinatorNodeBackup_Response PerCoordinatorNodeBackup_Response;
           2713                         ;
           2714                         ;  // Structure for CMD_COORDINATOR_RESTORE and CMD_NODE_RESTORE
           2715                         ;  TPerCoordinatorNodeRestore_Request PerCoordinatorNodeRestore_Request;
           2716                         ;
           2717                         ;  // Structure for CMD_COORDINATOR_AUTHORIZE_BOND
           2718                         ;  TPerCoordinatorAuthorizeBond_Request PerCoordinatorAuthorizeBond_Request;
           2719                         ;
           2720                         ;  // Structure returned by CMD_COORDINATOR_AUTHORIZE_BOND
           2721                         ;  TPerCoordinatorAuthorizeBond_Response PerCoordinatorAuthorizeBond_Response;
           2722                         ;
           2723                         ;  // Structure for CMD_COORDINATOR_BRIDGE
           2724                         ;  TPerCoordinatorBridge_Request PerCoordinatorBridge_Request;
           2725                         ;
           2726                         ;  // Structure returned by CMD_COORDINATOR_BRIDGE
           2727                         ;  TPerCoordinatorBridge_Response PerCoordinatorBridge_Response;
           2728                         ;
           2729                         ;  // Structure for CMD_COORDINATOR_SMART_CONNECT
           2730                         ;  TPerCoordinatorSmartConnect_Request PerCoordinatorSmartConnect_Request;
           2731                         ;
           2732                         ;  // Structure for CMD_COORDINATOR_SET_MID
           2733                         ;  TPerCoordinatorSetMID_Request PerCoordinatorSetMID_Request;
           2734                         ;
           2735                         ;  // Structure returned by CMD_NODE_READ
           2736                         ;  TPerNodeRead_Response PerNodeRead_Response;
           2737                         ;
           2738                         ;  // Structure for CMD_NODE_VALIDATE_BONDS
           2739                         ;  TPerNodeValidateBonds_Request PerNodeValidateBonds_Request;
           2740                         ;
           2741                         ;  // Structure returned by CMD_OS_READ
           2742                         ;  TPerOSRead_Response PerOSRead_Response;
           2743                         ;
           2744                         ;  // Structure returned by CMD_OS_READ_CFG
           2745                         ;  TPerOSReadCfg_Response PerOSReadCfg_Response;
           2746                         ;
           2747                         ;  // Structure for CMD_OS_WRITE_CFG
           2748                         ;  TPerOSWriteCfg_Request PerOSWriteCfg_Request;
           2749                         ;
           2750                         ;  // Structure for CMD_OS_WRITE_CFG_BYTE
           2751                         ;  TPerOSWriteCfgByte_Request PerOSWriteCfgByte_Request;
           2752                         ;
           2753                         ;  // Structure for CMD_OS_SET_SECURITY
           2754                         ;  TPerOSSetSecurity_Request PerOSSetSecurity_Request;
           2755                         ;
           2756                         ;  // Structure for CMD_OS_LOAD_CODE
           2757                         ;  TPerOSLoadCode_Request PerOSLoadCode_Request;
           2758                         ;
           2759                         ;  // Structure for CMD_OS_SLEEP
           2760                         ;  TPerOSSleep_Request PerOSSleep_Request;
           2761                         ;
           2762                         ;  // Structure for CMD_OS_SELECTIVE_BATCH
           2763                         ;  TPerOSSelectiveBatch_Request PerOSSelectiveBatch_Request;
           2764                         ;
           2765                         ;  // Structure for CMD_OS_TEST_RF_SIGNAL request
           2766                         ;  TPerOSTestRfSignal_Request PerOSTestRfSignal_Request;
           2767                         ;
           2768                         ;  // Structure for CMD_OS_INDICATE request
           2769                         ;  TPerOSIndicate_Request PerOSIndicate_Request;
           2770                         ;
           2771                         ;  // Structure for CMD_OS_TEST_RF_SIGNAL response
           2772                         ;  TPerOSTestRfSignal_Response PerOSTestRfSignal_Response;
           2773                         ;
           2774                         ;  // Structure for general memory request
           2775                         ;  TPerMemoryRequest MemoryRequest;
           2776                         ;
           2777                         ;  // Structure for general extended memory request
           2778                         ;  TPerXMemoryRequest XMemoryRequest;
           2779                         ;
           2780                         ;  // Structure for CMD_IO requests
           2781                         ;  TPerIoDirectionAndSet_Request PerIoDirectionAndSet_Request;
           2782                         ;
           2783                         ;  // Structure returned by CMD_THERMOMETER_READ
           2784                         ;  TPerThermometerRead_Response PerThermometerRead_Response;
           2785                         ;
           2786                         ;  // Structure for CMD_UART_OPEN
           2787                         ;  TPerUartOpen_Request PerUartOpen_Request;
           2788                         ;
           2789                         ;  // Structure for CMD_UART_[CLEAR_]WRITE_READ
           2790                         ;  TPerUartWriteRead_Request PerUartWriteRead_Request;
           2791                         ;
           2792                         ;  // Structure for CMD_FRC_SEND
           2793                         ;  TPerFrcSend_Request PerFrcSend_Request;
           2794                         ;
           2795                         ;  // Structure returned by CMD_FRC_SEND and CMD_FRC_SEND_SELECTIVE
           2796                         ;  TPerFrcSend_Response PerFrcSend_Response;
           2797                         ;
           2798                         ;  // Structure for CMD_FRC_SEND_SELECTIVE
           2799                         ;  TPerFrcSendSelective_Request PerFrcSendSelective_Request;
           2800                         ;
           2801                         ;  // Structure for request and response of CMD_FRC_SET_PARAMS
           2802                         ;  TPerFrcSetParams_RequestResponse PerFrcSetParams_RequestResponse;
           2803                         ;
           2804                         ;  // Interface and CMD_COORDINATOR_BRIDGE confirmation structure
           2805                         ;  TIFaceConfirmation IFaceConfirmation;
           2806                         ;} TDpaMessage;
           2807                         ;
           2808                         ;// Custom DPA Handler events
           2809                         ;#define DpaEvent_DpaRequest               0
           2810                         ;#define DpaEvent_Interrupt                1
           2811                         ;#define DpaEvent_Idle                     2
           2812                         ;#define DpaEvent_Init                     3
           2813                         ;#define DpaEvent_Notification             4
           2814                         ;#define DpaEvent_AfterRouting             5
           2815                         ;#define DpaEvent_BeforeSleep              6
           2816                         ;#define DpaEvent_AfterSleep               7
           2817                         ;#define DpaEvent_Reset                    8
           2818                         ;#define DpaEvent_DisableInterrupts        9
           2819                         ;#define DpaEvent_FrcValue                 10
           2820                         ;#define DpaEvent_ReceiveDpaResponse       11
           2821                         ;#define DpaEvent_IFaceReceive             12
           2822                         ;#define DpaEvent_ReceiveDpaRequest        13
           2823                         ;#define DpaEvent_BeforeSendingDpaResponse 14
           2824                         ;#define DpaEvent_PeerToPeer               15
           2825                         ;#define DpaEvent_UserDpaValue             17
           2826                         ;#define DpaEvent_FrcResponseTime          18
           2827                         ;#if defined( TR7xD )
           2828                         ;#define DpaEvent_BondingButton            19
           2829                         ;#endif
           2830                         ;#define DpaEvent_Indicate                 20
           2831                         ;#define DpaEvent_VerifyLocalFrc           21
           2832                         ;#if !defined( TR7xD )
           2833                         ;#define DpaEvent_MenuActivated            22
           2834                         ;#define DpaEvent_MenuItemSelected         23
           2835                         ;#define DpaEvent_MenuItemFinalize         24
           2836                         ;#define DpaEvent_InStandby                25
           2837                         ;#endif
           2838                         ;
           2839                         ;#if defined( TR7xD )
           2840                         ;#define DpaEvent_LAST                     DpaEvent_VerifyLocalFrc
           2841                         ;#else
           2842                         ;#define DpaEvent_LAST                     DpaEvent_InStandby
           2843                         ;#endif
           2844                         ;
           2845                         ;// Types of the diagnostic DPA Value that is returned inside DPA response
           2846                         ;typedef enum
           2847                         ;{
           2848                         ;  DpaValueType_RSSI = 0,
           2849                         ;  DpaValueType_SupplyVoltage = 1,
           2850                         ;  DpaValueType_System = 2,
           2851                         ;  DpaValueType_User = 3
           2852                         ;} TDpaValueType;
           2853                         ;
           2854                         ;// Type (color) of LED peripheral
           2855                         ;typedef enum
           2856                         ;{
           2857                         ;  LED_COLOR_RED = 0,
           2858                         ;  LED_COLOR_GREEN = 1,
           2859                         ;  LED_COLOR_BLUE = 2,
           2860                         ;  LED_COLOR_YELLOW = 3,
           2861                         ;  LED_COLOR_WHITE = 4,
           2862                         ;  LED_COLOR_UNKNOWN = 0xff
           2863                         ;} TLedColor;
           2864                         ;
           2865                         ;// Baud rates
           2866                         ;typedef enum
           2867                         ;{
           2868                         ;  DpaBaud_1200 = 0x00,
           2869                         ;  DpaBaud_2400 = 0x01,
           2870                         ;  DpaBaud_4800 = 0x02,
           2871                         ;  DpaBaud_9600 = 0x03,
           2872                         ;  DpaBaud_19200 = 0x04,
           2873                         ;  DpaBaud_38400 = 0x05,
           2874                         ;  DpaBaud_57600 = 0x06,
           2875                         ;  DpaBaud_115200 = 0x07,
           2876                         ;  DpaBaud_230400 = 0x08
           2877                         ;} TBaudRates;
           2878                         ;
           2879                         ;// Useful PNUM_IO definitions
           2880                         ;typedef enum
           2881                         ;{
           2882                         ;  PNUM_IO_PORTA = 0x00,
           2883                         ;  PNUM_IO_TRISA = 0x00,
           2884                         ;
           2885                         ;  PNUM_IO_PORTB = 0x01,
           2886                         ;  PNUM_IO_TRISB = 0x01,
           2887                         ;
           2888                         ;  PNUM_IO_PORTC = 0x02,
           2889                         ;  PNUM_IO_TRISC = 0x02,
           2890                         ;
           2891                         ;  PNUM_IO_PORTE = 0x04,
           2892                         ;  PNUM_IO_TRISE = 0x04,
           2893                         ;
           2894                         ;  PNUM_IO_WPUB = 0x11,
           2895                         ;#if !defined( TR7xD )
           2896                         ;  PNUM_IO_WPUA = 0x10,
           2897                         ;  PNUM_IO_WPUC = 0x12,
           2898                         ;  PNUM_IO_WPUE = 0x14,
           2899                         ;#endif
           2900                         ;  PNUM_IO_DELAY = 0xff,
           2901                         ;} PNUM_IO_Definitions;
           2902                         ;
           2903                         ;// To test for enumeration peripherals request
           2904                         ;#define IsDpaEnumPeripheralsRequestNoSize() ( _PNUM == PNUM_ENUMERATION && _PCMD == CMD_GET_PER_INFO )
           2905                         ;
           2906                         ;#if PARAM_CHECK_LEVEL >= 2
           2907                         ;#define IsDpaEnumPeripheralsRequest() ( IsDpaEnumPeripheralsRequestNoSize() && _DpaDataLength == 0 )
           2908                         ;#else
           2909                         ;#define IsDpaEnumPeripheralsRequest() IsDpaEnumPeripheralsRequestNoSize()
           2910                         ;#endif
           2911                         ;
           2912                         ;// To test for peripherals information request
           2913                         ;#define IsDpaPeripheralInfoRequestNoSize()  ( _PNUM != PNUM_ENUMERATION && _PCMD == CMD_GET_PER_INFO )
           2914                         ;
           2915                         ;#if PARAM_CHECK_LEVEL >= 2
           2916                         ;#define IsDpaPeripheralInfoRequest()  ( IsDpaPeripheralInfoRequestNoSize() && _DpaDataLength == 0 )
           2917                         ;#else
           2918                         ;#define IsDpaPeripheralInfoRequest()  IsDpaPeripheralInfoRequestNoSize()
           2919                         ;#endif
           2920                         ;
           2921                         ;// Optimized macro for both testing enumeration peripherals ELSE peripherals information. See examples
           2922                         ;#define IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequestNoSize() if ( _PCMD == CMD_GET_PER_INFO ) if ( _PNUM == PNUM_ENUMERATION )
           2923                         ;
           2924                         ;#if PARAM_CHECK_LEVEL >= 2
           2925                         ;#define IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequest() if ( _DpaDataLength == 0 && _PCMD == CMD_GET_PER_INFO ) if ( _PNUM == PNUM_ENUMERATION )
           2926                         ;#else
           2927                         ;#define IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequest() IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequestNoSize()
           2928                         ;#endif
           2929                         ;
           2930                         ;#if defined( __CC5X__ ) && !defined( CC5XnotDPA )
           2931                         ;
           2932                         ;// DPA message at bufferRF
           2933                         ;TDpaMessage DpaRfMessage @bufferRF;
           2934                         ;
           2935                         ;// Note: Works only, because _DpaMessage.Request.PData is at the same location as bufferRF!
           2936                         ;#define _FSR_DPA    _FSR_RF
           2937                         ;
           2938                         ;// Actual allocation of the RAM Peripheral memory block @ UserBank_02
           2939                         ;bank12 uns8  PeripheralRam[PERIPHERAL_RAM_LENGTH] @ 0x620;
           2940                         ;
           2941                         ;// Actual DPA message parameters at memory
           2942                         ;#define _NADR           RX
           2943                         ;#define _NADRhigh       RTAUX
           2944                         ;#define _PNUM           PNUM
           2945                         ;#define _PCMD           PCMD
           2946                         ;#define _DpaDataLength  DLEN
           2947                         ;#define _DpaMessage     DpaRfMessage
           2948                         ;
           2949                         ;// Return actual DPA user routine event
           2950                         ;#define GetDpaEvent()   userReg0
           2951                         ;
           2952                         ;// Stores DPA Params inside DPA request/response
           2953                         ;#define _DpaParams      PPAR
           2954                         ;// Get DPA Value type out of the DPA Params
           2955                         ;#define DpaValueType()  ( _DpaParams & 0b11 )
           2956                         ;
           2957                         ;// When TRUE then encryptBufferRF/decryptBufferRF is done by AccessPassord
           2958                         ;bit encryptByAccessPassword @ usedBank0[0x23].7;
           2959                         ;
           2960                         ;// DP2P response time-slot time in 10 ms
           2961                         ;#define DP2P_TIMESLOT   11
           2962                         ;
           2963                         ;// DP2P request packet. Fills out the whole bufferRF.
           2964                         ;typedef struct
           2965                         ;{
           2966                         ;  uns8  Header[3];  // 0x000000
           2967                         ;  uns8  SelectedNodes[30];
           2968                         ;  uns8  SlotLength;
           2969                         ;  uns8  ResponseTxPower;
           2970                         ;  uns8  Reserved;
           2971                         ;  uns16 HWPID;
           2972                         ;  uns8  PDATA[sizeofBufferRF - ( 3 + 30 + 1 + 1 + 1 ) * sizeof( uns8 ) - ( 1 ) * sizeof( uns16 )]; // size is 26 bytes
           2973                         ;} STRUCTATTR TDP2Prequest;
           2974                         ;
           2975                         ;// DP2P invite packet.
           2976                         ;typedef struct
           2977                         ;{
           2978                         ;  uns8  Header[3];  // 0x000001
           2979                         ;  uns8  NADR;
           2980                         ;  uns8  Rand[12];
           2981                         ;} STRUCTATTR TDP2Invite;
           2982                         ;
           2983                         ;// DP2P confirm packet.
           2984                         ;typedef struct
           2985                         ;{
           2986                         ;  uns8  Header[3];  // 0x000003
           2987                         ;  uns8  NADR;
           2988                         ;  uns8  Rand[12];
           2989                         ;} STRUCTATTR TDP2Confirm;
           2990                         ;
           2991                         ;// DP2P response packet.
           2992                         ;typedef struct
           2993                         ;{
           2994                         ;  uns8  Header[3];  // 0xFfFfFf
           2995                         ;  uns8  NADR;
           2996                         ;  uns8  PDATA[DPA_MAX_DATA_LENGTH];
           2997                         ;} STRUCTATTR TDP2Presponse;
           2998                         ;
           2999                         ;#ifndef TR7xD
           3000                         ;
           3001                         ;// Menus
           3002                         ;#define DMENU_Online                                  0x0
           3003                         ;#define DMENU_ReadyToBond                             0x1
           3004                         ;#define DMENU_Beaming                                 0x2
           3005                         ;#define DMENU_Standby                                 0x3
           3006                         ;
           3007                         ;// Menu items
           3008                         ;#define DMENU_Item_None                               0x0
           3009                         ;#define DMENU_Item_Beaming                            ( DMENU_Online + 1 )
           3010                         ;#define DMENU_Item_BondRequest                        ( DMENU_ReadyToBond + 1 )
           3011                         ;#define DMENU_Item_ConnectivityCheck                  ( DMENU_Beaming + 1 )
           3012                         ;#define DMENU_Item_ExitStandby                        ( DMENU_Standby + 1 )
           3013                         ;#define DMENU_Item_StateIndication                    ( DMENU_Item_ExitStandby + 1 )
           3014                         ;#define DMENU_Item_User1                              ( DMENU_Item_StateIndication + 1 )
           3015                         ;#define DMENU_Item_User2                              ( DMENU_Item_User1 + 1 )
           3016                         ;#define DMENU_Item_Standby                            ( DMENU_Item_User2 + 1 )
           3017                         ;#define DMENU_Item_Reset                              ( DMENU_Item_Standby + 1 )
           3018                         ;#define DMENU_Item_UnbondAndRestart                   ( DMENU_Item_Reset + 2 )
           3019                         ;#define DMENU_Item_UnbondFactorySettingsAndRestart    ( DMENU_Item_UnbondAndRestart + 1 )
           3020                         ;
           3021                         ;// Flags for enabling/disabling menu items at event DpaEvent_MenuActivated (when TRUE is returned) and at DpaApiMenu call
           3022                         ;#define DMENU_Item_Implemented_Beaming                            0b0000.0001
           3023                         ;#define DMENU_Item_Implemented_User1                              0b0000.0100
           3024                         ;#define DMENU_Item_Implemented_User1Confirmed                     ( DMENU_Item_Implemented_User1 | DMENU_Item_Confirm_User1 )
           3025                         ;#define DMENU_Item_Implemented_User2                              0b0000.1000
           3026                         ;#define DMENU_Item_Implemented_User2Confirmed                     ( DMENU_Item_Implemented_User2 | DMENU_Item_Confirm_User2 )
           3027                         ;
           3028                         ;#define DMENU_Item_Unimplemented_Standby                          0b0001.0000
           3029                         ;#define DMENU_Item_Unimplemented_UnbondAndRestart                 0b0100.0000
           3030                         ;#define DMENU_Item_Unimplemented_UnbondFactorySettingsAndRestart  0b1000.0000
           3031                         ;
           3032                         ;#define DMENU_Item_Confirm_User1                                  0b0000.0010
           3033                         ;#define DMENU_Item_Confirm_User2                                  0b0010.0000
           3034                         ;
           3035                         ;// Flags for DpaEvent_MenuActivated when FALSE is returned
           3036                         ;#define DMENU_MenuActivated_DoNotOpen                             0b1000.0000
           3037                         ;
           3038                         ;// Macro to construct value containing both menu and item values
           3039                         ;#define MakeDMenuAndItem( menu, menuItem )            ( ((menu) << 4 ) | (menuItem) )
           3040                         ;// Macro to get menu from menu&item value
           3041                         ;#define GetDMenu( menuAndItem )                       ( (menuAndItem) >> 4 )
           3042                         ;// Macro to get menu item from menu&item value
           3043                         ;#define GetDMenuItem( menuAndItem )                   ( (menuAndItem) & 0x0F )
           3044                         ;
           3045                         ;#endif
           3046                         ;// Include assembler definitions
           3047                         ;#include "HexCodes.h"
           3048                         ;// CC5X fix
           3049                         ;#if __CC5X__ <= 3800 && _16LF18877 == 1
           3050                         ;#undef  __MOVLB
           3051                         ;#define __MOVLB(k)    (0x0140+((k)&0x3F))
           3052                         ;#endif
           3053                         ;
           3054                         ;// Next code must start at the IQRF APPLICATION routine entry point
           3055                         ;#pragma origin __APPLICATION_ADDRESS
     0000  3056         ORG 0x3A00
           3057 
           3058   ; FILE C:\customdpa\DPAcustomHandler.h
           3059                         ;// *********************************************************************
           3060                         ;//   Main Custom DPA Handler header                                    *
           3061                         ;// *********************************************************************
           3062                         ;// Copyright (c) MICRORISC s.r.o.
           3063                         ;//
           3064                         ;// File:    $RCSfile: DPAcustomHandler.h,v $
           3065                         ;// Version: $Revision: 1.167 $
           3066                         ;// Date:    $Date: 2024/12/05 09:28:58 $
           3067                         ;//
           3068                         ;// Revision history:
           3069                         ;//   2024/11/05  Release for DPA 4.32
           3070                         ;//   2024/04/17  Release for DPA 4.31
           3071                         ;//   2023/03/07  Release for DPA 4.30
           3072                         ;//   2022/10/05  Release for DPA 4.18
           3073                         ;//   2022/02/24  Release for DPA 4.17
           3074                         ;//   2021/08/20  Release for DPA 4.16
           3075                         ;//   2020/09/03  Release for DPA 4.15
           3076                         ;//   2020/04/03  Release for DPA 4.14
           3077                         ;//   2020/02/27  Release for DPA 4.13
           3078                         ;//   2020/01/09  Release for DPA 4.12
           3079                         ;//   2019/12/11  Release for DPA 4.11
           3080                         ;//   2019/10/09  Release for DPA 4.10
           3081                         ;//   2019/06/12  Release for DPA 4.03
           3082                         ;//   2019/06/03  Release for DPA 4.02
           3083                         ;//   2019/03/07  Release for DPA 4.01
           3084                         ;//   2019/01/10  Release for DPA 4.00
           3085                         ;//   2018/10/25  Release for DPA 3.03
           3086                         ;//   2017/11/16  Release for DPA 3.02
           3087                         ;//   2017/08/14  Release for DPA 3.01
           3088                         ;//   2017/03/13  Release for DPA 3.00
           3089                         ;//   2016/09/12  Release for DPA 2.28
           3090                         ;//   2016/04/14  Release for DPA 2.27
           3091                         ;//   2016/03/03  Release for DPA 2.26
           3092                         ;//   2016/01/21  Release for DPA 2.25
           3093                         ;//   2015/12/01  Release for DPA 2.24
           3094                         ;//   2015/10/23  Release for DPA 2.23
           3095                         ;//   2015/09/25  Release for DPA 2.22
           3096                         ;//   2015/09/03  Release for DPA 2.21
           3097                         ;//   2015/08/05  Release for DPA 2.20
           3098                         ;//   2014/10/31  Release for DPA 2.10
           3099                         ;//   2014/04/30  Release for DPA 2.00
           3100                         ;//   2013/10/03  Release for DPA 1.00
           3101                         ;//
           3102                         ;// *********************************************************************
           3103                         ;
           3104                         ;// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
           3105                         ;// IQRF Standards documentation https://doc.iqrf.org/
           3106                         ;
           3107                         ;#ifndef _CUSTOM_DPA_HANDLER_
           3108                         ;#define _CUSTOM_DPA_HANDLER_
           3109                         ;
           3110                         ;//############################################################################################
           3111                         ;// 1st include
           3112                         ;
           3113                         ;// Custom DPA Handler routine declaration
           3114                         ;bit CustomDpaHandler();
           3115                         ;
           3116                         ;// Various DPA flags shared between DPA and Custom DPA Handler
           3117                         ;uns8 DpaFlags @ usedBank4[0];
           3118                         ;
           3119                         ;// [C][N] TRUE if I2C timeout occurred at the last DpaApiI2C?() call
           3120                         ;bit I2CwasTimeout @ DpaFlags.0;
           3121                         ;// [N] Flag for the 1st DpaApiSleep
           3122                         ;bit FirstDpaApiSleep @ DpaFlags.1;
           3123                         ;
           3124                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           3125                         ;// [C] TRUE if interface master is not connected (detected)
           3126                         ;bit IFaceMasterNotConnected @ DpaFlags.2;
           3127                         ;#endif
           3128                         ;// [N] DPA by interface notification is sent also when there was a "reading" like DPA request
           3129                         ;bit EnableIFaceNotificationOnRead @ DpaFlags.3;
           3130                         ;// [N] TRUE when node was just bonded using default bonding procedure
           3131                         ;bit NodeWasBonded @ DpaFlags.4;
           3132                         ;// [N] When TRUE, then next call of DpaApiRfTxDpaPacket sends non-routed packet
           3133                         ;bit NonroutedRfTxDpaPacket @ DpaFlags.7;
           3134                         ;
           3135                         ;// [C] Ticks (decrementing) counter usable for timing in the coordinator's Customer DPA Handler
           3136                         ;uns16 DpaTicks @ usedBank4[1];
           3137                         ;// [N] toutRF for LP mode, read from configuration memory after reset
           3138                         ;uns8 LPtoutRF @ usedBank4[3];
           3139                         ;// DPA Request/Response HWPID
           3140                         ;uns16 _HWPID @ usedBank4[4];
           3141                         ;// Identifies type of reset (stored at UserReg0 upon module reset). See Reset chapter at IQRF User's Guide for more information
           3142                         ;uns8 ResetType @ usedBank4[6];
           3143                         ;// User DPA Values to return
           3144                         ;uns8 UserDpaValue @ usedBank4[7];
           3145                         ;// Network depth of the DPA request/response, increases on bridging, decreases on back-bridging
           3146                         ;uns8 NetDepth @ usedBank4[8];
           3147                         ;// TRUE when node was at DPA Service Mode after last boot
           3148                         ;bit DSMactivated @ usedBank4[9].0;
           3149                         ;// If set to TRUE, then LP RX mode in the main loop can be terminated by pin, see _RLPMAT
           3150                         ;bit LpRxPinTerminate @ usedBank4[9].1;
           3151                         ;// If set to TRUE, then [C] executes asynchronous DPA requests received from [N]
           3152                         ;bit AsyncReqAtCoordinator @ usedBank4[9].2;
           3153                         ;// RX filter used at the DPA main loop checkRF call
           3154                         ;uns8 RxFilter @ usedBank4[11];
           3155                         ;// Countdown variable for button bonding before going to deep sleep
           3156                         ;uns16 BondingSleepCountdown @ usedBank4[12];
           3157                         ;#define BONDING_SLEEP_COUNTDOWN_UNIT  290
           3158                         ;// Non-zero pseudo-random value, read-only, updated on every Reset and Idle event, at [N] only.
           3159                         ;uns16 Random @ usedBank4[14];
           3160                         ;// DPA value from the received packet or just to be sent to the interface.
           3161                         ;uns8 DpaValue @ usedBank4[16];
           3162                         ;// If non-zero then timeout value for DpaApiI2C?() calls
           3163                         ;uns8 I2Ctimeout @ usedBank4[17];
           3164                         ;
           3165                         ;// Macro to return an error from the peripheral handler. If the code size is not an issue this macro is the right choice.
           3166                         ;#define DpaApiReturnPeripheralError(error) do { \
           3167                         ;    DpaApiSetPeripheralError( error ); \
           3168                         ;    return Carry; \
           3169                         ;  } while( 0 )
           3170                         ;
           3171                         ;// DPA API functions, see documentation for details
           3172                         ;#define DpaApiRfTxDpaPacket( dpaValue, netDepthAndFlags ) DpaApiEntry( dpaValue, netDepthAndFlags, DPA_API_RFTX_DPAPACKET )
           3173                         ;#define DpaApiReadConfigByte( index )                     DpaApiEntry( index, param3.low8, DPA_API_READ_CONFIG_BYTE )
           3174                         ;#define DpaApiLocalRequest()                              DpaApiEntry( param2, param3.low8, DPA_API_LOCAL_REQUEST )
           3175                         ;#define DpaApiSetPeripheralError( error )                 DpaApiEntry( error, param3.low8, DPA_API_SET_PERIPHERAL_ERROR )
           3176                         ;#define DpaApiSendToIFaceMaster( dpaValue, flags )        DpaApiEntry( dpaValue, flags, DPA_API_SEND_TO_IFACEMASTER )
           3177                         ;#define DpaApiSetRfDefaults()                             DpaApiEntry( param2, param3.low8, DPA_API_SET_RF_DEFAULTS )
           3178                         ;#define DpaApiLocalFrc( frcCommand, replyTxPower )        DpaApiEntry( frcCommand, replyTxPower, DPA_API_LOCAL_FRC )
           3179                         ;#define DpaApiCrc8( crc8, data )                          DpaApiEntry( crc8, data, DPA_API_CRC8 )
           3180                         ;#define DpaApiAggregateFrc()                              DpaApiEntry( param2, param3.low8, DPA_API_AGGREGATE_FRC )
           3181                         ;#define DpaApiSetOTK()                                    DpaApiEntry( param2, param3.low8, DPA_API_SET_OTK )
           3182                         ;#define DpaApiI2Cinit( frequency )                        DpaApiEntry( frequency, param3.low8, DPA_API_I2C_INIT )
           3183                         ;#define DpaApiI2Cstart( address )                         DpaApiEntry( address, param3.low8, DPA_API_I2C_START )
           3184                         ;#define DpaApiI2Cwrite( data )                            DpaApiEntry( data, param3.low8, DPA_API_I2C_WRITE )
           3185                         ;#define DpaApiI2Cread( ack )                              DpaApiEntry( ack, param3.low8, DPA_API_I2C_READ )
           3186                         ;#define DpaApiI2Cstop()                                   DpaApiEntry( param2, param3.low8, DPA_API_I2C_STOP )
           3187                         ;#define DpaApiI2CwaitForACK( address )                    DpaApiEntry( address, param3.low8, DPA_API_I2C_WAIT_FOR_ACK )
           3188                         ;#define DpaApiI2Cshutdown()                               DpaApiEntry( param2, param3.low8, DPA_API_I2C_SHUTDOWN )
           3189                         ;#define DpaApiI2CwaitForIdle()                            DpaApiEntry( param2, param3.low8, DPA_API_I2C_WAIT_FOR_IDLE )
           3190                         ;#define DpaApiSleep( wdtcon )                             DpaApiEntry( wdtcon, param3.low8, DPA_API_SLEEP )
           3191                         ;#define DpaApiAfterSleep()                                DpaApiEntry( param2, param3.low8, DPA_API_AFTER_SLEEP )
           3192                         ;#define DpaApiRandom()                                    DpaApiEntry( param2, param3.low8, DPA_API_RANDOM )
           3193                         ;
           3194                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           3195                         ;#define DpaApiRfTxDpaPacketCoordinator()                  DpaApiEntry( param2, param3.low8, DPA_API_COORDINATOR_RFTX_DPAPACKET )
           3196                         ;#endif
           3197                         ;
           3198                         ;#if !defined( TR7xD )
           3199                         ;#define DpaApiMenu( menu, flags )                         DpaApiEntry( menu, flags, DPA_API_MENU )
           3200                         ;#define DpaApiMenuIndicateResult( ok )                    DpaApiEntry( ok, param3.low8, DPA_API_MENU_INDICATE_RESULT )
           3201                         ;#define DpaApiMenuExecute( menuAndItem )                  DpaApiEntry( menuAndItem, param3.low8, DPA_API_MENU_EXECUTE )
           3202                         ;#define DpaApiDeepSleep( wdtcon )                         DpaApiEntry( wdtcon, param3.low8, DPA_API_DEEP_SLEEP )
           3203                         ;#endif
           3204                         ;
           3205                         ;#define DpaApiLocalFrc_StackSaver( frcCommand, replyTxPower ) \
           3206                         ;  param2 = frcCommand; \
           3207                         ;  param3.low8 = replyTxPower; \
           3208                         ;  W = DPA_API_LOCAL_FRC; \
           3209                         ;  #asm \
           3210                         ;    DW  __MOVLP( DPA_API_ADDRESS >> 8 ); \
           3211                         ;    DW  __CALL( DPA_API_ADDRESS ); \
           3212                         ;    DW  __MOVLP( CUSTOM_HANDLER_ADDRESS >> 8 ); \
           3213                         ;  #endasm \
           3214                         ;
           3215                         ;#define I2CcomputeFrequency( I2Cfrequency)                ( ( ( F_OSC ) / ( ( I2Cfrequency ) * 4 ) ) - 1 )
           3216                         ;
           3217                         ;// Wrapper routines to be called instead of DpaApi??? macros to decrease code size if more than ~2 calls are needed
           3218                         ;void _DpaApiI2Cinit( uns8 frequency );
           3219                         ;void _DpaApiI2Cstart( uns8 address );
           3220                         ;void _DpaApiI2Cwrite( uns8 data );
           3221                         ;uns8 _DpaApiI2Cread( uns8 ack );
           3222                         ;void _DpaApiI2Cstop();
           3223                         ;void _DpaApiI2CwaitForACK( uns8 address );
           3224                         ;void _DpaApiI2Cshutdown();
           3225                         ;void _DpaApiI2CwaitForIdle();
           3226                         ;void _DpaApiSleep( uns8 wdtcon );
           3227                         ;#if !defined( TR7xD )
           3228                         ;void _DpaApiDeepSleep( uns8 wdtcon );
           3229                         ;#endif
           3230                         ;void _DpaApiSleepFirst( uns8 wdtcon );
           3231                         ;void _DpaApiAfterSleep();
           3232                         ;uns8 _DpaApiRandom();
           3233                         ;void _DpaApiSetRfDefaults();
           3234                         ;
           3235                         ;// Helper "multi" function to decrease code size if used more times
           3236                         ;void _DpaApiI2Cwrite0();
           3237                         ;void _DpaApiI2CwriteAndStop( uns8 data );
           3238                         ;uns8 _DpaApiI2CreadACK();
           3239                         ;uns8 _DpaApiI2CreadNACK();
           3240                         ;uns8 _DpaApiI2CreadNACKandStop();
           3241                         ;
           3242                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           3243                         ;#undef  DpaEvent_Interrupt
           3244                         ;#undef  DpaEvent_BeforeSleep
           3245                         ;#undef  DpaEvent_AfterSleep
           3246                         ;#undef  DpaEvent_FrcValue
           3247                         ;#undef  DpaEvent_FrcResponseTime
           3248                         ;#else
           3249                         ;#undef  DpaEvent_ReceiveDpaResponse
           3250                         ;#undef  DpaEvent_IFaceReceive
           3251                         ;#endif
           3252                         ;
           3253                         ;// To detect overlapping code in case someone would put some code before this header by mistake
           3254                         ;#pragma origin __APPLICATION_ADDRESS
     0000  3255         ORG 0x3A00
           3256                         ;#pragma updateBank 0
           3257                         ;
           3258                         ;//############################################################################################
           3259                         ;// Main IQRF entry point jumps to the main DPA entry point
           3260                         ;void APPLICATION()
           3261                         ;//############################################################################################
           3262                         ;{
           3263 APPLICATION
           3264                         ;  #asm
           3265                         ;    DW  __MOVLP( MAIN_DPA_ADDRESS >> 8 );
3A00 31AC  3266         DW    0x31AC
           3267                         ;  DW  __GOTO( MAIN_DPA_ADDRESS );
3A01 2C04  3268         DW    0x2C04
           3269                         ;  #endasm
           3270                         ;
           3271                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           3272                         ;    // Fake call to force CustomDpaHandler() compilation
           3273                         ;    CustomDpaHandler();
3A02 2220  3274         CALL  CustomDpaHandler
           3275                         ;#endif
           3276                         ;
           3277                         ;  // Fake call to force DpaApiEntry() compilation
           3278                         ;  DpaApiEntry( param2, param3.low8, W );
3A03 2A08  3279         GOTO  DpaApiEntry
           3280                         ;}
           3281                         ;
           3282                         ;//############################################################################################
           3283                         ;// Entry stub to the real DPA API entry
           3284                         ;#pragma origin DPA_API_ADDRESS_ENTRY
     0000  3285         ORG 0x3A08
           3286                         ;uns8  DpaApiEntry( uns8 par1 @ param2, uns8 par2 @ param3.low8, uns8 apiIndex @ W )
           3287                         ;//############################################################################################
           3288                         ;{
           3289 DpaApiEntry
           3290                         ;  #asm
           3291                         ;    DW  __MOVLP( DPA_API_ADDRESS >> 8 );
3A08 31AC  3292         DW    0x31AC
           3293                         ;  DW  __CALL( DPA_API_ADDRESS );
3A09 2400  3294         DW    0x2400
           3295                         ;  DW  __MOVLP( DPA_API_ADDRESS_ENTRY >> 8 );
3A0A 31BA  3296         DW    0x31BA
           3297                         ;  #endasm
           3298                         ;
           3299                         ;    return W;
3A0B 0008  3300         RETURN
           3301                         ;}
           3302                         ;
           3303                         ;//############################################################################################
           3304                         ;#pragma origin DPA_API_ADDRESS_ENTRY + 0x08
     0000  3305         ORG 0x3A10
           3306                         ;
           3307                         ;//############################################################################################
           3308                         ;
           3309                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           3310                         ;// Next comes Custom DPA handler routine
           3311                         ;#pragma origin CUSTOM_HANDLER_ADDRESS
     0000  3312         ORG 0x3A20
           3313                         ;#endif
           3314                         ;
           3315                         ;#pragma updateBank 1
           3316 
           3317   ; FILE C:\customdpa\CustomDpaHandle.c
           3318                         ;// *********************************************************************
           3319                         ;//   Custom DPA Handler code template                                  *
           3320                         ;// *********************************************************************
           3321                         ;// Copyright (c) MICRORISC s.r.o.
           3322                         ;//
           3323                         ;// File:    $RCSfile: CustomDpaHandler-Template.c,v $
           3324                         ;// Version: $Revision: 1.77 $
           3325                         ;// Date:    $Date: 2023/11/03 16:32:30 $
           3326                         ;//
           3327                         ;// Revision history:
           3328                         ;//   2023/03/07  Release for DPA 4.30
           3329                         ;//   2022/10/05  Release for DPA 4.18
           3330                         ;//   2022/02/24  Release for DPA 4.17
           3331                         ;//   2021/08/20  Release for DPA 4.16
           3332                         ;//   2020/09/03  Release for DPA 4.15
           3333                         ;//   2020/02/27  Release for DPA 4.13
           3334                         ;//   2019/01/10  Release for DPA 4.00
           3335                         ;//   2017/08/14  Release for DPA 3.01
           3336                         ;//   2017/03/13  Release for DPA 3.00
           3337                         ;//   2015/08/05  Release for DPA 2.20
           3338                         ;//   2014/10/31  Release for DPA 2.10
           3339                         ;//   2014/04/30  Release for DPA 2.00
           3340                         ;//
           3341                         ;// *********************************************************************
           3342                         ;
           3343                         ;// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
           3344                         ;
           3345                         ;/*<
           3346                         ;This is a Custom DPA Handler with all available events prepared.
           3347                         ;Use the following define to use a Coordinator version instead of default Node version.
           3348                         ;`#define COORDINATOR_CUSTOM_HANDLER`
           3349                         ;>*/
           3350                         ;
           3351                         ;// Default IQRF include (modify the path according to your setup)
           3352                         ;#include "IQRF.h"
           3353                         ;
           3354                         ;// Default DPA header (modify the path according to your setup)
           3355                         ;#include "DPA.h"
           3356                         ;// Default Custom DPA Handler header (modify the path according to your setup)
           3357                         ;#include "DPAcustomHandler.h"
           3358                         ;
           3359                         ;// Uncomment the following includes if the respective component is needed
           3360                         ;// IQRF standards header (modify the path according to your setup)
           3361                         ;//#include "IQRFstandard.h"
           3362                         ;//#include "IQRF_HWPID.h"
           3363                         ;//#include "NFC.c"
           3364                         ;
           3365                         ;#define COORDINATOR_CUSTOM_HANDLER
           3366                         ;
           3367                         ;//############################################################################################
           3368                         ;
           3369                         ;// Place for global variables shared among CustomDpaHandler() and other function, otherwise local [static] variables are recommended
           3370                         ;// example: uns8 globalCounter;
           3371                         ;
           3372                         ;// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
           3373                         ;//############################################################################################
           3374                         ;// https://doc.iqrf.org/DpaTechGuide/pages/custom-dpa-handler.html
           3375                         ;bit CustomDpaHandler()
           3376                         ;//############################################################################################
           3377                         ;{
           3378 CustomDpaHandler
           3379                         ;  // Handler presence mark
           3380                         ;  clrwdt();
3A20 0064  3381         CLRWDT
           3382                         ;
           3383                         ;  // Place for local static variables used only within CustomDpaHandler() among more events
           3384                         ;  // example: static bit interruptOccured;
           3385                         ;
           3386                         ;  // Detect DPA event to handle (unused event handlers can be commented out or even deleted)
           3387                         ;  switch ( GetDpaEvent() )
3A21 0870  3388         MOVF  userReg0,W
3A22 3A01  3389         XORLW 0x01
3A23 1903  3390         BTFSC 0x03,Zero_
3A24 3228  3391         BRA   m001
3A25 3A03  3392         XORLW 0x03
3A26 1903  3393         BTFSC 0x03,Zero_
3A27 3226  3394         BRA   m002
3A28 3A0A  3395         XORLW 0x0A
3A29 1903  3396         BTFSC 0x03,Zero_
3A2A 324E  3397         BRA   m007
3A2B 3A0B  3398         XORLW 0x0B
3A2C 1903  3399         BTFSC 0x03,Zero_
3A2D 324B  3400         BRA   m007
3A2E 3A0E  3401         XORLW 0x0E
3A2F 1903  3402         BTFSC 0x03,Zero_
3A30 3248  3403         BRA   m007
3A31 3A03  3404         XORLW 0x03
3A32 1903  3405         BTFSC 0x03,Zero_
3A33 3245  3406         BRA   m007
3A34 3A0A  3407         XORLW 0x0A
3A35 1903  3408         BTFSC 0x03,Zero_
3A36 3242  3409         BRA   m007
3A37 3A01  3410         XORLW 0x01
3A38 1903  3411         BTFSC 0x03,Zero_
3A39 323F  3412         BRA   m007
3A3A 3A0C  3413         XORLW 0x0C
3A3B 1903  3414         BTFSC 0x03,Zero_
3A3C 323C  3415         BRA   m007
3A3D 3A02  3416         XORLW 0x02
3A3E 1903  3417         BTFSC 0x03,Zero_
3A3F 3239  3418         BRA   m007
3A40 3A07  3419         XORLW 0x07
3A41 1903  3420         BTFSC 0x03,Zero_
3A42 3236  3421         BRA   m007
3A43 3A03  3422         XORLW 0x03
3A44 1903  3423         BTFSC 0x03,Zero_
3A45 3233  3424         BRA   m007
3A46 3A1E  3425         XORLW 0x1E
3A47 1903  3426         BTFSC 0x03,Zero_
3A48 3230  3427         BRA   m007
3A49 3A11  3428         XORLW 0x11
3A4A 1903  3429         BTFSC 0x03,Zero_
3A4B 320B  3430         BRA   m003
3A4C 322C  3431         BRA   m007
           3432                         ;  {
           3433                         ;#ifdef DpaEvent_Interrupt
           3434                         ;    // -------------------------------------------------
           3435                         ;    case DpaEvent_Interrupt:
           3436                         ;      // Do an extra quick background interrupt work
           3437                         ;      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
           3438                         ;      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
           3439                         ;      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the empty return handler ensures the shortest possible interrupt routine response time.
           3440                         ;      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
           3441                         ;      // ! Make sure race condition does not occur when accessing those variables at other places.
           3442                         ;      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
           3443                         ;      // ! Do not call any OS functions except setINDFx().
           3444                         ;      // ! Do not use any OS variables especially for writing access.
           3445                         ;      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.
           3446                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/EventInterrupt.html
           3447                         ;      return Carry;
3A4D 0008  3448 m001    RETURN
           3449                         ;#endif
           3450                         ;      // -------------------------------------------------
           3451                         ;    case DpaEvent_Idle:
           3452                         ;
           3453                         ;        setLEDG();
3A4E 209A  3454 m002    CALL  setLEDG
           3455                         ;        waitMS(25);
3A4F 3019  3456         MOVLW 0x19
3A50 2076  3457         CALL  waitMS
           3458                         ;        stopLEDG();
3A51 2031  3459         CALL  stopLEDG
           3460                         ;        setLEDR();
3A52 2164  3461         CALL  setLEDR
           3462                         ;        waitMS(25);
3A53 3019  3463         MOVLW 0x19
3A54 2076  3464         CALL  waitMS
           3465                         ;        stopLEDR();
3A55 2028  3466         CALL  stopLEDR
           3467                         ;
           3468                         ;      break;
3A56 3222  3469         BRA   m007
           3470                         ;
           3471                         ;      // -------------------------------------------------
           3472                         ;    case DpaEvent_Reset:
           3473                         ;      // Called after module is reset
           3474                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/ResetEvent.html
           3475                         ;
           3476                         ;      //goto DpaHandleReturnTRUE; // return TRUE only if you handle node bonding/unbonding
           3477                         ;      break;
           3478                         ;
           3479                         ;#if !defined( COORDINATOR_CUSTOM_HANDLER ) && defined( DpaEvent_BondingButton )
           3480                         ;      // -------------------------------------------------
           3481                         ;    case DpaEvent_BondingButton:
           3482                         ;      // Called to allow a bonding button customization
           3483                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/bondingbutton.html
           3484                         ;
           3485                         ;      //goto DpaHandleReturnTRUE; // return TRUE to handle bonding button
           3486                         ;      break;
           3487                         ;#endif
           3488                         ;
           3489                         ;#ifndef COORDINATOR_CUSTOM_HANDLER
           3490                         ;      // -------------------------------------------------
           3491                         ;    case DpaEvent_Indicate:
           3492                         ;      // Called to allow a customization of the device indication
           3493                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/IndicateEvent.html
           3494                         ;
           3495                         ;      //goto DpaHandleReturnTRUE; // return TRUE to skip default indication
           3496                         ;      break;
           3497                         ;#endif
           3498                         ;
           3499                         ;      // -------------------------------------------------
           3500                         ;    case DpaEvent_Init:
           3501                         ;      // Do a one time initialization before main loop starts
           3502                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/init.html
           3503                         ;      break;
           3504                         ;
           3505                         ;      // -------------------------------------------------
           3506                         ;    case DpaEvent_ReceiveDpaRequest:
           3507                         ;      // Called after DPA request was received
           3508                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/receivedparequest.html
           3509                         ;
           3510                         ;      //goto DpaHandleReturnTRUE; // return TRUE to skip default processing
           3511                         ;      break;
           3512                         ;
           3513                         ;      // -------------------------------------------------
           3514                         ;    case DpaEvent_BeforeSendingDpaResponse:
           3515                         ;      // Called before sending DPA response back to originator of DPA response
           3516                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/beforesendingdparesponse.html
           3517                         ;      break;
           3518                         ;
           3519                         ;      // -------------------------------------------------
           3520                         ;    case DpaEvent_Notification:
           3521                         ;      // Called after DPA request was processed and after DPA response was sent
           3522                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/notification.html
           3523                         ;      break;
           3524                         ;
           3525                         ;      // -------------------------------------------------
           3526                         ;    case DpaEvent_AfterRouting:
           3527                         ;      // Called after Notification and after routing of the DPA response was finished
           3528                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/afterrouting.html
           3529                         ;      break;
           3530                         ;
           3531                         ;#ifndef COORDINATOR_CUSTOM_HANDLER
           3532                         ;      // -------------------------------------------------
           3533                         ;    case DpaEvent_FrcValue:
           3534                         ;      // Called to get FRC value
           3535                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/frcvalue.html
           3536                         ;      break;
           3537                         ;#endif
           3538                         ;
           3539                         ;#ifndef COORDINATOR_CUSTOM_HANDLER
           3540                         ;      // -------------------------------------------------
           3541                         ;    case DpaEvent_FrcResponseTime:
           3542                         ;      // Called to get FRC response time
           3543                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/frcresponsetime.html
           3544                         ;      break;
           3545                         ;#endif
           3546                         ;
           3547                         ;#ifndef COORDINATOR_CUSTOM_HANDLER
           3548                         ;      // -------------------------------------------------
           3549                         ;    case DpaEvent_BeforeSleep:
           3550                         ;      // Called before going to sleep
           3551                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/beforesleep.html
           3552                         ;      break;
           3553                         ;#endif
           3554                         ;
           3555                         ;#ifndef COORDINATOR_CUSTOM_HANDLER
           3556                         ;      // -------------------------------------------------
           3557                         ;    case DpaEvent_AfterSleep:
           3558                         ;      // Called after woken up after sleep
           3559                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/aftersleep.html
           3560                         ;      break;
           3561                         ;#endif
           3562                         ;
           3563                         ;      // -------------------------------------------------
           3564                         ;    case DpaEvent_DisableInterrupts:
           3565                         ;      // Called when device needs all hardware interrupts to be disabled (before Reset, Restart, LoadCode, Remove bond and run RFPGM)
           3566                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/eventDisableInterrupts.html
           3567                         ;      break;
           3568                         ;
           3569                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           3570                         ;      // -------------------------------------------------
           3571                         ;    //case DpaEvent_ReceiveDpaResponse:
           3572                         ;    case 11:
           3573                         ;      // Called after DPA response was received at coordinator
           3574                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/receivedparesponse.html
           3575                         ;      //goto DpaHandleReturnTRUE; // return TRUE to skip default processing
           3576                         ;      break;
           3577                         ;#endif
           3578                         ;
           3579                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           3580                         ;      // -------------------------------------------------
           3581                         ;    //case DpaEvent_IFaceReceive:
           3582                         ;    case 12:
           3583                         ;      // Called after DPA request from interface master was received at coordinator
           3584                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/ifacereceive.html
           3585                         ;
           3586                         ;      //goto DpaHandleReturnTRUE; // return TRUE to skip default processing
           3587                         ;      break;
           3588                         ;#endif
           3589                         ;
           3590                         ;      // -------------------------------------------------
           3591                         ;    case DpaEvent_PeerToPeer:
           3592                         ;      // Called when peer-to-peer (non-networking) packet is received
           3593                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/peertopeer.html
           3594                         ;      break;
           3595                         ;
           3596                         ;      // -------------------------------------------------
           3597                         ;    case DpaEvent_UserDpaValue:
           3598                         ;      // Called when DPA is required to return User defined DPA value in the response
           3599                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/userdpavalue.html
           3600                         ;      break;
           3601                         ;
           3602                         ;      // -------------------------------------------------
           3603                         ;#if !defined( COORDINATOR_CUSTOM_HANDLER ) && defined( DpaEvent_InStandby )
           3604                         ;    case DpaEvent_InStandby:
           3605                         ;      // Called to set WDT during Standby
           3606                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/instandby.html
           3607                         ;
           3608                         ;      //goto DpaHandleReturnTRUE; // return TRUE to indicate that userReg1 contains WDT settings
           3609                         ;      goto DpaHandleReturnFALSE;
           3610                         ;#endif
           3611                         ;
           3612                         ;#ifndef COORDINATOR_CUSTOM_HANDLER
           3613                         ;      // -------------------------------------------------
           3614                         ;    case DpaEvent_VerifyLocalFrc:
           3615                         ;      // Called to verify local FRC command
           3616                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/verifylocalfrc.html
           3617                         ;
           3618                         ;      //goto DpaHandleReturnTRUE; // return TRUE allow FRC command
           3619                         ;      break;
           3620                         ;#endif
           3621                         ;
           3622                         ;      // -------------------------------------------------
           3623                         ;#if !defined( COORDINATOR_CUSTOM_HANDLER ) && defined( DpaEvent_MenuActivated )
           3624                         ;    case DpaEvent_MenuActivated:
           3625                         ;      // Called to customize DPA menu
           3626                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/menuactivated.html
           3627                         ;
           3628                         ;      //goto DpaHandleReturnTRUE; // return TRUE to allow customizing menu specified by userReg1
           3629                         ;      break;
           3630                         ;#endif
           3631                         ;
           3632                         ;      // -------------------------------------------------
           3633                         ;#if !defined( COORDINATOR_CUSTOM_HANDLER ) && defined( DpaEvent_MenuItemSelected )
           3634                         ;    case DpaEvent_MenuItemSelected:
           3635                         ;      // Called to indicate "OK" or "Error" for selected menu item
           3636                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/menuitemselected.html
           3637                         ;
           3638                         ;      //goto DpaHandleReturnTRUE; // return TRUE to indicate "OK" for menu item specified by userReg1, otherwise to indicate Error
           3639                         ;      break;
           3640                         ;#endif
           3641                         ;
           3642                         ;      // -------------------------------------------------
           3643                         ;#if !defined( COORDINATOR_CUSTOM_HANDLER ) && defined( DpaEvent_MenuItemFinalize )
           3644                         ;    case DpaEvent_MenuItemFinalize:
           3645                         ;      // Called to finalize menu item execution
           3646                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/menuitemfinalize.html
           3647                         ;
           3648                         ;      break;
           3649                         ;#endif
           3650                         ;
           3651                         ;      // -------------------------------------------------
           3652                         ;    case DpaEvent_DpaRequest:
           3653                         ;      // Called to interpret DPA request for peripherals
           3654                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/EventDpaRequest.html
           3655                         ;      IfDpaEnumPeripherals_Else_PeripheralInfo_Else_PeripheralRequest()
3A57 0145  3656 m003    MOVLB 0x05
3A58 08A1  3657         MOVF  DLEN,1
3A59 1D03  3658         BTFSS 0x03,Zero_
3A5A 3216  3659         BRA   m006
3A5B 082F  3660         MOVF  PCMD,W
3A5C 3A3F  3661         XORLW 0x3F
3A5D 1D03  3662         BTFSS 0x03,Zero_
3A5E 3212  3663         BRA   m006
3A5F 0F2E  3664         INCFSZ PNUM,W
3A60 3205  3665         BRA   m005
           3666                         ;      {
           3667                         ;        // -------------------------------------------------
           3668                         ;        // Peripheral enumeration
           3669                         ;        // https://doc.iqrf.org/DpaTechGuide/pages/enumerate-peripherals.html
           3670                         ;
           3671                         ;        _DpaMessage.EnumPeripheralsAnswer.UserPerNr |= 0; // ?
           3672                         ;        // FlagUserPer( _DpaMessage.EnumPeripheralsAnswer.UserPer, PNUM_USER + 0 ); // ?
           3673                         ;        _DpaMessage.EnumPeripheralsAnswer.HWPID |= 0x000F; // ????
3A61 300F  3674         MOVLW 0x0F
3A62 0149  3675         MOVLB 0x09
3A63 04A7  3676         IORWF DpaRfMessage+7,1
           3677                         ;        _DpaMessage.EnumPeripheralsAnswer.HWPIDver |= 0; // ????
           3678                         ;
           3679                         ;DpaHandleReturnTRUE:
           3680                         ;        return TRUE;
3A64 1403  3681 m004    BSF   0x03,Carry
3A65 0008  3682         RETURN
           3683                         ;      }
           3684                         ;      else
           3685                         ;      {
           3686                         ;        // -------------------------------------------------
           3687                         ;        // Get information about peripheral
           3688                         ;        // https://doc.iqrf.org/DpaTechGuide/pages/get-peripheral-info.html
           3689                         ;
           3690                         ;        if ( _PNUM == PNUM_USER + 0 ) // ?
3A66 0145  3691 m005    MOVLB 0x05
3A67 082E  3692         MOVF  PNUM,W
3A68 3A20  3693         XORLW 0x20
3A69 1D03  3694         BTFSS 0x03,Zero_
3A6A 320E  3695         BRA   m007
           3696                         ;        {
           3697                         ;          _DpaMessage.PeripheralInfoAnswer.PerT = 0; // PERIPHERAL_TYPE_?
3A6B 0149  3698         MOVLB 0x09
3A6C 01A1  3699         CLRF  DpaRfMessage+1
           3700                         ;          _DpaMessage.PeripheralInfoAnswer.PerTE = 0; // PERIPHERAL_TYPE_EXTENDED_?
3A6D 01A0  3701         CLRF  DpaRfMessage
           3702                         ;          _DpaMessage.PeripheralInfoAnswer.Par1 = 0; // ?
3A6E 01A2  3703         CLRF  DpaRfMessage+2
           3704                         ;          _DpaMessage.PeripheralInfoAnswer.Par2 = 0; // ?
3A6F 01A3  3705         CLRF  DpaRfMessage+3
           3706                         ;          goto DpaHandleReturnTRUE;
3A70 33F3  3707         BRA   m004
           3708                         ;        }
           3709                         ;
           3710                         ;        break;
           3711                         ;      }
           3712                         ;
           3713                         ;      // -------------------------------------------------
           3714                         ;      // Handle peripheral command
           3715                         ;      // https://doc.iqrf.org/DpaTechGuide/pages/handle-peripheral-request.html
           3716                         ;
           3717                         ;      if ( _PNUM == PNUM_USER + 0 ) // ?
3A71 0145  3718 m006    MOVLB 0x05
3A72 082E  3719         MOVF  PNUM,W
3A73 3A20  3720         XORLW 0x20
3A74 1D03  3721         BTFSS 0x03,Zero_
3A75 3203  3722         BRA   m007
           3723                         ;      {
           3724                         ;        if ( _PCMD == 0 ) // ????
3A76 08AF  3725         MOVF  PCMD,1
3A77 1903  3726         BTFSC 0x03,Zero_
           3727                         ;        {
           3728                         ;          goto DpaHandleReturnTRUE;
3A78 33EB  3729         BRA   m004
           3730                         ;        }
           3731                         ;      }
           3732                         ;
           3733                         ;      break;
           3734                         ;  }
           3735                         ;
           3736                         ;DpaHandleReturnFALSE:
           3737                         ;  return FALSE;
3A79 1003  3738 m007    BCF   0x03,Carry
3A7A 0008  3739         RETURN
           3740 
           3741   ; FILE C:\customdpa\DPAcustomHandler.h
           3742                         ;// *********************************************************************
           3743                         ;//   Main Custom DPA Handler header                                    *
           3744                         ;// *********************************************************************
           3745                         ;// Copyright (c) MICRORISC s.r.o.
           3746                         ;//
           3747                         ;// File:    $RCSfile: DPAcustomHandler.h,v $
           3748                         ;// Version: $Revision: 1.167 $
           3749                         ;// Date:    $Date: 2024/12/05 09:28:58 $
           3750                         ;//
           3751                         ;// Revision history:
           3752                         ;//   2024/11/05  Release for DPA 4.32
           3753                         ;//   2024/04/17  Release for DPA 4.31
           3754                         ;//   2023/03/07  Release for DPA 4.30
           3755                         ;//   2022/10/05  Release for DPA 4.18
           3756                         ;//   2022/02/24  Release for DPA 4.17
           3757                         ;//   2021/08/20  Release for DPA 4.16
           3758                         ;//   2020/09/03  Release for DPA 4.15
           3759                         ;//   2020/04/03  Release for DPA 4.14
           3760                         ;//   2020/02/27  Release for DPA 4.13
           3761                         ;//   2020/01/09  Release for DPA 4.12
           3762                         ;//   2019/12/11  Release for DPA 4.11
           3763                         ;//   2019/10/09  Release for DPA 4.10
           3764                         ;//   2019/06/12  Release for DPA 4.03
           3765                         ;//   2019/06/03  Release for DPA 4.02
           3766                         ;//   2019/03/07  Release for DPA 4.01
           3767                         ;//   2019/01/10  Release for DPA 4.00
           3768                         ;//   2018/10/25  Release for DPA 3.03
           3769                         ;//   2017/11/16  Release for DPA 3.02
           3770                         ;//   2017/08/14  Release for DPA 3.01
           3771                         ;//   2017/03/13  Release for DPA 3.00
           3772                         ;//   2016/09/12  Release for DPA 2.28
           3773                         ;//   2016/04/14  Release for DPA 2.27
           3774                         ;//   2016/03/03  Release for DPA 2.26
           3775                         ;//   2016/01/21  Release for DPA 2.25
           3776                         ;//   2015/12/01  Release for DPA 2.24
           3777                         ;//   2015/10/23  Release for DPA 2.23
           3778                         ;//   2015/09/25  Release for DPA 2.22
           3779                         ;//   2015/09/03  Release for DPA 2.21
           3780                         ;//   2015/08/05  Release for DPA 2.20
           3781                         ;//   2014/10/31  Release for DPA 2.10
           3782                         ;//   2014/04/30  Release for DPA 2.00
           3783                         ;//   2013/10/03  Release for DPA 1.00
           3784                         ;//
           3785                         ;// *********************************************************************
           3786                         ;
           3787                         ;// Online DPA documentation https://doc.iqrf.org/DpaTechGuide/
           3788                         ;// IQRF Standards documentation https://doc.iqrf.org/
           3789                         ;
           3790                         ;#ifndef _CUSTOM_DPA_HANDLER_
           3791                         ;#define _CUSTOM_DPA_HANDLER_
           3792                         ;
           3793                         ;//############################################################################################
           3794                         ;// 1st include
           3795                         ;
           3796                         ;// Custom DPA Handler routine declaration
           3797                         ;bit CustomDpaHandler();
           3798                         ;
           3799                         ;// Various DPA flags shared between DPA and Custom DPA Handler
           3800                         ;uns8 DpaFlags @ usedBank4[0];
           3801                         ;
           3802                         ;// [C][N] TRUE if I2C timeout occurred at the last DpaApiI2C?() call
           3803                         ;bit I2CwasTimeout @ DpaFlags.0;
           3804                         ;// [N] Flag for the 1st DpaApiSleep
           3805                         ;bit FirstDpaApiSleep @ DpaFlags.1;
           3806                         ;
           3807                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           3808                         ;// [C] TRUE if interface master is not connected (detected)
           3809                         ;bit IFaceMasterNotConnected @ DpaFlags.2;
           3810                         ;#endif
           3811                         ;// [N] DPA by interface notification is sent also when there was a "reading" like DPA request
           3812                         ;bit EnableIFaceNotificationOnRead @ DpaFlags.3;
           3813                         ;// [N] TRUE when node was just bonded using default bonding procedure
           3814                         ;bit NodeWasBonded @ DpaFlags.4;
           3815                         ;// [N] When TRUE, then next call of DpaApiRfTxDpaPacket sends non-routed packet
           3816                         ;bit NonroutedRfTxDpaPacket @ DpaFlags.7;
           3817                         ;
           3818                         ;// [C] Ticks (decrementing) counter usable for timing in the coordinator's Customer DPA Handler
           3819                         ;uns16 DpaTicks @ usedBank4[1];
           3820                         ;// [N] toutRF for LP mode, read from configuration memory after reset
           3821                         ;uns8 LPtoutRF @ usedBank4[3];
           3822                         ;// DPA Request/Response HWPID
           3823                         ;uns16 _HWPID @ usedBank4[4];
           3824                         ;// Identifies type of reset (stored at UserReg0 upon module reset). See Reset chapter at IQRF User's Guide for more information
           3825                         ;uns8 ResetType @ usedBank4[6];
           3826                         ;// User DPA Values to return
           3827                         ;uns8 UserDpaValue @ usedBank4[7];
           3828                         ;// Network depth of the DPA request/response, increases on bridging, decreases on back-bridging
           3829                         ;uns8 NetDepth @ usedBank4[8];
           3830                         ;// TRUE when node was at DPA Service Mode after last boot
           3831                         ;bit DSMactivated @ usedBank4[9].0;
           3832                         ;// If set to TRUE, then LP RX mode in the main loop can be terminated by pin, see _RLPMAT
           3833                         ;bit LpRxPinTerminate @ usedBank4[9].1;
           3834                         ;// If set to TRUE, then [C] executes asynchronous DPA requests received from [N]
           3835                         ;bit AsyncReqAtCoordinator @ usedBank4[9].2;
           3836                         ;// RX filter used at the DPA main loop checkRF call
           3837                         ;uns8 RxFilter @ usedBank4[11];
           3838                         ;// Countdown variable for button bonding before going to deep sleep
           3839                         ;uns16 BondingSleepCountdown @ usedBank4[12];
           3840                         ;#define BONDING_SLEEP_COUNTDOWN_UNIT  290
           3841                         ;// Non-zero pseudo-random value, read-only, updated on every Reset and Idle event, at [N] only.
           3842                         ;uns16 Random @ usedBank4[14];
           3843                         ;// DPA value from the received packet or just to be sent to the interface.
           3844                         ;uns8 DpaValue @ usedBank4[16];
           3845                         ;// If non-zero then timeout value for DpaApiI2C?() calls
           3846                         ;uns8 I2Ctimeout @ usedBank4[17];
           3847                         ;
           3848                         ;// Macro to return an error from the peripheral handler. If the code size is not an issue this macro is the right choice.
           3849                         ;#define DpaApiReturnPeripheralError(error) do { \
           3850                         ;    DpaApiSetPeripheralError( error ); \
           3851                         ;    return Carry; \
           3852                         ;  } while( 0 )
           3853                         ;
           3854                         ;// DPA API functions, see documentation for details
           3855                         ;#define DpaApiRfTxDpaPacket( dpaValue, netDepthAndFlags ) DpaApiEntry( dpaValue, netDepthAndFlags, DPA_API_RFTX_DPAPACKET )
           3856                         ;#define DpaApiReadConfigByte( index )                     DpaApiEntry( index, param3.low8, DPA_API_READ_CONFIG_BYTE )
           3857                         ;#define DpaApiLocalRequest()                              DpaApiEntry( param2, param3.low8, DPA_API_LOCAL_REQUEST )
           3858                         ;#define DpaApiSetPeripheralError( error )                 DpaApiEntry( error, param3.low8, DPA_API_SET_PERIPHERAL_ERROR )
           3859                         ;#define DpaApiSendToIFaceMaster( dpaValue, flags )        DpaApiEntry( dpaValue, flags, DPA_API_SEND_TO_IFACEMASTER )
           3860                         ;#define DpaApiSetRfDefaults()                             DpaApiEntry( param2, param3.low8, DPA_API_SET_RF_DEFAULTS )
           3861                         ;#define DpaApiLocalFrc( frcCommand, replyTxPower )        DpaApiEntry( frcCommand, replyTxPower, DPA_API_LOCAL_FRC )
           3862                         ;#define DpaApiCrc8( crc8, data )                          DpaApiEntry( crc8, data, DPA_API_CRC8 )
           3863                         ;#define DpaApiAggregateFrc()                              DpaApiEntry( param2, param3.low8, DPA_API_AGGREGATE_FRC )
           3864                         ;#define DpaApiSetOTK()                                    DpaApiEntry( param2, param3.low8, DPA_API_SET_OTK )
           3865                         ;#define DpaApiI2Cinit( frequency )                        DpaApiEntry( frequency, param3.low8, DPA_API_I2C_INIT )
           3866                         ;#define DpaApiI2Cstart( address )                         DpaApiEntry( address, param3.low8, DPA_API_I2C_START )
           3867                         ;#define DpaApiI2Cwrite( data )                            DpaApiEntry( data, param3.low8, DPA_API_I2C_WRITE )
           3868                         ;#define DpaApiI2Cread( ack )                              DpaApiEntry( ack, param3.low8, DPA_API_I2C_READ )
           3869                         ;#define DpaApiI2Cstop()                                   DpaApiEntry( param2, param3.low8, DPA_API_I2C_STOP )
           3870                         ;#define DpaApiI2CwaitForACK( address )                    DpaApiEntry( address, param3.low8, DPA_API_I2C_WAIT_FOR_ACK )
           3871                         ;#define DpaApiI2Cshutdown()                               DpaApiEntry( param2, param3.low8, DPA_API_I2C_SHUTDOWN )
           3872                         ;#define DpaApiI2CwaitForIdle()                            DpaApiEntry( param2, param3.low8, DPA_API_I2C_WAIT_FOR_IDLE )
           3873                         ;#define DpaApiSleep( wdtcon )                             DpaApiEntry( wdtcon, param3.low8, DPA_API_SLEEP )
           3874                         ;#define DpaApiAfterSleep()                                DpaApiEntry( param2, param3.low8, DPA_API_AFTER_SLEEP )
           3875                         ;#define DpaApiRandom()                                    DpaApiEntry( param2, param3.low8, DPA_API_RANDOM )
           3876                         ;
           3877                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           3878                         ;#define DpaApiRfTxDpaPacketCoordinator()                  DpaApiEntry( param2, param3.low8, DPA_API_COORDINATOR_RFTX_DPAPACKET )
           3879                         ;#endif
           3880                         ;
           3881                         ;#if !defined( TR7xD )
           3882                         ;#define DpaApiMenu( menu, flags )                         DpaApiEntry( menu, flags, DPA_API_MENU )
           3883                         ;#define DpaApiMenuIndicateResult( ok )                    DpaApiEntry( ok, param3.low8, DPA_API_MENU_INDICATE_RESULT )
           3884                         ;#define DpaApiMenuExecute( menuAndItem )                  DpaApiEntry( menuAndItem, param3.low8, DPA_API_MENU_EXECUTE )
           3885                         ;#define DpaApiDeepSleep( wdtcon )                         DpaApiEntry( wdtcon, param3.low8, DPA_API_DEEP_SLEEP )
           3886                         ;#endif
           3887                         ;
           3888                         ;#define DpaApiLocalFrc_StackSaver( frcCommand, replyTxPower ) \
           3889                         ;  param2 = frcCommand; \
           3890                         ;  param3.low8 = replyTxPower; \
           3891                         ;  W = DPA_API_LOCAL_FRC; \
           3892                         ;  #asm \
           3893                         ;    DW  __MOVLP( DPA_API_ADDRESS >> 8 ); \
           3894                         ;    DW  __CALL( DPA_API_ADDRESS ); \
           3895                         ;    DW  __MOVLP( CUSTOM_HANDLER_ADDRESS >> 8 ); \
           3896                         ;  #endasm \
           3897                         ;
           3898                         ;#define I2CcomputeFrequency( I2Cfrequency)                ( ( ( F_OSC ) / ( ( I2Cfrequency ) * 4 ) ) - 1 )
           3899                         ;
           3900                         ;// Wrapper routines to be called instead of DpaApi??? macros to decrease code size if more than ~2 calls are needed
           3901                         ;void _DpaApiI2Cinit( uns8 frequency );
           3902                         ;void _DpaApiI2Cstart( uns8 address );
           3903                         ;void _DpaApiI2Cwrite( uns8 data );
           3904                         ;uns8 _DpaApiI2Cread( uns8 ack );
           3905                         ;void _DpaApiI2Cstop();
           3906                         ;void _DpaApiI2CwaitForACK( uns8 address );
           3907                         ;void _DpaApiI2Cshutdown();
           3908                         ;void _DpaApiI2CwaitForIdle();
           3909                         ;void _DpaApiSleep( uns8 wdtcon );
           3910                         ;#if !defined( TR7xD )
           3911                         ;void _DpaApiDeepSleep( uns8 wdtcon );
           3912                         ;#endif
           3913                         ;void _DpaApiSleepFirst( uns8 wdtcon );
           3914                         ;void _DpaApiAfterSleep();
           3915                         ;uns8 _DpaApiRandom();
           3916                         ;void _DpaApiSetRfDefaults();
           3917                         ;
           3918                         ;// Helper "multi" function to decrease code size if used more times
           3919                         ;void _DpaApiI2Cwrite0();
           3920                         ;void _DpaApiI2CwriteAndStop( uns8 data );
           3921                         ;uns8 _DpaApiI2CreadACK();
           3922                         ;uns8 _DpaApiI2CreadNACK();
           3923                         ;uns8 _DpaApiI2CreadNACKandStop();
           3924                         ;
           3925                         ;#ifdef COORDINATOR_CUSTOM_HANDLER
           3926                         ;#undef  DpaEvent_Interrupt
           3927                         ;#undef  DpaEvent_BeforeSleep
           3928                         ;#undef  DpaEvent_AfterSleep
           3929                         ;#undef  DpaEvent_FrcValue
           3930                         ;#undef  DpaEvent_FrcResponseTime
           3931                         ;#else
           3932                         ;#undef  DpaEvent_ReceiveDpaResponse
           3933                         ;#undef  DpaEvent_IFaceReceive
           3934                         ;#endif
           3935                         ;
           3936                         ;// To detect overlapping code in case someone would put some code before this header by mistake
           3937                         ;#pragma origin __APPLICATION_ADDRESS
           3938                         ;#pragma updateBank 0
           3939                         ;
           3940                         ;//############################################################################################
           3941                         ;// Main IQRF entry point jumps to the main DPA entry point
           3942                         ;void APPLICATION()
           3943                         ;//############################################################################################
           3944                         ;{
           3945                         ;  #asm
           3946                         ;    DW  __MOVLP( MAIN_DPA_ADDRESS >> 8 );
           3947                         ;  DW  __GOTO( MAIN_DPA_ADDRESS );
           3948                         ;  #endasm
           3949                         ;
           3950                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           3951                         ;    // Fake call to force CustomDpaHandler() compilation
           3952                         ;    CustomDpaHandler();
           3953                         ;#endif
           3954                         ;
           3955                         ;  // Fake call to force DpaApiEntry() compilation
           3956                         ;  DpaApiEntry( param2, param3.low8, W );
           3957                         ;}
           3958                         ;
           3959                         ;//############################################################################################
           3960                         ;// Entry stub to the real DPA API entry
           3961                         ;#pragma origin DPA_API_ADDRESS_ENTRY
           3962                         ;uns8  DpaApiEntry( uns8 par1 @ param2, uns8 par2 @ param3.low8, uns8 apiIndex @ W )
           3963                         ;//############################################################################################
           3964                         ;{
           3965                         ;  #asm
           3966                         ;    DW  __MOVLP( DPA_API_ADDRESS >> 8 );
           3967                         ;  DW  __CALL( DPA_API_ADDRESS );
           3968                         ;  DW  __MOVLP( DPA_API_ADDRESS_ENTRY >> 8 );
           3969                         ;  #endasm
           3970                         ;
           3971                         ;    return W;
           3972                         ;}
           3973                         ;
           3974                         ;//############################################################################################
           3975                         ;#pragma origin DPA_API_ADDRESS_ENTRY + 0x08
           3976                         ;
           3977                         ;//############################################################################################
           3978                         ;
           3979                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           3980                         ;// Next comes Custom DPA handler routine
           3981                         ;#pragma origin CUSTOM_HANDLER_ADDRESS
           3982                         ;#endif
           3983                         ;
           3984                         ;#pragma updateBank 1
           3985                         ;
           3986                         ;//############################################################################################
           3987                         ;#else // _CUSTOM_DPA_HANDLER_
           3988                         ;//############################################################################################
           3989                         ;// 2nd include
           3990                         ;
           3991                         ;#ifndef NO_CUSTOM_DPA_HANDLER
           3992                         ;
           3993                         ;// Library wrappers and helpers to decrease code size
           3994                         ;//############################################################################################
           3995                         ;#pragma library 1
           3996                         ;//############################################################################################
           3997                         ;uns8 _DpaApiUserBank_01( uns8 apiIndex @ W )
           3998                         ;//############################################################################################
           3999                         ;{
           4000 _DpaApiUserBank_01
           4001                         ;#pragma updateBank exit = UserBank_01
           4002                         ;  return DpaApiEntry( param2, param3.low8, apiIndex );
           4003                         ;}
           4004                         ;//############################################################################################
           4005                         ;void _DpaApiI2Cinit( uns8 frequency @ W )
           4006                         ;//############################################################################################
           4007                         ;{
           4008 _DpaApiI2Cinit
           4009                         ;#pragma updateBank exit = UserBank_01
           4010                         ;  param2 = frequency;
           4011                         ;  _DpaApiUserBank_01( DPA_API_I2C_INIT );
           4012                         ;}
           4013                         ;//############################################################################################
           4014                         ;void _DpaApiI2Cstart( uns8 address @ W )
           4015                         ;//############################################################################################
           4016                         ;{
           4017 _DpaApiI2Cstart
           4018                         ;#pragma updateBank exit = UserBank_01
           4019                         ;  param2 = address;
           4020                         ;  _DpaApiUserBank_01( DPA_API_I2C_START );
           4021                         ;}
           4022                         ;//############################################################################################
           4023                         ;void _DpaApiI2Cwrite0()
           4024                         ;//############################################################################################
           4025                         ;{
           4026 _DpaApiI2Cwrite0
           4027                         ;#pragma updateBank exit = UserBank_01
           4028                         ;  _DpaApiI2Cwrite( 0 );
           4029                         ;}
           4030                         ;//############################################################################################
           4031                         ;void _DpaApiI2Cwrite( uns8 data @ W )
           4032                         ;//############################################################################################
           4033                         ;{
           4034 _DpaApiI2Cwrite
           4035                         ;#pragma updateBank exit = UserBank_01
           4036                         ;  param2 = data;
           4037                         ;  _DpaApiUserBank_01( DPA_API_I2C_WRITE );
           4038                         ;}
           4039                         ;//############################################################################################
           4040                         ;uns8 _DpaApiI2CreadNACKandStop()
           4041                         ;//############################################################################################
           4042                         ;{
           4043 _DpaApiI2CreadNACKandStop
           4044                         ;#pragma updateBank exit = UserBank_01
           4045                         ;  param2 = _DpaApiI2CreadNACK();
           4046                         ;  _DpaApiI2Cstop(); /* Must not use param2 */
           4047                         ;  return param2;
           4048                         ;}
           4049                         ;//############################################################################################
           4050                         ;uns8 _DpaApiI2CreadACK()
           4051                         ;//############################################################################################
           4052                         ;{
           4053 _DpaApiI2CreadACK
           4054                         ;#pragma updateBank exit = UserBank_01
           4055                         ;  return _DpaApiI2Cread( 1 );
           4056                         ;}
           4057                         ;//############################################################################################
           4058                         ;uns8 _DpaApiI2CreadNACK()
           4059                         ;//############################################################################################
           4060                         ;{
           4061 _DpaApiI2CreadNACK
           4062                         ;#pragma updateBank exit = UserBank_01
           4063                         ;  return _DpaApiI2Cread( 0 );
           4064                         ;}
           4065                         ;//############################################################################################
           4066                         ;uns8 _DpaApiI2Cread( uns8 ack @ W )
           4067                         ;//############################################################################################
           4068                         ;{
           4069 _DpaApiI2Cread
           4070                         ;#pragma updateBank exit = UserBank_01
           4071                         ;  param2 = ack;
           4072                         ;  return _DpaApiUserBank_01( DPA_API_I2C_READ );
           4073                         ;}
           4074                         ;//############################################################################################
           4075                         ;void _DpaApiI2CwriteAndStop( uns8 data @ W )
           4076                         ;//############################################################################################
           4077                         ;{
           4078 _DpaApiI2CwriteAndStop
           4079                         ;#pragma updateBank exit = UserBank_01
           4080                         ;  _DpaApiI2Cwrite( data );
           4081                         ;  _DpaApiI2Cstop();
           4082                         ;}
           4083                         ;//############################################################################################
           4084                         ;void _DpaApiI2Cstop()
           4085                         ;//############################################################################################
           4086                         ;{
           4087 _DpaApiI2Cstop
           4088                         ;#pragma updateBank exit = UserBank_01
           4089                         ;  _DpaApiUserBank_01( DPA_API_I2C_STOP );
           4090                         ;}
           4091                         ;//############################################################################################
           4092                         ;void _DpaApiI2CwaitForACK( uns8 address @ W )
           4093                         ;//############################################################################################
           4094                         ;{
           4095 _DpaApiI2CwaitForACK
           4096                         ;#pragma updateBank exit = UserBank_01
           4097                         ;  DpaApiI2CwaitForACK( address );
           4098                         ;}
           4099                         ;//############################################################################################
           4100                         ;void _DpaApiI2Cshutdown()
           4101                         ;//############################################################################################
           4102                         ;{
           4103 _DpaApiI2Cshutdown
           4104                         ;#pragma updateBank exit = UserBank_01
           4105                         ;  _DpaApiUserBank_01( DPA_API_I2C_SHUTDOWN );
           4106                         ;}
           4107                         ;//############################################################################################
           4108                         ;void _DpaApiI2CwaitForIdle()
           4109                         ;//############################################################################################
           4110                         ;{
           4111 _DpaApiI2CwaitForIdle
           4112                         ;#pragma updateBank exit = UserBank_01
           4113                         ;  _DpaApiUserBank_01( DPA_API_I2C_WAIT_FOR_IDLE );
           4114                         ;}
           4115                         ;//############################################################################################
           4116                         ;void _DpaApiSleep( uns8 wdtcon @ W )
           4117                         ;//############################################################################################
           4118                         ;{
           4119 _DpaApiSleep
           4120                         ;#pragma updateBank exit = UserBank_01
           4121                         ;  param2 = wdtcon;
           4122                         ;  _DpaApiUserBank_01( DPA_API_SLEEP );
           4123                         ;}
           4124                         ;#if !defined( TR7xD )
           4125                         ;//############################################################################################
           4126                         ;void _DpaApiDeepSleep( uns8 wdtcon @ W )
           4127                         ;//############################################################################################
           4128                         ;{
           4129 _DpaApiDeepSleep
           4130                         ;#pragma updateBank exit = UserBank_01
           4131                         ;  param2 = wdtcon;
           4132                         ;  _DpaApiUserBank_01( DPA_API_DEEP_SLEEP );
           4133                         ;}
           4134                         ;#endif
           4135                         ;//############################################################################################
           4136                         ;void _DpaApiSleepFirst( uns8 wdtcon @ W )
           4137                         ;//############################################################################################
           4138                         ;{
           4139 _DpaApiSleepFirst
           4140                         ;#pragma updateBank exit = UserBank_01
           4141                         ;  FirstDpaApiSleep = TRUE;
           4142                         ;  _DpaApiSleep( wdtcon );
           4143                         ;}
           4144                         ;//############################################################################################
           4145                         ;void _DpaApiAfterSleep()
           4146                         ;//############################################################################################
           4147                         ;{
           4148 _DpaApiAfterSleep
           4149                         ;#pragma updateBank exit = UserBank_01
           4150                         ;  _DpaApiUserBank_01( DPA_API_AFTER_SLEEP );
           4151                         ;}
           4152                         ;//############################################################################################
           4153                         ;uns8 _DpaApiRandom()
           4154                         ;//############################################################################################
           4155                         ;{
           4156 _DpaApiRandom
           4157                         ;#pragma updateBank exit = UserBank_01
           4158                         ;  return _DpaApiUserBank_01( DPA_API_RANDOM );
           4159                         ;}
           4160                         ;//############################################################################################
           4161                         ;void _DpaApiSetRfDefaults()
           4162                         ;//############################################################################################
           4163                         ;{
           4164 _DpaApiSetRfDefaults
           4165                         ;#pragma updateBank exit = UserBank_01
           4166                         ;  _DpaApiUserBank_01( DPA_API_SET_RF_DEFAULTS );
           4167                         ;}
           4168                         ;//############################################################################################
           4169                         ;
           4170                         ;// Code bumper to detect too long code of Custom DPA handler + other routines
           4171                         ;#pragma origin CUSTOM_HANDLER_ADDRESS_END
     0000  4172         ORG 0x4F00
           4173                         ;// To avoid adding some code after handler by mistake
           4174                         ;#pragma origin __MAX_FLASH_ADDRESS
     0000  4175         ORG 0x7FFF
           4176 
     0000  4177         ORG 0x3800
3800 0046  4178         DATA 0046H
3801 0005  4179         DATA 0005H
3802 0082  4180         DATA 0082H
           4181         END
           4182 
           4183 
           4184 ; *** KEY INFO ***
           4185 
           4186 ; 0x0100 P0    5 word(s)  0 % : main
           4187 
           4188 ; 0x3A00 P7    4 word(s)  0 % : APPLICATION
           4189 ; 0x3810 P7    2 word(s)  0 % : dummy
           4190 ; 0x3816 P7    2 word(s)  0 % : iqrfSleep
           4191 ; 0x3819 P7    2 word(s)  0 % : _debug
           4192 ; 0x381C P7    2 word(s)  0 % : moduleInfo
           4193 ; 0x3822 P7    2 word(s)  0 % : pulsingLEDR
           4194 ; 0x3825 P7    2 word(s)  0 % : pulseLEDR
           4195 ; 0x3828 P7    2 word(s)  0 % : stopLEDR
           4196 ; 0x382B P7    2 word(s)  0 % : pulsingLEDG
           4197 ; 0x382E P7    2 word(s)  0 % : pulseLEDG
           4198 ; 0x3831 P7    2 word(s)  0 % : stopLEDG
           4199 ; 0x3834 P7    2 word(s)  0 % : setOnPulsingLED
           4200 ; 0x3837 P7    2 word(s)  0 % : setOffPulsingLED
           4201 ; 0x383A P7    2 word(s)  0 % : eeReadByte
           4202 ; 0x383D P7    2 word(s)  0 % : eeReadData
           4203 ; 0x3840 P7    2 word(s)  0 % : eeWriteByte
           4204 ; 0x3843 P7    2 word(s)  0 % : eeWriteData
           4205 ; 0x3846 P7    2 word(s)  0 % : readFromRAM
           4206 ; 0x384C P7    2 word(s)  0 % : clearBufferINFO
           4207 ; 0x384F P7    2 word(s)  0 % : swapBufferINFO
           4208 ; 0x3852 P7    2 word(s)  0 % : compareBufferINFO2RF
           4209 ; 0x3855 P7    2 word(s)  0 % : copyBufferINFO2COM
           4210 ; 0x3858 P7    2 word(s)  0 % : copyBufferINFO2RF
           4211 ; 0x385B P7    2 word(s)  0 % : copyBufferRF2COM
           4212 ; 0x385E P7    2 word(s)  0 % : copyBufferRF2INFO
           4213 ; 0x3861 P7    2 word(s)  0 % : copyBufferCOM2RF
           4214 ; 0x3864 P7    2 word(s)  0 % : copyBufferCOM2INFO
           4215 ; 0x3867 P7    2 word(s)  0 % : copyMemoryBlock
           4216 ; 0x386A P7    2 word(s)  0 % : startDelay
           4217 ; 0x386D P7    2 word(s)  0 % : startLongDelay
           4218 ; 0x3870 P7    2 word(s)  0 % : isDelay
           4219 ; 0x3873 P7    2 word(s)  0 % : waitDelay
           4220 ; 0x3876 P7    2 word(s)  0 % : waitMS
           4221 ; 0x3879 P7    2 word(s)  0 % : startCapture
           4222 ; 0x387C P7    2 word(s)  0 % : captureTicks
           4223 ; 0x3882 P7    2 word(s)  0 % : waitNewTick
           4224 ; 0x3885 P7    2 word(s)  0 % : enableSPI
           4225 ; 0x3888 P7    2 word(s)  0 % : disableSPI
           4226 ; 0x388B P7    2 word(s)  0 % : startSPI
           4227 ; 0x388E P7    2 word(s)  0 % : stopSPI
           4228 ; 0x3891 P7    2 word(s)  0 % : restartSPI
           4229 ; 0x3894 P7    2 word(s)  0 % : getStatusSPI
           4230 ; 0x3897 P7    2 word(s)  0 % : setRFpower
           4231 ; 0x389A P7    2 word(s)  0 % : setLEDG
           4232 ; 0x389D P7    2 word(s)  0 % : setRFchannel
           4233 ; 0x38A0 P7    2 word(s)  0 % : setRFmode
           4234 ; 0x38A3 P7    2 word(s)  0 % : setRFspeed
           4235 ; 0x38A6 P7    2 word(s)  0 % : setRFsleep
           4236 ; 0x38A9 P7    2 word(s)  0 % : setRFready
           4237 ; 0x38AC P7    2 word(s)  0 % : RFTXpacket
           4238 ; 0x38AF P7    2 word(s)  0 % : RFRXpacket
           4239 ; 0x38B2 P7    2 word(s)  0 % : checkRF
           4240 ; 0x38B8 P7    2 word(s)  0 % : amIBonded
           4241 ; 0x38BB P7    2 word(s)  0 % : removeBond
           4242 ; 0x38BE P7    2 word(s)  0 % : bondNewNode
           4243 ; 0x38C1 P7    2 word(s)  0 % : isBondedNode
           4244 ; 0x38C4 P7    2 word(s)  0 % : removeBondedNode
           4245 ; 0x38C7 P7    2 word(s)  0 % : rebondNode
           4246 ; 0x38CA P7    2 word(s)  0 % : clearAllBonds
           4247 ; 0x38CD P7    2 word(s)  0 % : setNonetMode
           4248 ; 0x38D0 P7    2 word(s)  0 % : setCoordinatorMode
           4249 ; 0x38D3 P7    2 word(s)  0 % : setNodeMode
           4250 ; 0x38D6 P7    2 word(s)  0 % : setNetworkFilteringOn
           4251 ; 0x38D9 P7    2 word(s)  0 % : setNetworkFilteringOff
           4252 ; 0x38DC P7    2 word(s)  0 % : getNetworkParams
           4253 ; 0x38DF P7    2 word(s)  0 % : setRoutingOn
           4254 ; 0x38E2 P7    2 word(s)  0 % : setRoutingOff
           4255 ; 0x38E8 P7    2 word(s)  0 % : answerSystemPacket
           4256 ; 0x38EB P7    2 word(s)  0 % : discovery
           4257 ; 0x38EE P7    2 word(s)  0 % : wasRouted
           4258 ; 0x38F1 P7    2 word(s)  0 % : optimizeHops
           4259 ; 0x38F4 P7    2 word(s)  0 % : getSupplyVoltage
           4260 ; 0x38F7 P7    2 word(s)  0 % : getTemperature
           4261 ; 0x38FA P7    2 word(s)  0 % : clearBufferRF
           4262 ; 0x3910 P7    2 word(s)  0 % : isDiscoveredNode
           4263 ; 0x3913 P7    2 word(s)  0 % : enableRFPGM
           4264 ; 0x3916 P7    2 word(s)  0 % : disableRFPGM
           4265 ; 0x3919 P7    2 word(s)  0 % : setupRFPGM
           4266 ; 0x391C P7    2 word(s)  0 % : runRFPGM
           4267 ; 0x391F P7    2 word(s)  0 % : iqrfDeepSleep
           4268 ; 0x3922 P7    2 word(s)  0 % : wasRFICrestarted
           4269 ; 0x3925 P7    2 word(s)  0 % : eeeWriteData
           4270 ; 0x3928 P7    2 word(s)  0 % : eeeReadData
           4271 ; 0x3931 P7    2 word(s)  0 % : setINDF0
           4272 ; 0x3934 P7    2 word(s)  0 % : setINDF1
           4273 ; 0x3937 P7    2 word(s)  0 % : getRSSI
           4274 ; 0x393A P7    2 word(s)  0 % : removeBondAddress
           4275 ; 0x393D P7    2 word(s)  0 % : sendFRC
           4276 ; 0x3940 P7    2 word(s)  0 % : responseFRC
           4277 ; 0x3943 P7    2 word(s)  0 % : bondRequestAdvanced
           4278 ; 0x3946 P7    2 word(s)  0 % : prebondNodeAtNode
           4279 ; 0x3949 P7    2 word(s)  0 % : nodeAuthorization
           4280 ; 0x394C P7    2 word(s)  0 % : dummy01
           4281 ; 0x3958 P7    2 word(s)  0 % : setAccessPassword
           4282 ; 0x395B P7    2 word(s)  0 % : setUserKey
           4283 ; 0x3961 P7    2 word(s)  0 % : amIRecipientOfFRC
           4284 ; 0x3964 P7    2 word(s)  0 % : setLEDR
           4285 ; 0x3967 P7    2 word(s)  0 % : encryptBufferRF
           4286 ; 0x396A P7    2 word(s)  0 % : decryptBufferRF
           4287 ; 0x396D P7    2 word(s)  0 % : prebondNodeAtCoordinator
           4288 ; 0x3970 P7    2 word(s)  0 % : setFSRs
           4289 ; 0x3973 P7    2 word(s)  0 % : updateCRC16
           4290 ; 0x3976 P7    2 word(s)  0 % : smartConnect
           4291 ; 0x3979 P7    2 word(s)  0 % : addressBitmap
           4292 ; 0x397C P7    2 word(s)  0 % : setServiceChannel
           4293 ; 0x3A08 P7    4 word(s)  0 % : DpaApiEntry
           4294 ; 0x3A20 P7   91 word(s)  4 % : CustomDpaHandler
           4295 
           4296 ; RAM usage: 1088 bytes (0 local), 3008 bytes free
           4297 ; Maximum call level: 3
           4298 ;  Codepage 0 has    6 word(s) :   0 %
           4299 ;  Codepage 1 has    0 word(s) :   0 %
           4300 ;  Codepage 2 has    0 word(s) :   0 %
           4301 ;  Codepage 3 has    0 word(s) :   0 %
           4302 ;  Codepage 4 has    0 word(s) :   0 %
           4303 ;  Codepage 5 has    0 word(s) :   0 %
           4304 ;  Codepage 6 has    0 word(s) :   0 %
           4305 ;  Codepage 7 has  310 word(s) :  15 %
           4306 ;  Codepage 8 has    0 word(s) :   0 %
           4307 ;  Codepage 9 has    0 word(s) :   0 %
           4308 ;  Codepage 10 has    0 word(s) :   0 %
           4309 ;  Codepage 11 has    0 word(s) :   0 %
           4310 ;  Codepage 12 has    0 word(s) :   0 %
           4311 ;  Codepage 13 has    0 word(s) :   0 %
           4312 ;  Codepage 14 has    0 word(s) :   0 %
           4313 ;  Codepage 15 has    0 word(s) :   0 %
           4314 ; Total of 316 code words (0 %)
